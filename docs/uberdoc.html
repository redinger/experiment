<!DOCTYPE html>
<html><head><meta charset="utf-8" content="text/html" http-equiv="Content-Type" /><meta content="Evaluation platform of a new model for running, recording and sharing self-experiments" name="description" /><style type="text/css">/**
 * SyntaxHighlighter
 * http://alexgorbatchev.com/SyntaxHighlighter
 *
 * SyntaxHighlighter is donationware. If you are using it, please donate.
 * http://alexgorbatchev.com/SyntaxHighlighter/donate.html
 *
 * @version
 * 3.0.83 (July 02 2010)
 * 
 * @copyright
 * Copyright (C) 2004-2010 Alex Gorbatchev.
 *
 * @license
 * Dual licensed under the MIT and GPL licenses.
 */
.syntaxhighlighter a,
.syntaxhighlighter div,
.syntaxhighlighter code,
.syntaxhighlighter table,
.syntaxhighlighter table td,
.syntaxhighlighter table tr,
.syntaxhighlighter table tbody,
.syntaxhighlighter table thead,
.syntaxhighlighter table caption,
.syntaxhighlighter textarea {
  -moz-border-radius: 0 0 0 0 !important;
  -webkit-border-radius: 0 0 0 0 !important;
  background: none !important;
  border: 0 !important;
  bottom: auto !important;
  float: none !important;
  height: auto !important;
  left: auto !important;
  line-height: 1.1em !important;
/*  margin: 0 !important; */
  outline: 0 !important;
  overflow: visible !important;
  padding: 0 !important;
  position: static !important;
  right: auto !important;
  text-align: left !important;
  top: auto !important;
  vertical-align: baseline !important;
  width: auto !important;
  box-sizing: content-box !important;
  font-family: "Consolas", "Bitstream Vera Sans Mono", "Courier New", Courier, monospace !important;
  font-weight: normal !important;
  font-style: normal !important;
  min-height: inherit !important;
  min-height: auto !important;
}

.syntaxhighlighter {
/*  width: 100% !important; */
  margin: 1em 0 1em 0 !important;
  position: relative !important;
  overflow: auto !important;
}
.syntaxhighlighter.source {
  overflow: hidden !important;
}
.syntaxhighlighter .bold {
  font-weight: bold !important;
}
.syntaxhighlighter .italic {
  font-style: italic !important;
}
.syntaxhighlighter .line {
  white-space: pre !important;
}
.syntaxhighlighter table {
/*    width: 100% !important;*/
}
.syntaxhighlighter table caption {
  text-align: left !important;
  padding: .5em 0 0.5em 1em !important;
}
.syntaxhighlighter table td.code {
  width: 100% !important;
}
.syntaxhighlighter table td.code .container {
  position: relative !important;
}
.syntaxhighlighter table td.code .container textarea {
  box-sizing: border-box !important;
  position: absolute !important;
  left: 0 !important;
  top: 0 !important;
  width: 100% !important;
  height: 100% !important;
  border: none !important;
  background: white !important;
  padding-left: 1em !important;
  overflow: hidden !important;
  white-space: pre !important;
}
.syntaxhighlighter table td.gutter .line {
  text-align: right !important;
  padding: 0 0.5em 0 1em !important;
}
.syntaxhighlighter table td.code .line {
  padding: 0 1em !important;
}
.syntaxhighlighter.nogutter td.code .container textarea, .syntaxhighlighter.nogutter td.code .line {
  padding-left: 0em !important;
}
.syntaxhighlighter.show {
  display: block !important;
}
.syntaxhighlighter.collapsed table {
  display: none !important;
}
.syntaxhighlighter.collapsed .toolbar {
    display: none;
/*  padding: 0.1em 0.8em 0em 0.8em !important;
  font-size: 1em !important;
  position: static !important;
  width: auto !important;
  height: auto !important;*/
}
.syntaxhighlighter.collapsed .toolbar span {
  display: inline !important;
  margin-right: 1em !important;
}
.syntaxhighlighter.collapsed .toolbar span a {
  padding: 0 !important;
  display: none !important;
}
.syntaxhighlighter.collapsed .toolbar span a.expandSource {
  display: inline !important;
}
.syntaxhighlighter .toolbar {
    display: none;
/*  position: absolute !important;
  right: 1px !important;
  top: 1px !important;
  width: 11px !important;
  height: 11px !important;
  font-size: 10px !important;
  z-index: 10 !important;*/
}
.syntaxhighlighter .toolbar span.title {
  display: inline !important;
}
.syntaxhighlighter .toolbar a {
  display: block !important;
  text-align: center !important;
  text-decoration: none !important;
  padding-top: 1px !important;
}
.syntaxhighlighter .toolbar a.expandSource {
  display: none !important;
}
.syntaxhighlighter.ie {
  font-size: .9em !important;
  padding: 1px 0 1px 0 !important;
}
.syntaxhighlighter.ie .toolbar {
  line-height: 8px !important;
}
.syntaxhighlighter.ie .toolbar a {
  padding-top: 0px !important;
}
.syntaxhighlighter.printing .line.alt1 .content,
.syntaxhighlighter.printing .line.alt2 .content,
.syntaxhighlighter.printing .line.highlighted .number,
.syntaxhighlighter.printing .line.highlighted.alt1 .content,
.syntaxhighlighter.printing .line.highlighted.alt2 .content {
  background: none !important;
}
.syntaxhighlighter.printing .line .number {
  color: #bbbbbb !important;
}
.syntaxhighlighter.printing .line .content {
  color: black !important;
}
.syntaxhighlighter.printing .toolbar {
  display: none !important;
}
.syntaxhighlighter.printing a {
  text-decoration: none !important;
}
.syntaxhighlighter.printing .plain, .syntaxhighlighter.printing .plain a {
  color: black !important;
}
.syntaxhighlighter.printing .comments, .syntaxhighlighter.printing .comments a {
  color: #008200 !important;
}
.syntaxhighlighter.printing .string, .syntaxhighlighter.printing .string a {
  color: blue !important;
}
.syntaxhighlighter.printing .keyword {
  color: #006699 !important;
  font-weight: bold !important;
}
.syntaxhighlighter.printing .preprocessor {
  color: gray !important;
}
.syntaxhighlighter.printing .variable {
  color: #aa7700 !important;
}
.syntaxhighlighter.printing .value {
  color: #009900 !important;
}
.syntaxhighlighter.printing .functions {
  color: #ff1493 !important;
}
.syntaxhighlighter.printing .constants {
  color: #0066cc !important;
}
.syntaxhighlighter.printing .script {
  font-weight: bold !important;
}
.syntaxhighlighter.printing .color1, .syntaxhighlighter.printing .color1 a {
  color: gray !important;
}
.syntaxhighlighter.printing .color2, .syntaxhighlighter.printing .color2 a {
  color: #ff1493 !important;
}
.syntaxhighlighter.printing .color3, .syntaxhighlighter.printing .color3 a {
  color: red !important;
}
.syntaxhighlighter.printing .break, .syntaxhighlighter.printing .break a {
  color: black !important;
}
</style><style type="text/css">.syntaxhighlighter{overflow:hidden !important;}</style><style type="text/css">/**
 * http://alexgorbatchev.com/SyntaxHighlighter/donate.html
 *
 * @version
 * 3.0.83 (July 02 2010)
 * 
 * @copyright
 * Copyright (C) 2004-2010 Alex Gorbatchev.
 *
 * @license
 * Dual licensed under the MIT and GPL licenses.
 */
.syntaxhighlighter {
  background-color: transparent !important;
}
.syntaxhighlighter .line.alt1 {
  background-color: transparent !important;
}
.syntaxhighlighter .line.alt2 {
  background-color: transparent !important;
}
.syntaxhighlighter .line.highlighted.alt1, .syntaxhighlighter .line.highlighted.alt2 {
  background-color: #c3defe !important;
}
.syntaxhighlighter .line.highlighted.number {
  color: white !important;
}
.syntaxhighlighter table caption {
  color: black !important;
}
.syntaxhighlighter .gutter {
  color: #787878 !important;
}
.syntaxhighlighter .gutter .line {
  border-right: 3px solid #d4d0c8 !important;
}
.syntaxhighlighter .gutter .line.highlighted {
  background-color: #d4d0c8 !important;
  color: white !important;
}
.syntaxhighlighter.printing .line .content {
  border: none !important;
}
.syntaxhighlighter.collapsed {
  overflow: visible !important;
}
.syntaxhighlighter.collapsed .toolbar {
  color: #3f5fbf !important;
  background: white !important;
  border: 1px solid #d4d0c8 !important;
}
.syntaxhighlighter.collapsed .toolbar a {
  color: #3f5fbf !important;
}
.syntaxhighlighter.collapsed .toolbar a:hover {
  color: #aa7700 !important;
}
.syntaxhighlighter .toolbar {
  color: #a0a0a0 !important;
  background: #d4d0c8 !important;
  border: none !important;
}
.syntaxhighlighter .toolbar a {
  color: #a0a0a0 !important;
}
.syntaxhighlighter .toolbar a:hover {
  color: red !important;
}
.syntaxhighlighter .plain, .syntaxhighlighter .plain a {
  color: black !important;
}
.syntaxhighlighter .comments, .syntaxhighlighter .comments a {
  color: #3f5fbf !important;
}
.syntaxhighlighter .string, .syntaxhighlighter .string a {
  color: #2a00ff !important;
}
.syntaxhighlighter .keyword {
  color: #7f0055 !important;
}
.syntaxhighlighter .preprocessor {
  color: #646464 !important;
}
.syntaxhighlighter .variable {
  color: #aa7700 !important;
}
.syntaxhighlighter .value {
  color: #009900 !important;
}
.syntaxhighlighter .functions {
  color: #ff1493 !important;
}
.syntaxhighlighter .constants {
  color: #0066cc !important;
}
.syntaxhighlighter .script {
  font-weight: bold !important;
  color: #7f0055 !important;
  background-color: none !important;
}
.syntaxhighlighter .color1, .syntaxhighlighter .color1 a {
  color: gray !important;
}
.syntaxhighlighter .color2, .syntaxhighlighter .color2 a {
  color: #ff1493 !important;
}
.syntaxhighlighter .color3, .syntaxhighlighter .color3 a {
  color: red !important;
}

.syntaxhighlighter .xml .keyword {
  color: #3f7f7f !important;
  font-weight: normal !important;
}
.syntaxhighlighter .xml .color1, .syntaxhighlighter .xml .color1 a {
  color: #7f007f !important;
}
.syntaxhighlighter .xml .string {
  font-style: italic !important;
  color: #2a00ff !important;
}

.clojure.syntaxhighlighter .invalid { 
   background-color: #FAA !important;
}

.clojure.syntaxhighlighter .quoted {      
    font-style: italic !important;
}

.syntaxhighlighter .clojure.variable,
.syntaxhighlighter .clojure.symbol,
.syntaxhighlighter .clojure.value
{
    color: #006060 !important;
}

.syntaxhighlighter .clojure.string {
    color: #55B !important;
}

.syntaxhighlighter .clojure.functions {
    color: black !important;
}

.syntaxhighlighter .clojure.color1 {
    color: #666 !important;
}

.syntaxhighlighter .clojure.color3 {
    color: #900 !important;
}

.syntaxhighlighter .clojure.constants {
    color: #1A734D !important;
}

</style><style type="text/css">html{margin:0;padding:0;}h1{margin:0;padding:0;}h2{margin:0;padding:0;}h3{margin:0;padding:0;}h4{margin:0;padding:0;}a{color:#261A3B;}a:visited{color:#261A3B;}</style><style type="text/css">.header{margin-top:30px;}h1.project-name{display:inline;font-size:34px;}h2.project-version{display:inline;margin-left:10px;margin-top:0;font-size:18px;}.toc-link{margin-left:10px;color:#252519;font-size:12px;text-decoration:none;}.toc-link:hover{color:#5050A6;}.toc h1{margin:0;font-size:34px;}.docs-header{margin-bottom:25px;padding-bottom:10px;border-bottom:dotted #aaa 1px;}.toc h1{font-size:24px;}.toc{margin-bottom:40px;border-bottom:solid #bbb 1px;}.toc ul{padding-left:0px;margin-left:20px;margin-top:0;padding-top:0;}.toc li{padding-left:0;list-style-type:none;}.dependencies{}.dependencies table{border:none;width:99.99%;margin-left:20px;font-size:16px;}.dependencies td{padding-right:20px;;white-space:nowrap;}.dependencies .dotted{width:99%;}.dependencies .dotted hr{margin-bottom:-6px;noshade:noshade;border-top:none;color:transparent;border-left:none;border-bottom:dotted #bbb 1px;border-right:none;background-color:transparent;height:0;}.dependencies .dep-version{text-align:right;}.plugins ul{padding-left:0px;margin-left:20px;margin-top:0;padding-top:0;}.plugins li{padding-left:0;list-style-type:none;}.header p{margin-left:20px;}</style><style type="text/css">#floating-toc{position:fixed;text-align:right;overflow:hidden;top:10px;right:20px;height:20px;}#floating-toc li{margin:0;padding:0;list-style-type:none;}</style><style type="text/css">body{margin:0;padding:0;color:#252519;font-size:16px;background-color:#F5F5FF;font-family:'Palatino Linotype', 'Book Antiqua', Palatino, FreeSerif, serif;;}h1{margin-top:0;font-size:20px;}a.anchor{color:#252519;text-decoration:none;}a.anchor:hover{color:#5050A6;}table{margin-bottom:10px;border-bottom:solid #ddd 1px;;border-spacing:0;}code{display:inline;}p{margin-top:8px;}tr{margin:0px;padding:0px;}td.docs{border:none;margin:0px;padding-left:55px;width:410px;padding-right:20px;vertical-align:top;max-width:410px;background-color:#FFF;}td.docs pre{font-size:12px;overflow:hidden;}td.codes{border:none;margin:0px;padding-left:20px;width:55%;border-left:solid #E5E5EE 1px;font-size:10pt;vertical-align:top;overflow:hidden;background-color:#F5F5FF;}td.spacer{padding-bottom:40px;}pre code{display:block;padding:4px;}code{border:solid #DEDEDE 1px;padding-left:3px;padding-right:3px;font-size:14px;background-color:ghostWhite;}.syntaxhighlighter code{font-size:13px;}.footer{text-align:center;}</style><script type="text/javascript">/*!
 * jQuery JavaScript Library v1.4.4
 * http://jquery.com/
 *
 * Copyright 2010, John Resig
 * Dual licensed under the MIT or GPL Version 2 licenses.
 * http://jquery.org/license
 *
 * Includes Sizzle.js
 * http://sizzlejs.com/
 * Copyright 2010, The Dojo Foundation
 * Released under the MIT, BSD, and GPL Licenses.
 *
 * Date: Thu Nov 11 19:04:53 2010 -0500
 */
(function(E,B){function ka(a,b,d){if(d===B&&a.nodeType===1){d=a.getAttribute("data-"+b);if(typeof d==="string"){try{d=d==="true"?true:d==="false"?false:d==="null"?null:!c.isNaN(d)?parseFloat(d):Ja.test(d)?c.parseJSON(d):d}catch(e){}c.data(a,b,d)}else d=B}return d}function U(){return false}function ca(){return true}function la(a,b,d){d[0].type=a;return c.event.handle.apply(b,d)}function Ka(a){var b,d,e,f,h,l,k,o,x,r,A,C=[];f=[];h=c.data(this,this.nodeType?"events":"__events__");if(typeof h==="function")h=
h.events;if(!(a.liveFired===this||!h||!h.live||a.button&&a.type==="click")){if(a.namespace)A=RegExp("(^|\\.)"+a.namespace.split(".").join("\\.(?:.*\\.)?")+"(\\.|$)");a.liveFired=this;var J=h.live.slice(0);for(k=0;k<J.length;k++){h=J[k];h.origType.replace(X,"")===a.type?f.push(h.selector):J.splice(k--,1)}f=c(a.target).closest(f,a.currentTarget);o=0;for(x=f.length;o<x;o++){r=f[o];for(k=0;k<J.length;k++){h=J[k];if(r.selector===h.selector&&(!A||A.test(h.namespace))){l=r.elem;e=null;if(h.preType==="mouseenter"||
h.preType==="mouseleave"){a.type=h.preType;e=c(a.relatedTarget).closest(h.selector)[0]}if(!e||e!==l)C.push({elem:l,handleObj:h,level:r.level})}}}o=0;for(x=C.length;o<x;o++){f=C[o];if(d&&f.level>d)break;a.currentTarget=f.elem;a.data=f.handleObj.data;a.handleObj=f.handleObj;A=f.handleObj.origHandler.apply(f.elem,arguments);if(A===false||a.isPropagationStopped()){d=f.level;if(A===false)b=false;if(a.isImmediatePropagationStopped())break}}return b}}function Y(a,b){return(a&&a!=="*"?a+".":"")+b.replace(La,
"`").replace(Ma,"&")}function ma(a,b,d){if(c.isFunction(b))return c.grep(a,function(f,h){return!!b.call(f,h,f)===d});else if(b.nodeType)return c.grep(a,function(f){return f===b===d});else if(typeof b==="string"){var e=c.grep(a,function(f){return f.nodeType===1});if(Na.test(b))return c.filter(b,e,!d);else b=c.filter(b,e)}return c.grep(a,function(f){return c.inArray(f,b)>=0===d})}function na(a,b){var d=0;b.each(function(){if(this.nodeName===(a[d]&&a[d].nodeName)){var e=c.data(a[d++]),f=c.data(this,
e);if(e=e&&e.events){delete f.handle;f.events={};for(var h in e)for(var l in e[h])c.event.add(this,h,e[h][l],e[h][l].data)}}})}function Oa(a,b){b.src?c.ajax({url:b.src,async:false,dataType:"script"}):c.globalEval(b.text||b.textContent||b.innerHTML||"");b.parentNode&&b.parentNode.removeChild(b)}function oa(a,b,d){var e=b==="width"?a.offsetWidth:a.offsetHeight;if(d==="border")return e;c.each(b==="width"?Pa:Qa,function(){d||(e-=parseFloat(c.css(a,"padding"+this))||0);if(d==="margin")e+=parseFloat(c.css(a,
"margin"+this))||0;else e-=parseFloat(c.css(a,"border"+this+"Width"))||0});return e}function da(a,b,d,e){if(c.isArray(b)&&b.length)c.each(b,function(f,h){d||Ra.test(a)?e(a,h):da(a+"["+(typeof h==="object"||c.isArray(h)?f:"")+"]",h,d,e)});else if(!d&&b!=null&&typeof b==="object")c.isEmptyObject(b)?e(a,""):c.each(b,function(f,h){da(a+"["+f+"]",h,d,e)});else e(a,b)}function S(a,b){var d={};c.each(pa.concat.apply([],pa.slice(0,b)),function(){d[this]=a});return d}function qa(a){if(!ea[a]){var b=c("<"+
a+">").appendTo("body"),d=b.css("display");b.remove();if(d==="none"||d==="")d="block";ea[a]=d}return ea[a]}function fa(a){return c.isWindow(a)?a:a.nodeType===9?a.defaultView||a.parentWindow:false}var t=E.document,c=function(){function a(){if(!b.isReady){try{t.documentElement.doScroll("left")}catch(j){setTimeout(a,1);return}b.ready()}}var b=function(j,s){return new b.fn.init(j,s)},d=E.jQuery,e=E.$,f,h=/^(?:[^<]*(<[\w\W]+>)[^>]*$|#([\w\-]+)$)/,l=/\S/,k=/^\s+/,o=/\s+$/,x=/\W/,r=/\d/,A=/^<(\w+)\s*\/?>(?:<\/\1>)?$/,
C=/^[\],:{}\s]*$/,J=/\\(?:["\\\/bfnrt]|u[0-9a-fA-F]{4})/g,w=/"[^"\\\n\r]*"|true|false|null|-?\d+(?:\.\d*)?(?:[eE][+\-]?\d+)?/g,I=/(?:^|:|,)(?:\s*\[)+/g,L=/(webkit)[ \/]([\w.]+)/,g=/(opera)(?:.*version)?[ \/]([\w.]+)/,i=/(msie) ([\w.]+)/,n=/(mozilla)(?:.*? rv:([\w.]+))?/,m=navigator.userAgent,p=false,q=[],u,y=Object.prototype.toString,F=Object.prototype.hasOwnProperty,M=Array.prototype.push,N=Array.prototype.slice,O=String.prototype.trim,D=Array.prototype.indexOf,R={};b.fn=b.prototype={init:function(j,
s){var v,z,H;if(!j)return this;if(j.nodeType){this.context=this[0]=j;this.length=1;return this}if(j==="body"&&!s&&t.body){this.context=t;this[0]=t.body;this.selector="body";this.length=1;return this}if(typeof j==="string")if((v=h.exec(j))&&(v[1]||!s))if(v[1]){H=s?s.ownerDocument||s:t;if(z=A.exec(j))if(b.isPlainObject(s)){j=[t.createElement(z[1])];b.fn.attr.call(j,s,true)}else j=[H.createElement(z[1])];else{z=b.buildFragment([v[1]],[H]);j=(z.cacheable?z.fragment.cloneNode(true):z.fragment).childNodes}return b.merge(this,
j)}else{if((z=t.getElementById(v[2]))&&z.parentNode){if(z.id!==v[2])return f.find(j);this.length=1;this[0]=z}this.context=t;this.selector=j;return this}else if(!s&&!x.test(j)){this.selector=j;this.context=t;j=t.getElementsByTagName(j);return b.merge(this,j)}else return!s||s.jquery?(s||f).find(j):b(s).find(j);else if(b.isFunction(j))return f.ready(j);if(j.selector!==B){this.selector=j.selector;this.context=j.context}return b.makeArray(j,this)},selector:"",jquery:"1.4.4",length:0,size:function(){return this.length},
toArray:function(){return N.call(this,0)},get:function(j){return j==null?this.toArray():j<0?this.slice(j)[0]:this[j]},pushStack:function(j,s,v){var z=b();b.isArray(j)?M.apply(z,j):b.merge(z,j);z.prevObject=this;z.context=this.context;if(s==="find")z.selector=this.selector+(this.selector?" ":"")+v;else if(s)z.selector=this.selector+"."+s+"("+v+")";return z},each:function(j,s){return b.each(this,j,s)},ready:function(j){b.bindReady();if(b.isReady)j.call(t,b);else q&&q.push(j);return this},eq:function(j){return j===
-1?this.slice(j):this.slice(j,+j+1)},first:function(){return this.eq(0)},last:function(){return this.eq(-1)},slice:function(){return this.pushStack(N.apply(this,arguments),"slice",N.call(arguments).join(","))},map:function(j){return this.pushStack(b.map(this,function(s,v){return j.call(s,v,s)}))},end:function(){return this.prevObject||b(null)},push:M,sort:[].sort,splice:[].splice};b.fn.init.prototype=b.fn;b.extend=b.fn.extend=function(){var j,s,v,z,H,G=arguments[0]||{},K=1,Q=arguments.length,ga=false;
if(typeof G==="boolean"){ga=G;G=arguments[1]||{};K=2}if(typeof G!=="object"&&!b.isFunction(G))G={};if(Q===K){G=this;--K}for(;K<Q;K++)if((j=arguments[K])!=null)for(s in j){v=G[s];z=j[s];if(G!==z)if(ga&&z&&(b.isPlainObject(z)||(H=b.isArray(z)))){if(H){H=false;v=v&&b.isArray(v)?v:[]}else v=v&&b.isPlainObject(v)?v:{};G[s]=b.extend(ga,v,z)}else if(z!==B)G[s]=z}return G};b.extend({noConflict:function(j){E.$=e;if(j)E.jQuery=d;return b},isReady:false,readyWait:1,ready:function(j){j===true&&b.readyWait--;
if(!b.readyWait||j!==true&&!b.isReady){if(!t.body)return setTimeout(b.ready,1);b.isReady=true;if(!(j!==true&&--b.readyWait>0))if(q){var s=0,v=q;for(q=null;j=v[s++];)j.call(t,b);b.fn.trigger&&b(t).trigger("ready").unbind("ready")}}},bindReady:function(){if(!p){p=true;if(t.readyState==="complete")return setTimeout(b.ready,1);if(t.addEventListener){t.addEventListener("DOMContentLoaded",u,false);E.addEventListener("load",b.ready,false)}else if(t.attachEvent){t.attachEvent("onreadystatechange",u);E.attachEvent("onload",
b.ready);var j=false;try{j=E.frameElement==null}catch(s){}t.documentElement.doScroll&&j&&a()}}},isFunction:function(j){return b.type(j)==="function"},isArray:Array.isArray||function(j){return b.type(j)==="array"},isWindow:function(j){return j&&typeof j==="object"&&"setInterval"in j},isNaN:function(j){return j==null||!r.test(j)||isNaN(j)},type:function(j){return j==null?String(j):R[y.call(j)]||"object"},isPlainObject:function(j){if(!j||b.type(j)!=="object"||j.nodeType||b.isWindow(j))return false;if(j.constructor&&
!F.call(j,"constructor")&&!F.call(j.constructor.prototype,"isPrototypeOf"))return false;for(var s in j);return s===B||F.call(j,s)},isEmptyObject:function(j){for(var s in j)return false;return true},error:function(j){throw j;},parseJSON:function(j){if(typeof j!=="string"||!j)return null;j=b.trim(j);if(C.test(j.replace(J,"@").replace(w,"]").replace(I,"")))return E.JSON&&E.JSON.parse?E.JSON.parse(j):(new Function("return "+j))();else b.error("Invalid JSON: "+j)},noop:function(){},globalEval:function(j){if(j&&
l.test(j)){var s=t.getElementsByTagName("head")[0]||t.documentElement,v=t.createElement("script");v.type="text/javascript";if(b.support.scriptEval)v.appendChild(t.createTextNode(j));else v.text=j;s.insertBefore(v,s.firstChild);s.removeChild(v)}},nodeName:function(j,s){return j.nodeName&&j.nodeName.toUpperCase()===s.toUpperCase()},each:function(j,s,v){var z,H=0,G=j.length,K=G===B||b.isFunction(j);if(v)if(K)for(z in j){if(s.apply(j[z],v)===false)break}else for(;H<G;){if(s.apply(j[H++],v)===false)break}else if(K)for(z in j){if(s.call(j[z],
z,j[z])===false)break}else for(v=j[0];H<G&&s.call(v,H,v)!==false;v=j[++H]);return j},trim:O?function(j){return j==null?"":O.call(j)}:function(j){return j==null?"":j.toString().replace(k,"").replace(o,"")},makeArray:function(j,s){var v=s||[];if(j!=null){var z=b.type(j);j.length==null||z==="string"||z==="function"||z==="regexp"||b.isWindow(j)?M.call(v,j):b.merge(v,j)}return v},inArray:function(j,s){if(s.indexOf)return s.indexOf(j);for(var v=0,z=s.length;v<z;v++)if(s[v]===j)return v;return-1},merge:function(j,
s){var v=j.length,z=0;if(typeof s.length==="number")for(var H=s.length;z<H;z++)j[v++]=s[z];else for(;s[z]!==B;)j[v++]=s[z++];j.length=v;return j},grep:function(j,s,v){var z=[],H;v=!!v;for(var G=0,K=j.length;G<K;G++){H=!!s(j[G],G);v!==H&&z.push(j[G])}return z},map:function(j,s,v){for(var z=[],H,G=0,K=j.length;G<K;G++){H=s(j[G],G,v);if(H!=null)z[z.length]=H}return z.concat.apply([],z)},guid:1,proxy:function(j,s,v){if(arguments.length===2)if(typeof s==="string"){v=j;j=v[s];s=B}else if(s&&!b.isFunction(s)){v=
s;s=B}if(!s&&j)s=function(){return j.apply(v||this,arguments)};if(j)s.guid=j.guid=j.guid||s.guid||b.guid++;return s},access:function(j,s,v,z,H,G){var K=j.length;if(typeof s==="object"){for(var Q in s)b.access(j,Q,s[Q],z,H,v);return j}if(v!==B){z=!G&&z&&b.isFunction(v);for(Q=0;Q<K;Q++)H(j[Q],s,z?v.call(j[Q],Q,H(j[Q],s)):v,G);return j}return K?H(j[0],s):B},now:function(){return(new Date).getTime()},uaMatch:function(j){j=j.toLowerCase();j=L.exec(j)||g.exec(j)||i.exec(j)||j.indexOf("compatible")<0&&n.exec(j)||
[];return{browser:j[1]||"",version:j[2]||"0"}},browser:{}});b.each("Boolean Number String Function Array Date RegExp Object".split(" "),function(j,s){R["[object "+s+"]"]=s.toLowerCase()});m=b.uaMatch(m);if(m.browser){b.browser[m.browser]=true;b.browser.version=m.version}if(b.browser.webkit)b.browser.safari=true;if(D)b.inArray=function(j,s){return D.call(s,j)};if(!/\s/.test("\u00a0")){k=/^[\s\xA0]+/;o=/[\s\xA0]+$/}f=b(t);if(t.addEventListener)u=function(){t.removeEventListener("DOMContentLoaded",u,
false);b.ready()};else if(t.attachEvent)u=function(){if(t.readyState==="complete"){t.detachEvent("onreadystatechange",u);b.ready()}};return E.jQuery=E.$=b}();(function(){c.support={};var a=t.documentElement,b=t.createElement("script"),d=t.createElement("div"),e="script"+c.now();d.style.display="none";d.innerHTML="   <link/><table></table><a href='/a' style='color:red;float:left;opacity:.55;'>a</a><input type='checkbox'/>";var f=d.getElementsByTagName("*"),h=d.getElementsByTagName("a")[0],l=t.createElement("select"),
k=l.appendChild(t.createElement("option"));if(!(!f||!f.length||!h)){c.support={leadingWhitespace:d.firstChild.nodeType===3,tbody:!d.getElementsByTagName("tbody").length,htmlSerialize:!!d.getElementsByTagName("link").length,style:/red/.test(h.getAttribute("style")),hrefNormalized:h.getAttribute("href")==="/a",opacity:/^0.55$/.test(h.style.opacity),cssFloat:!!h.style.cssFloat,checkOn:d.getElementsByTagName("input")[0].value==="on",optSelected:k.selected,deleteExpando:true,optDisabled:false,checkClone:false,
scriptEval:false,noCloneEvent:true,boxModel:null,inlineBlockNeedsLayout:false,shrinkWrapBlocks:false,reliableHiddenOffsets:true};l.disabled=true;c.support.optDisabled=!k.disabled;b.type="text/javascript";try{b.appendChild(t.createTextNode("window."+e+"=1;"))}catch(o){}a.insertBefore(b,a.firstChild);if(E[e]){c.support.scriptEval=true;delete E[e]}try{delete b.test}catch(x){c.support.deleteExpando=false}a.removeChild(b);if(d.attachEvent&&d.fireEvent){d.attachEvent("onclick",function r(){c.support.noCloneEvent=
false;d.detachEvent("onclick",r)});d.cloneNode(true).fireEvent("onclick")}d=t.createElement("div");d.innerHTML="<input type='radio' name='radiotest' checked='checked'/>";a=t.createDocumentFragment();a.appendChild(d.firstChild);c.support.checkClone=a.cloneNode(true).cloneNode(true).lastChild.checked;c(function(){var r=t.createElement("div");r.style.width=r.style.paddingLeft="1px";t.body.appendChild(r);c.boxModel=c.support.boxModel=r.offsetWidth===2;if("zoom"in r.style){r.style.display="inline";r.style.zoom=
1;c.support.inlineBlockNeedsLayout=r.offsetWidth===2;r.style.display="";r.innerHTML="<div style='width:4px;'></div>";c.support.shrinkWrapBlocks=r.offsetWidth!==2}r.innerHTML="<table><tr><td style='padding:0;display:none'></td><td>t</td></tr></table>";var A=r.getElementsByTagName("td");c.support.reliableHiddenOffsets=A[0].offsetHeight===0;A[0].style.display="";A[1].style.display="none";c.support.reliableHiddenOffsets=c.support.reliableHiddenOffsets&&A[0].offsetHeight===0;r.innerHTML="";t.body.removeChild(r).style.display=
"none"});a=function(r){var A=t.createElement("div");r="on"+r;var C=r in A;if(!C){A.setAttribute(r,"return;");C=typeof A[r]==="function"}return C};c.support.submitBubbles=a("submit");c.support.changeBubbles=a("change");a=b=d=f=h=null}})();var ra={},Ja=/^(?:\{.*\}|\[.*\])$/;c.extend({cache:{},uuid:0,expando:"jQuery"+c.now(),noData:{embed:true,object:"clsid:D27CDB6E-AE6D-11cf-96B8-444553540000",applet:true},data:function(a,b,d){if(c.acceptData(a)){a=a==E?ra:a;var e=a.nodeType,f=e?a[c.expando]:null,h=
c.cache;if(!(e&&!f&&typeof b==="string"&&d===B)){if(e)f||(a[c.expando]=f=++c.uuid);else h=a;if(typeof b==="object")if(e)h[f]=c.extend(h[f],b);else c.extend(h,b);else if(e&&!h[f])h[f]={};a=e?h[f]:h;if(d!==B)a[b]=d;return typeof b==="string"?a[b]:a}}},removeData:function(a,b){if(c.acceptData(a)){a=a==E?ra:a;var d=a.nodeType,e=d?a[c.expando]:a,f=c.cache,h=d?f[e]:e;if(b){if(h){delete h[b];d&&c.isEmptyObject(h)&&c.removeData(a)}}else if(d&&c.support.deleteExpando)delete a[c.expando];else if(a.removeAttribute)a.removeAttribute(c.expando);
else if(d)delete f[e];else for(var l in a)delete a[l]}},acceptData:function(a){if(a.nodeName){var b=c.noData[a.nodeName.toLowerCase()];if(b)return!(b===true||a.getAttribute("classid")!==b)}return true}});c.fn.extend({data:function(a,b){var d=null;if(typeof a==="undefined"){if(this.length){var e=this[0].attributes,f;d=c.data(this[0]);for(var h=0,l=e.length;h<l;h++){f=e[h].name;if(f.indexOf("data-")===0){f=f.substr(5);ka(this[0],f,d[f])}}}return d}else if(typeof a==="object")return this.each(function(){c.data(this,
a)});var k=a.split(".");k[1]=k[1]?"."+k[1]:"";if(b===B){d=this.triggerHandler("getData"+k[1]+"!",[k[0]]);if(d===B&&this.length){d=c.data(this[0],a);d=ka(this[0],a,d)}return d===B&&k[1]?this.data(k[0]):d}else return this.each(function(){var o=c(this),x=[k[0],b];o.triggerHandler("setData"+k[1]+"!",x);c.data(this,a,b);o.triggerHandler("changeData"+k[1]+"!",x)})},removeData:function(a){return this.each(function(){c.removeData(this,a)})}});c.extend({queue:function(a,b,d){if(a){b=(b||"fx")+"queue";var e=
c.data(a,b);if(!d)return e||[];if(!e||c.isArray(d))e=c.data(a,b,c.makeArray(d));else e.push(d);return e}},dequeue:function(a,b){b=b||"fx";var d=c.queue(a,b),e=d.shift();if(e==="inprogress")e=d.shift();if(e){b==="fx"&&d.unshift("inprogress");e.call(a,function(){c.dequeue(a,b)})}}});c.fn.extend({queue:function(a,b){if(typeof a!=="string"){b=a;a="fx"}if(b===B)return c.queue(this[0],a);return this.each(function(){var d=c.queue(this,a,b);a==="fx"&&d[0]!=="inprogress"&&c.dequeue(this,a)})},dequeue:function(a){return this.each(function(){c.dequeue(this,
a)})},delay:function(a,b){a=c.fx?c.fx.speeds[a]||a:a;b=b||"fx";return this.queue(b,function(){var d=this;setTimeout(function(){c.dequeue(d,b)},a)})},clearQueue:function(a){return this.queue(a||"fx",[])}});var sa=/[\n\t]/g,ha=/\s+/,Sa=/\r/g,Ta=/^(?:href|src|style)$/,Ua=/^(?:button|input)$/i,Va=/^(?:button|input|object|select|textarea)$/i,Wa=/^a(?:rea)?$/i,ta=/^(?:radio|checkbox)$/i;c.props={"for":"htmlFor","class":"className",readonly:"readOnly",maxlength:"maxLength",cellspacing:"cellSpacing",rowspan:"rowSpan",
colspan:"colSpan",tabindex:"tabIndex",usemap:"useMap",frameborder:"frameBorder"};c.fn.extend({attr:function(a,b){return c.access(this,a,b,true,c.attr)},removeAttr:function(a){return this.each(function(){c.attr(this,a,"");this.nodeType===1&&this.removeAttribute(a)})},addClass:function(a){if(c.isFunction(a))return this.each(function(x){var r=c(this);r.addClass(a.call(this,x,r.attr("class")))});if(a&&typeof a==="string")for(var b=(a||"").split(ha),d=0,e=this.length;d<e;d++){var f=this[d];if(f.nodeType===
1)if(f.className){for(var h=" "+f.className+" ",l=f.className,k=0,o=b.length;k<o;k++)if(h.indexOf(" "+b[k]+" ")<0)l+=" "+b[k];f.className=c.trim(l)}else f.className=a}return this},removeClass:function(a){if(c.isFunction(a))return this.each(function(o){var x=c(this);x.removeClass(a.call(this,o,x.attr("class")))});if(a&&typeof a==="string"||a===B)for(var b=(a||"").split(ha),d=0,e=this.length;d<e;d++){var f=this[d];if(f.nodeType===1&&f.className)if(a){for(var h=(" "+f.className+" ").replace(sa," "),
l=0,k=b.length;l<k;l++)h=h.replace(" "+b[l]+" "," ");f.className=c.trim(h)}else f.className=""}return this},toggleClass:function(a,b){var d=typeof a,e=typeof b==="boolean";if(c.isFunction(a))return this.each(function(f){var h=c(this);h.toggleClass(a.call(this,f,h.attr("class"),b),b)});return this.each(function(){if(d==="string")for(var f,h=0,l=c(this),k=b,o=a.split(ha);f=o[h++];){k=e?k:!l.hasClass(f);l[k?"addClass":"removeClass"](f)}else if(d==="undefined"||d==="boolean"){this.className&&c.data(this,
"__className__",this.className);this.className=this.className||a===false?"":c.data(this,"__className__")||""}})},hasClass:function(a){a=" "+a+" ";for(var b=0,d=this.length;b<d;b++)if((" "+this[b].className+" ").replace(sa," ").indexOf(a)>-1)return true;return false},val:function(a){if(!arguments.length){var b=this[0];if(b){if(c.nodeName(b,"option")){var d=b.attributes.value;return!d||d.specified?b.value:b.text}if(c.nodeName(b,"select")){var e=b.selectedIndex;d=[];var f=b.options;b=b.type==="select-one";
if(e<0)return null;var h=b?e:0;for(e=b?e+1:f.length;h<e;h++){var l=f[h];if(l.selected&&(c.support.optDisabled?!l.disabled:l.getAttribute("disabled")===null)&&(!l.parentNode.disabled||!c.nodeName(l.parentNode,"optgroup"))){a=c(l).val();if(b)return a;d.push(a)}}return d}if(ta.test(b.type)&&!c.support.checkOn)return b.getAttribute("value")===null?"on":b.value;return(b.value||"").replace(Sa,"")}return B}var k=c.isFunction(a);return this.each(function(o){var x=c(this),r=a;if(this.nodeType===1){if(k)r=
a.call(this,o,x.val());if(r==null)r="";else if(typeof r==="number")r+="";else if(c.isArray(r))r=c.map(r,function(C){return C==null?"":C+""});if(c.isArray(r)&&ta.test(this.type))this.checked=c.inArray(x.val(),r)>=0;else if(c.nodeName(this,"select")){var A=c.makeArray(r);c("option",this).each(function(){this.selected=c.inArray(c(this).val(),A)>=0});if(!A.length)this.selectedIndex=-1}else this.value=r}})}});c.extend({attrFn:{val:true,css:true,html:true,text:true,data:true,width:true,height:true,offset:true},
attr:function(a,b,d,e){if(!a||a.nodeType===3||a.nodeType===8)return B;if(e&&b in c.attrFn)return c(a)[b](d);e=a.nodeType!==1||!c.isXMLDoc(a);var f=d!==B;b=e&&c.props[b]||b;var h=Ta.test(b);if((b in a||a[b]!==B)&&e&&!h){if(f){b==="type"&&Ua.test(a.nodeName)&&a.parentNode&&c.error("type property can't be changed");if(d===null)a.nodeType===1&&a.removeAttribute(b);else a[b]=d}if(c.nodeName(a,"form")&&a.getAttributeNode(b))return a.getAttributeNode(b).nodeValue;if(b==="tabIndex")return(b=a.getAttributeNode("tabIndex"))&&
b.specified?b.value:Va.test(a.nodeName)||Wa.test(a.nodeName)&&a.href?0:B;return a[b]}if(!c.support.style&&e&&b==="style"){if(f)a.style.cssText=""+d;return a.style.cssText}f&&a.setAttribute(b,""+d);if(!a.attributes[b]&&a.hasAttribute&&!a.hasAttribute(b))return B;a=!c.support.hrefNormalized&&e&&h?a.getAttribute(b,2):a.getAttribute(b);return a===null?B:a}});var X=/\.(.*)$/,ia=/^(?:textarea|input|select)$/i,La=/\./g,Ma=/ /g,Xa=/[^\w\s.|`]/g,Ya=function(a){return a.replace(Xa,"\\$&")},ua={focusin:0,focusout:0};
c.event={add:function(a,b,d,e){if(!(a.nodeType===3||a.nodeType===8)){if(c.isWindow(a)&&a!==E&&!a.frameElement)a=E;if(d===false)d=U;else if(!d)return;var f,h;if(d.handler){f=d;d=f.handler}if(!d.guid)d.guid=c.guid++;if(h=c.data(a)){var l=a.nodeType?"events":"__events__",k=h[l],o=h.handle;if(typeof k==="function"){o=k.handle;k=k.events}else if(!k){a.nodeType||(h[l]=h=function(){});h.events=k={}}if(!o)h.handle=o=function(){return typeof c!=="undefined"&&!c.event.triggered?c.event.handle.apply(o.elem,
arguments):B};o.elem=a;b=b.split(" ");for(var x=0,r;l=b[x++];){h=f?c.extend({},f):{handler:d,data:e};if(l.indexOf(".")>-1){r=l.split(".");l=r.shift();h.namespace=r.slice(0).sort().join(".")}else{r=[];h.namespace=""}h.type=l;if(!h.guid)h.guid=d.guid;var A=k[l],C=c.event.special[l]||{};if(!A){A=k[l]=[];if(!C.setup||C.setup.call(a,e,r,o)===false)if(a.addEventListener)a.addEventListener(l,o,false);else a.attachEvent&&a.attachEvent("on"+l,o)}if(C.add){C.add.call(a,h);if(!h.handler.guid)h.handler.guid=
d.guid}A.push(h);c.event.global[l]=true}a=null}}},global:{},remove:function(a,b,d,e){if(!(a.nodeType===3||a.nodeType===8)){if(d===false)d=U;var f,h,l=0,k,o,x,r,A,C,J=a.nodeType?"events":"__events__",w=c.data(a),I=w&&w[J];if(w&&I){if(typeof I==="function"){w=I;I=I.events}if(b&&b.type){d=b.handler;b=b.type}if(!b||typeof b==="string"&&b.charAt(0)==="."){b=b||"";for(f in I)c.event.remove(a,f+b)}else{for(b=b.split(" ");f=b[l++];){r=f;k=f.indexOf(".")<0;o=[];if(!k){o=f.split(".");f=o.shift();x=RegExp("(^|\\.)"+
c.map(o.slice(0).sort(),Ya).join("\\.(?:.*\\.)?")+"(\\.|$)")}if(A=I[f])if(d){r=c.event.special[f]||{};for(h=e||0;h<A.length;h++){C=A[h];if(d.guid===C.guid){if(k||x.test(C.namespace)){e==null&&A.splice(h--,1);r.remove&&r.remove.call(a,C)}if(e!=null)break}}if(A.length===0||e!=null&&A.length===1){if(!r.teardown||r.teardown.call(a,o)===false)c.removeEvent(a,f,w.handle);delete I[f]}}else for(h=0;h<A.length;h++){C=A[h];if(k||x.test(C.namespace)){c.event.remove(a,r,C.handler,h);A.splice(h--,1)}}}if(c.isEmptyObject(I)){if(b=
w.handle)b.elem=null;delete w.events;delete w.handle;if(typeof w==="function")c.removeData(a,J);else c.isEmptyObject(w)&&c.removeData(a)}}}}},trigger:function(a,b,d,e){var f=a.type||a;if(!e){a=typeof a==="object"?a[c.expando]?a:c.extend(c.Event(f),a):c.Event(f);if(f.indexOf("!")>=0){a.type=f=f.slice(0,-1);a.exclusive=true}if(!d){a.stopPropagation();c.event.global[f]&&c.each(c.cache,function(){this.events&&this.events[f]&&c.event.trigger(a,b,this.handle.elem)})}if(!d||d.nodeType===3||d.nodeType===
8)return B;a.result=B;a.target=d;b=c.makeArray(b);b.unshift(a)}a.currentTarget=d;(e=d.nodeType?c.data(d,"handle"):(c.data(d,"__events__")||{}).handle)&&e.apply(d,b);e=d.parentNode||d.ownerDocument;try{if(!(d&&d.nodeName&&c.noData[d.nodeName.toLowerCase()]))if(d["on"+f]&&d["on"+f].apply(d,b)===false){a.result=false;a.preventDefault()}}catch(h){}if(!a.isPropagationStopped()&&e)c.event.trigger(a,b,e,true);else if(!a.isDefaultPrevented()){var l;e=a.target;var k=f.replace(X,""),o=c.nodeName(e,"a")&&k===
"click",x=c.event.special[k]||{};if((!x._default||x._default.call(d,a)===false)&&!o&&!(e&&e.nodeName&&c.noData[e.nodeName.toLowerCase()])){try{if(e[k]){if(l=e["on"+k])e["on"+k]=null;c.event.triggered=true;e[k]()}}catch(r){}if(l)e["on"+k]=l;c.event.triggered=false}}},handle:function(a){var b,d,e,f;d=[];var h=c.makeArray(arguments);a=h[0]=c.event.fix(a||E.event);a.currentTarget=this;b=a.type.indexOf(".")<0&&!a.exclusive;if(!b){e=a.type.split(".");a.type=e.shift();d=e.slice(0).sort();e=RegExp("(^|\\.)"+
d.join("\\.(?:.*\\.)?")+"(\\.|$)")}a.namespace=a.namespace||d.join(".");f=c.data(this,this.nodeType?"events":"__events__");if(typeof f==="function")f=f.events;d=(f||{})[a.type];if(f&&d){d=d.slice(0);f=0;for(var l=d.length;f<l;f++){var k=d[f];if(b||e.test(k.namespace)){a.handler=k.handler;a.data=k.data;a.handleObj=k;k=k.handler.apply(this,h);if(k!==B){a.result=k;if(k===false){a.preventDefault();a.stopPropagation()}}if(a.isImmediatePropagationStopped())break}}}return a.result},props:"altKey attrChange attrName bubbles button cancelable charCode clientX clientY ctrlKey currentTarget data detail eventPhase fromElement handler keyCode layerX layerY metaKey newValue offsetX offsetY pageX pageY prevValue relatedNode relatedTarget screenX screenY shiftKey srcElement target toElement view wheelDelta which".split(" "),
fix:function(a){if(a[c.expando])return a;var b=a;a=c.Event(b);for(var d=this.props.length,e;d;){e=this.props[--d];a[e]=b[e]}if(!a.target)a.target=a.srcElement||t;if(a.target.nodeType===3)a.target=a.target.parentNode;if(!a.relatedTarget&&a.fromElement)a.relatedTarget=a.fromElement===a.target?a.toElement:a.fromElement;if(a.pageX==null&&a.clientX!=null){b=t.documentElement;d=t.body;a.pageX=a.clientX+(b&&b.scrollLeft||d&&d.scrollLeft||0)-(b&&b.clientLeft||d&&d.clientLeft||0);a.pageY=a.clientY+(b&&b.scrollTop||
d&&d.scrollTop||0)-(b&&b.clientTop||d&&d.clientTop||0)}if(a.which==null&&(a.charCode!=null||a.keyCode!=null))a.which=a.charCode!=null?a.charCode:a.keyCode;if(!a.metaKey&&a.ctrlKey)a.metaKey=a.ctrlKey;if(!a.which&&a.button!==B)a.which=a.button&1?1:a.button&2?3:a.button&4?2:0;return a},guid:1E8,proxy:c.proxy,special:{ready:{setup:c.bindReady,teardown:c.noop},live:{add:function(a){c.event.add(this,Y(a.origType,a.selector),c.extend({},a,{handler:Ka,guid:a.handler.guid}))},remove:function(a){c.event.remove(this,
Y(a.origType,a.selector),a)}},beforeunload:{setup:function(a,b,d){if(c.isWindow(this))this.onbeforeunload=d},teardown:function(a,b){if(this.onbeforeunload===b)this.onbeforeunload=null}}}};c.removeEvent=t.removeEventListener?function(a,b,d){a.removeEventListener&&a.removeEventListener(b,d,false)}:function(a,b,d){a.detachEvent&&a.detachEvent("on"+b,d)};c.Event=function(a){if(!this.preventDefault)return new c.Event(a);if(a&&a.type){this.originalEvent=a;this.type=a.type}else this.type=a;this.timeStamp=
c.now();this[c.expando]=true};c.Event.prototype={preventDefault:function(){this.isDefaultPrevented=ca;var a=this.originalEvent;if(a)if(a.preventDefault)a.preventDefault();else a.returnValue=false},stopPropagation:function(){this.isPropagationStopped=ca;var a=this.originalEvent;if(a){a.stopPropagation&&a.stopPropagation();a.cancelBubble=true}},stopImmediatePropagation:function(){this.isImmediatePropagationStopped=ca;this.stopPropagation()},isDefaultPrevented:U,isPropagationStopped:U,isImmediatePropagationStopped:U};
var va=function(a){var b=a.relatedTarget;try{for(;b&&b!==this;)b=b.parentNode;if(b!==this){a.type=a.data;c.event.handle.apply(this,arguments)}}catch(d){}},wa=function(a){a.type=a.data;c.event.handle.apply(this,arguments)};c.each({mouseenter:"mouseover",mouseleave:"mouseout"},function(a,b){c.event.special[a]={setup:function(d){c.event.add(this,b,d&&d.selector?wa:va,a)},teardown:function(d){c.event.remove(this,b,d&&d.selector?wa:va)}}});if(!c.support.submitBubbles)c.event.special.submit={setup:function(){if(this.nodeName.toLowerCase()!==
"form"){c.event.add(this,"click.specialSubmit",function(a){var b=a.target,d=b.type;if((d==="submit"||d==="image")&&c(b).closest("form").length){a.liveFired=B;return la("submit",this,arguments)}});c.event.add(this,"keypress.specialSubmit",function(a){var b=a.target,d=b.type;if((d==="text"||d==="password")&&c(b).closest("form").length&&a.keyCode===13){a.liveFired=B;return la("submit",this,arguments)}})}else return false},teardown:function(){c.event.remove(this,".specialSubmit")}};if(!c.support.changeBubbles){var V,
xa=function(a){var b=a.type,d=a.value;if(b==="radio"||b==="checkbox")d=a.checked;else if(b==="select-multiple")d=a.selectedIndex>-1?c.map(a.options,function(e){return e.selected}).join("-"):"";else if(a.nodeName.toLowerCase()==="select")d=a.selectedIndex;return d},Z=function(a,b){var d=a.target,e,f;if(!(!ia.test(d.nodeName)||d.readOnly)){e=c.data(d,"_change_data");f=xa(d);if(a.type!=="focusout"||d.type!=="radio")c.data(d,"_change_data",f);if(!(e===B||f===e))if(e!=null||f){a.type="change";a.liveFired=
B;return c.event.trigger(a,b,d)}}};c.event.special.change={filters:{focusout:Z,beforedeactivate:Z,click:function(a){var b=a.target,d=b.type;if(d==="radio"||d==="checkbox"||b.nodeName.toLowerCase()==="select")return Z.call(this,a)},keydown:function(a){var b=a.target,d=b.type;if(a.keyCode===13&&b.nodeName.toLowerCase()!=="textarea"||a.keyCode===32&&(d==="checkbox"||d==="radio")||d==="select-multiple")return Z.call(this,a)},beforeactivate:function(a){a=a.target;c.data(a,"_change_data",xa(a))}},setup:function(){if(this.type===
"file")return false;for(var a in V)c.event.add(this,a+".specialChange",V[a]);return ia.test(this.nodeName)},teardown:function(){c.event.remove(this,".specialChange");return ia.test(this.nodeName)}};V=c.event.special.change.filters;V.focus=V.beforeactivate}t.addEventListener&&c.each({focus:"focusin",blur:"focusout"},function(a,b){function d(e){e=c.event.fix(e);e.type=b;return c.event.trigger(e,null,e.target)}c.event.special[b]={setup:function(){ua[b]++===0&&t.addEventListener(a,d,true)},teardown:function(){--ua[b]===
0&&t.removeEventListener(a,d,true)}}});c.each(["bind","one"],function(a,b){c.fn[b]=function(d,e,f){if(typeof d==="object"){for(var h in d)this[b](h,e,d[h],f);return this}if(c.isFunction(e)||e===false){f=e;e=B}var l=b==="one"?c.proxy(f,function(o){c(this).unbind(o,l);return f.apply(this,arguments)}):f;if(d==="unload"&&b!=="one")this.one(d,e,f);else{h=0;for(var k=this.length;h<k;h++)c.event.add(this[h],d,l,e)}return this}});c.fn.extend({unbind:function(a,b){if(typeof a==="object"&&!a.preventDefault)for(var d in a)this.unbind(d,
a[d]);else{d=0;for(var e=this.length;d<e;d++)c.event.remove(this[d],a,b)}return this},delegate:function(a,b,d,e){return this.live(b,d,e,a)},undelegate:function(a,b,d){return arguments.length===0?this.unbind("live"):this.die(b,null,d,a)},trigger:function(a,b){return this.each(function(){c.event.trigger(a,b,this)})},triggerHandler:function(a,b){if(this[0]){var d=c.Event(a);d.preventDefault();d.stopPropagation();c.event.trigger(d,b,this[0]);return d.result}},toggle:function(a){for(var b=arguments,d=
1;d<b.length;)c.proxy(a,b[d++]);return this.click(c.proxy(a,function(e){var f=(c.data(this,"lastToggle"+a.guid)||0)%d;c.data(this,"lastToggle"+a.guid,f+1);e.preventDefault();return b[f].apply(this,arguments)||false}))},hover:function(a,b){return this.mouseenter(a).mouseleave(b||a)}});var ya={focus:"focusin",blur:"focusout",mouseenter:"mouseover",mouseleave:"mouseout"};c.each(["live","die"],function(a,b){c.fn[b]=function(d,e,f,h){var l,k=0,o,x,r=h||this.selector;h=h?this:c(this.context);if(typeof d===
"object"&&!d.preventDefault){for(l in d)h[b](l,e,d[l],r);return this}if(c.isFunction(e)){f=e;e=B}for(d=(d||"").split(" ");(l=d[k++])!=null;){o=X.exec(l);x="";if(o){x=o[0];l=l.replace(X,"")}if(l==="hover")d.push("mouseenter"+x,"mouseleave"+x);else{o=l;if(l==="focus"||l==="blur"){d.push(ya[l]+x);l+=x}else l=(ya[l]||l)+x;if(b==="live"){x=0;for(var A=h.length;x<A;x++)c.event.add(h[x],"live."+Y(l,r),{data:e,selector:r,handler:f,origType:l,origHandler:f,preType:o})}else h.unbind("live."+Y(l,r),f)}}return this}});
c.each("blur focus focusin focusout load resize scroll unload click dblclick mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave change select submit keydown keypress keyup error".split(" "),function(a,b){c.fn[b]=function(d,e){if(e==null){e=d;d=null}return arguments.length>0?this.bind(b,d,e):this.trigger(b)};if(c.attrFn)c.attrFn[b]=true});E.attachEvent&&!E.addEventListener&&c(E).bind("unload",function(){for(var a in c.cache)if(c.cache[a].handle)try{c.event.remove(c.cache[a].handle.elem)}catch(b){}});
(function(){function a(g,i,n,m,p,q){p=0;for(var u=m.length;p<u;p++){var y=m[p];if(y){var F=false;for(y=y[g];y;){if(y.sizcache===n){F=m[y.sizset];break}if(y.nodeType===1&&!q){y.sizcache=n;y.sizset=p}if(y.nodeName.toLowerCase()===i){F=y;break}y=y[g]}m[p]=F}}}function b(g,i,n,m,p,q){p=0;for(var u=m.length;p<u;p++){var y=m[p];if(y){var F=false;for(y=y[g];y;){if(y.sizcache===n){F=m[y.sizset];break}if(y.nodeType===1){if(!q){y.sizcache=n;y.sizset=p}if(typeof i!=="string"){if(y===i){F=true;break}}else if(k.filter(i,
[y]).length>0){F=y;break}}y=y[g]}m[p]=F}}}var d=/((?:\((?:\([^()]+\)|[^()]+)+\)|\[(?:\[[^\[\]]*\]|['"][^'"]*['"]|[^\[\]'"]+)+\]|\\.|[^ >+~,(\[\\]+)+|[>+~])(\s*,\s*)?((?:.|\r|\n)*)/g,e=0,f=Object.prototype.toString,h=false,l=true;[0,0].sort(function(){l=false;return 0});var k=function(g,i,n,m){n=n||[];var p=i=i||t;if(i.nodeType!==1&&i.nodeType!==9)return[];if(!g||typeof g!=="string")return n;var q,u,y,F,M,N=true,O=k.isXML(i),D=[],R=g;do{d.exec("");if(q=d.exec(R)){R=q[3];D.push(q[1]);if(q[2]){F=q[3];
break}}}while(q);if(D.length>1&&x.exec(g))if(D.length===2&&o.relative[D[0]])u=L(D[0]+D[1],i);else for(u=o.relative[D[0]]?[i]:k(D.shift(),i);D.length;){g=D.shift();if(o.relative[g])g+=D.shift();u=L(g,u)}else{if(!m&&D.length>1&&i.nodeType===9&&!O&&o.match.ID.test(D[0])&&!o.match.ID.test(D[D.length-1])){q=k.find(D.shift(),i,O);i=q.expr?k.filter(q.expr,q.set)[0]:q.set[0]}if(i){q=m?{expr:D.pop(),set:C(m)}:k.find(D.pop(),D.length===1&&(D[0]==="~"||D[0]==="+")&&i.parentNode?i.parentNode:i,O);u=q.expr?k.filter(q.expr,
q.set):q.set;if(D.length>0)y=C(u);else N=false;for(;D.length;){q=M=D.pop();if(o.relative[M])q=D.pop();else M="";if(q==null)q=i;o.relative[M](y,q,O)}}else y=[]}y||(y=u);y||k.error(M||g);if(f.call(y)==="[object Array]")if(N)if(i&&i.nodeType===1)for(g=0;y[g]!=null;g++){if(y[g]&&(y[g]===true||y[g].nodeType===1&&k.contains(i,y[g])))n.push(u[g])}else for(g=0;y[g]!=null;g++)y[g]&&y[g].nodeType===1&&n.push(u[g]);else n.push.apply(n,y);else C(y,n);if(F){k(F,p,n,m);k.uniqueSort(n)}return n};k.uniqueSort=function(g){if(w){h=
l;g.sort(w);if(h)for(var i=1;i<g.length;i++)g[i]===g[i-1]&&g.splice(i--,1)}return g};k.matches=function(g,i){return k(g,null,null,i)};k.matchesSelector=function(g,i){return k(i,null,null,[g]).length>0};k.find=function(g,i,n){var m;if(!g)return[];for(var p=0,q=o.order.length;p<q;p++){var u,y=o.order[p];if(u=o.leftMatch[y].exec(g)){var F=u[1];u.splice(1,1);if(F.substr(F.length-1)!=="\\"){u[1]=(u[1]||"").replace(/\\/g,"");m=o.find[y](u,i,n);if(m!=null){g=g.replace(o.match[y],"");break}}}}m||(m=i.getElementsByTagName("*"));
return{set:m,expr:g}};k.filter=function(g,i,n,m){for(var p,q,u=g,y=[],F=i,M=i&&i[0]&&k.isXML(i[0]);g&&i.length;){for(var N in o.filter)if((p=o.leftMatch[N].exec(g))!=null&&p[2]){var O,D,R=o.filter[N];D=p[1];q=false;p.splice(1,1);if(D.substr(D.length-1)!=="\\"){if(F===y)y=[];if(o.preFilter[N])if(p=o.preFilter[N](p,F,n,y,m,M)){if(p===true)continue}else q=O=true;if(p)for(var j=0;(D=F[j])!=null;j++)if(D){O=R(D,p,j,F);var s=m^!!O;if(n&&O!=null)if(s)q=true;else F[j]=false;else if(s){y.push(D);q=true}}if(O!==
B){n||(F=y);g=g.replace(o.match[N],"");if(!q)return[];break}}}if(g===u)if(q==null)k.error(g);else break;u=g}return F};k.error=function(g){throw"Syntax error, unrecognized expression: "+g;};var o=k.selectors={order:["ID","NAME","TAG"],match:{ID:/#((?:[\w\u00c0-\uFFFF\-]|\\.)+)/,CLASS:/\.((?:[\w\u00c0-\uFFFF\-]|\\.)+)/,NAME:/\[name=['"]*((?:[\w\u00c0-\uFFFF\-]|\\.)+)['"]*\]/,ATTR:/\[\s*((?:[\w\u00c0-\uFFFF\-]|\\.)+)\s*(?:(\S?=)\s*(['"]*)(.*?)\3|)\s*\]/,TAG:/^((?:[\w\u00c0-\uFFFF\*\-]|\\.)+)/,CHILD:/:(only|nth|last|first)-child(?:\((even|odd|[\dn+\-]*)\))?/,
POS:/:(nth|eq|gt|lt|first|last|even|odd)(?:\((\d*)\))?(?=[^\-]|$)/,PSEUDO:/:((?:[\w\u00c0-\uFFFF\-]|\\.)+)(?:\((['"]?)((?:\([^\)]+\)|[^\(\)]*)+)\2\))?/},leftMatch:{},attrMap:{"class":"className","for":"htmlFor"},attrHandle:{href:function(g){return g.getAttribute("href")}},relative:{"+":function(g,i){var n=typeof i==="string",m=n&&!/\W/.test(i);n=n&&!m;if(m)i=i.toLowerCase();m=0;for(var p=g.length,q;m<p;m++)if(q=g[m]){for(;(q=q.previousSibling)&&q.nodeType!==1;);g[m]=n||q&&q.nodeName.toLowerCase()===
i?q||false:q===i}n&&k.filter(i,g,true)},">":function(g,i){var n,m=typeof i==="string",p=0,q=g.length;if(m&&!/\W/.test(i))for(i=i.toLowerCase();p<q;p++){if(n=g[p]){n=n.parentNode;g[p]=n.nodeName.toLowerCase()===i?n:false}}else{for(;p<q;p++)if(n=g[p])g[p]=m?n.parentNode:n.parentNode===i;m&&k.filter(i,g,true)}},"":function(g,i,n){var m,p=e++,q=b;if(typeof i==="string"&&!/\W/.test(i)){m=i=i.toLowerCase();q=a}q("parentNode",i,p,g,m,n)},"~":function(g,i,n){var m,p=e++,q=b;if(typeof i==="string"&&!/\W/.test(i)){m=
i=i.toLowerCase();q=a}q("previousSibling",i,p,g,m,n)}},find:{ID:function(g,i,n){if(typeof i.getElementById!=="undefined"&&!n)return(g=i.getElementById(g[1]))&&g.parentNode?[g]:[]},NAME:function(g,i){if(typeof i.getElementsByName!=="undefined"){for(var n=[],m=i.getElementsByName(g[1]),p=0,q=m.length;p<q;p++)m[p].getAttribute("name")===g[1]&&n.push(m[p]);return n.length===0?null:n}},TAG:function(g,i){return i.getElementsByTagName(g[1])}},preFilter:{CLASS:function(g,i,n,m,p,q){g=" "+g[1].replace(/\\/g,
"")+" ";if(q)return g;q=0;for(var u;(u=i[q])!=null;q++)if(u)if(p^(u.className&&(" "+u.className+" ").replace(/[\t\n]/g," ").indexOf(g)>=0))n||m.push(u);else if(n)i[q]=false;return false},ID:function(g){return g[1].replace(/\\/g,"")},TAG:function(g){return g[1].toLowerCase()},CHILD:function(g){if(g[1]==="nth"){var i=/(-?)(\d*)n((?:\+|-)?\d*)/.exec(g[2]==="even"&&"2n"||g[2]==="odd"&&"2n+1"||!/\D/.test(g[2])&&"0n+"+g[2]||g[2]);g[2]=i[1]+(i[2]||1)-0;g[3]=i[3]-0}g[0]=e++;return g},ATTR:function(g,i,n,
m,p,q){i=g[1].replace(/\\/g,"");if(!q&&o.attrMap[i])g[1]=o.attrMap[i];if(g[2]==="~=")g[4]=" "+g[4]+" ";return g},PSEUDO:function(g,i,n,m,p){if(g[1]==="not")if((d.exec(g[3])||"").length>1||/^\w/.test(g[3]))g[3]=k(g[3],null,null,i);else{g=k.filter(g[3],i,n,true^p);n||m.push.apply(m,g);return false}else if(o.match.POS.test(g[0])||o.match.CHILD.test(g[0]))return true;return g},POS:function(g){g.unshift(true);return g}},filters:{enabled:function(g){return g.disabled===false&&g.type!=="hidden"},disabled:function(g){return g.disabled===
true},checked:function(g){return g.checked===true},selected:function(g){return g.selected===true},parent:function(g){return!!g.firstChild},empty:function(g){return!g.firstChild},has:function(g,i,n){return!!k(n[3],g).length},header:function(g){return/h\d/i.test(g.nodeName)},text:function(g){return"text"===g.type},radio:function(g){return"radio"===g.type},checkbox:function(g){return"checkbox"===g.type},file:function(g){return"file"===g.type},password:function(g){return"password"===g.type},submit:function(g){return"submit"===
g.type},image:function(g){return"image"===g.type},reset:function(g){return"reset"===g.type},button:function(g){return"button"===g.type||g.nodeName.toLowerCase()==="button"},input:function(g){return/input|select|textarea|button/i.test(g.nodeName)}},setFilters:{first:function(g,i){return i===0},last:function(g,i,n,m){return i===m.length-1},even:function(g,i){return i%2===0},odd:function(g,i){return i%2===1},lt:function(g,i,n){return i<n[3]-0},gt:function(g,i,n){return i>n[3]-0},nth:function(g,i,n){return n[3]-
0===i},eq:function(g,i,n){return n[3]-0===i}},filter:{PSEUDO:function(g,i,n,m){var p=i[1],q=o.filters[p];if(q)return q(g,n,i,m);else if(p==="contains")return(g.textContent||g.innerText||k.getText([g])||"").indexOf(i[3])>=0;else if(p==="not"){i=i[3];n=0;for(m=i.length;n<m;n++)if(i[n]===g)return false;return true}else k.error("Syntax error, unrecognized expression: "+p)},CHILD:function(g,i){var n=i[1],m=g;switch(n){case "only":case "first":for(;m=m.previousSibling;)if(m.nodeType===1)return false;if(n===
"first")return true;m=g;case "last":for(;m=m.nextSibling;)if(m.nodeType===1)return false;return true;case "nth":n=i[2];var p=i[3];if(n===1&&p===0)return true;var q=i[0],u=g.parentNode;if(u&&(u.sizcache!==q||!g.nodeIndex)){var y=0;for(m=u.firstChild;m;m=m.nextSibling)if(m.nodeType===1)m.nodeIndex=++y;u.sizcache=q}m=g.nodeIndex-p;return n===0?m===0:m%n===0&&m/n>=0}},ID:function(g,i){return g.nodeType===1&&g.getAttribute("id")===i},TAG:function(g,i){return i==="*"&&g.nodeType===1||g.nodeName.toLowerCase()===
i},CLASS:function(g,i){return(" "+(g.className||g.getAttribute("class"))+" ").indexOf(i)>-1},ATTR:function(g,i){var n=i[1];n=o.attrHandle[n]?o.attrHandle[n](g):g[n]!=null?g[n]:g.getAttribute(n);var m=n+"",p=i[2],q=i[4];return n==null?p==="!=":p==="="?m===q:p==="*="?m.indexOf(q)>=0:p==="~="?(" "+m+" ").indexOf(q)>=0:!q?m&&n!==false:p==="!="?m!==q:p==="^="?m.indexOf(q)===0:p==="$="?m.substr(m.length-q.length)===q:p==="|="?m===q||m.substr(0,q.length+1)===q+"-":false},POS:function(g,i,n,m){var p=o.setFilters[i[2]];
if(p)return p(g,n,i,m)}}},x=o.match.POS,r=function(g,i){return"\\"+(i-0+1)},A;for(A in o.match){o.match[A]=RegExp(o.match[A].source+/(?![^\[]*\])(?![^\(]*\))/.source);o.leftMatch[A]=RegExp(/(^(?:.|\r|\n)*?)/.source+o.match[A].source.replace(/\\(\d+)/g,r))}var C=function(g,i){g=Array.prototype.slice.call(g,0);if(i){i.push.apply(i,g);return i}return g};try{Array.prototype.slice.call(t.documentElement.childNodes,0)}catch(J){C=function(g,i){var n=0,m=i||[];if(f.call(g)==="[object Array]")Array.prototype.push.apply(m,
g);else if(typeof g.length==="number")for(var p=g.length;n<p;n++)m.push(g[n]);else for(;g[n];n++)m.push(g[n]);return m}}var w,I;if(t.documentElement.compareDocumentPosition)w=function(g,i){if(g===i){h=true;return 0}if(!g.compareDocumentPosition||!i.compareDocumentPosition)return g.compareDocumentPosition?-1:1;return g.compareDocumentPosition(i)&4?-1:1};else{w=function(g,i){var n,m,p=[],q=[];n=g.parentNode;m=i.parentNode;var u=n;if(g===i){h=true;return 0}else if(n===m)return I(g,i);else if(n){if(!m)return 1}else return-1;
for(;u;){p.unshift(u);u=u.parentNode}for(u=m;u;){q.unshift(u);u=u.parentNode}n=p.length;m=q.length;for(u=0;u<n&&u<m;u++)if(p[u]!==q[u])return I(p[u],q[u]);return u===n?I(g,q[u],-1):I(p[u],i,1)};I=function(g,i,n){if(g===i)return n;for(g=g.nextSibling;g;){if(g===i)return-1;g=g.nextSibling}return 1}}k.getText=function(g){for(var i="",n,m=0;g[m];m++){n=g[m];if(n.nodeType===3||n.nodeType===4)i+=n.nodeValue;else if(n.nodeType!==8)i+=k.getText(n.childNodes)}return i};(function(){var g=t.createElement("div"),
i="script"+(new Date).getTime(),n=t.documentElement;g.innerHTML="<a name='"+i+"'/>";n.insertBefore(g,n.firstChild);if(t.getElementById(i)){o.find.ID=function(m,p,q){if(typeof p.getElementById!=="undefined"&&!q)return(p=p.getElementById(m[1]))?p.id===m[1]||typeof p.getAttributeNode!=="undefined"&&p.getAttributeNode("id").nodeValue===m[1]?[p]:B:[]};o.filter.ID=function(m,p){var q=typeof m.getAttributeNode!=="undefined"&&m.getAttributeNode("id");return m.nodeType===1&&q&&q.nodeValue===p}}n.removeChild(g);
n=g=null})();(function(){var g=t.createElement("div");g.appendChild(t.createComment(""));if(g.getElementsByTagName("*").length>0)o.find.TAG=function(i,n){var m=n.getElementsByTagName(i[1]);if(i[1]==="*"){for(var p=[],q=0;m[q];q++)m[q].nodeType===1&&p.push(m[q]);m=p}return m};g.innerHTML="<a href='#'></a>";if(g.firstChild&&typeof g.firstChild.getAttribute!=="undefined"&&g.firstChild.getAttribute("href")!=="#")o.attrHandle.href=function(i){return i.getAttribute("href",2)};g=null})();t.querySelectorAll&&
function(){var g=k,i=t.createElement("div");i.innerHTML="<p class='TEST'></p>";if(!(i.querySelectorAll&&i.querySelectorAll(".TEST").length===0)){k=function(m,p,q,u){p=p||t;m=m.replace(/\=\s*([^'"\]]*)\s*\]/g,"='$1']");if(!u&&!k.isXML(p))if(p.nodeType===9)try{return C(p.querySelectorAll(m),q)}catch(y){}else if(p.nodeType===1&&p.nodeName.toLowerCase()!=="object"){var F=p.getAttribute("id"),M=F||"__sizzle__";F||p.setAttribute("id",M);try{return C(p.querySelectorAll("#"+M+" "+m),q)}catch(N){}finally{F||
p.removeAttribute("id")}}return g(m,p,q,u)};for(var n in g)k[n]=g[n];i=null}}();(function(){var g=t.documentElement,i=g.matchesSelector||g.mozMatchesSelector||g.webkitMatchesSelector||g.msMatchesSelector,n=false;try{i.call(t.documentElement,"[test!='']:sizzle")}catch(m){n=true}if(i)k.matchesSelector=function(p,q){q=q.replace(/\=\s*([^'"\]]*)\s*\]/g,"='$1']");if(!k.isXML(p))try{if(n||!o.match.PSEUDO.test(q)&&!/!=/.test(q))return i.call(p,q)}catch(u){}return k(q,null,null,[p]).length>0}})();(function(){var g=
t.createElement("div");g.innerHTML="<div class='test e'></div><div class='test'></div>";if(!(!g.getElementsByClassName||g.getElementsByClassName("e").length===0)){g.lastChild.className="e";if(g.getElementsByClassName("e").length!==1){o.order.splice(1,0,"CLASS");o.find.CLASS=function(i,n,m){if(typeof n.getElementsByClassName!=="undefined"&&!m)return n.getElementsByClassName(i[1])};g=null}}})();k.contains=t.documentElement.contains?function(g,i){return g!==i&&(g.contains?g.contains(i):true)}:t.documentElement.compareDocumentPosition?
function(g,i){return!!(g.compareDocumentPosition(i)&16)}:function(){return false};k.isXML=function(g){return(g=(g?g.ownerDocument||g:0).documentElement)?g.nodeName!=="HTML":false};var L=function(g,i){for(var n,m=[],p="",q=i.nodeType?[i]:i;n=o.match.PSEUDO.exec(g);){p+=n[0];g=g.replace(o.match.PSEUDO,"")}g=o.relative[g]?g+"*":g;n=0;for(var u=q.length;n<u;n++)k(g,q[n],m);return k.filter(p,m)};c.find=k;c.expr=k.selectors;c.expr[":"]=c.expr.filters;c.unique=k.uniqueSort;c.text=k.getText;c.isXMLDoc=k.isXML;
c.contains=k.contains})();var Za=/Until$/,$a=/^(?:parents|prevUntil|prevAll)/,ab=/,/,Na=/^.[^:#\[\.,]*$/,bb=Array.prototype.slice,cb=c.expr.match.POS;c.fn.extend({find:function(a){for(var b=this.pushStack("","find",a),d=0,e=0,f=this.length;e<f;e++){d=b.length;c.find(a,this[e],b);if(e>0)for(var h=d;h<b.length;h++)for(var l=0;l<d;l++)if(b[l]===b[h]){b.splice(h--,1);break}}return b},has:function(a){var b=c(a);return this.filter(function(){for(var d=0,e=b.length;d<e;d++)if(c.contains(this,b[d]))return true})},
not:function(a){return this.pushStack(ma(this,a,false),"not",a)},filter:function(a){return this.pushStack(ma(this,a,true),"filter",a)},is:function(a){return!!a&&c.filter(a,this).length>0},closest:function(a,b){var d=[],e,f,h=this[0];if(c.isArray(a)){var l,k={},o=1;if(h&&a.length){e=0;for(f=a.length;e<f;e++){l=a[e];k[l]||(k[l]=c.expr.match.POS.test(l)?c(l,b||this.context):l)}for(;h&&h.ownerDocument&&h!==b;){for(l in k){e=k[l];if(e.jquery?e.index(h)>-1:c(h).is(e))d.push({selector:l,elem:h,level:o})}h=
h.parentNode;o++}}return d}l=cb.test(a)?c(a,b||this.context):null;e=0;for(f=this.length;e<f;e++)for(h=this[e];h;)if(l?l.index(h)>-1:c.find.matchesSelector(h,a)){d.push(h);break}else{h=h.parentNode;if(!h||!h.ownerDocument||h===b)break}d=d.length>1?c.unique(d):d;return this.pushStack(d,"closest",a)},index:function(a){if(!a||typeof a==="string")return c.inArray(this[0],a?c(a):this.parent().children());return c.inArray(a.jquery?a[0]:a,this)},add:function(a,b){var d=typeof a==="string"?c(a,b||this.context):
c.makeArray(a),e=c.merge(this.get(),d);return this.pushStack(!d[0]||!d[0].parentNode||d[0].parentNode.nodeType===11||!e[0]||!e[0].parentNode||e[0].parentNode.nodeType===11?e:c.unique(e))},andSelf:function(){return this.add(this.prevObject)}});c.each({parent:function(a){return(a=a.parentNode)&&a.nodeType!==11?a:null},parents:function(a){return c.dir(a,"parentNode")},parentsUntil:function(a,b,d){return c.dir(a,"parentNode",d)},next:function(a){return c.nth(a,2,"nextSibling")},prev:function(a){return c.nth(a,
2,"previousSibling")},nextAll:function(a){return c.dir(a,"nextSibling")},prevAll:function(a){return c.dir(a,"previousSibling")},nextUntil:function(a,b,d){return c.dir(a,"nextSibling",d)},prevUntil:function(a,b,d){return c.dir(a,"previousSibling",d)},siblings:function(a){return c.sibling(a.parentNode.firstChild,a)},children:function(a){return c.sibling(a.firstChild)},contents:function(a){return c.nodeName(a,"iframe")?a.contentDocument||a.contentWindow.document:c.makeArray(a.childNodes)}},function(a,
b){c.fn[a]=function(d,e){var f=c.map(this,b,d);Za.test(a)||(e=d);if(e&&typeof e==="string")f=c.filter(e,f);f=this.length>1?c.unique(f):f;if((this.length>1||ab.test(e))&&$a.test(a))f=f.reverse();return this.pushStack(f,a,bb.call(arguments).join(","))}});c.extend({filter:function(a,b,d){if(d)a=":not("+a+")";return b.length===1?c.find.matchesSelector(b[0],a)?[b[0]]:[]:c.find.matches(a,b)},dir:function(a,b,d){var e=[];for(a=a[b];a&&a.nodeType!==9&&(d===B||a.nodeType!==1||!c(a).is(d));){a.nodeType===1&&
e.push(a);a=a[b]}return e},nth:function(a,b,d){b=b||1;for(var e=0;a;a=a[d])if(a.nodeType===1&&++e===b)break;return a},sibling:function(a,b){for(var d=[];a;a=a.nextSibling)a.nodeType===1&&a!==b&&d.push(a);return d}});var za=/ jQuery\d+="(?:\d+|null)"/g,$=/^\s+/,Aa=/<(?!area|br|col|embed|hr|img|input|link|meta|param)(([\w:]+)[^>]*)\/>/ig,Ba=/<([\w:]+)/,db=/<tbody/i,eb=/<|&#?\w+;/,Ca=/<(?:script|object|embed|option|style)/i,Da=/checked\s*(?:[^=]|=\s*.checked.)/i,fb=/\=([^="'>\s]+\/)>/g,P={option:[1,
"<select multiple='multiple'>","</select>"],legend:[1,"<fieldset>","</fieldset>"],thead:[1,"<table>","</table>"],tr:[2,"<table><tbody>","</tbody></table>"],td:[3,"<table><tbody><tr>","</tr></tbody></table>"],col:[2,"<table><tbody></tbody><colgroup>","</colgroup></table>"],area:[1,"<map>","</map>"],_default:[0,"",""]};P.optgroup=P.option;P.tbody=P.tfoot=P.colgroup=P.caption=P.thead;P.th=P.td;if(!c.support.htmlSerialize)P._default=[1,"div<div>","</div>"];c.fn.extend({text:function(a){if(c.isFunction(a))return this.each(function(b){var d=
c(this);d.text(a.call(this,b,d.text()))});if(typeof a!=="object"&&a!==B)return this.empty().append((this[0]&&this[0].ownerDocument||t).createTextNode(a));return c.text(this)},wrapAll:function(a){if(c.isFunction(a))return this.each(function(d){c(this).wrapAll(a.call(this,d))});if(this[0]){var b=c(a,this[0].ownerDocument).eq(0).clone(true);this[0].parentNode&&b.insertBefore(this[0]);b.map(function(){for(var d=this;d.firstChild&&d.firstChild.nodeType===1;)d=d.firstChild;return d}).append(this)}return this},
wrapInner:function(a){if(c.isFunction(a))return this.each(function(b){c(this).wrapInner(a.call(this,b))});return this.each(function(){var b=c(this),d=b.contents();d.length?d.wrapAll(a):b.append(a)})},wrap:function(a){return this.each(function(){c(this).wrapAll(a)})},unwrap:function(){return this.parent().each(function(){c.nodeName(this,"body")||c(this).replaceWith(this.childNodes)}).end()},append:function(){return this.domManip(arguments,true,function(a){this.nodeType===1&&this.appendChild(a)})},
prepend:function(){return this.domManip(arguments,true,function(a){this.nodeType===1&&this.insertBefore(a,this.firstChild)})},before:function(){if(this[0]&&this[0].parentNode)return this.domManip(arguments,false,function(b){this.parentNode.insertBefore(b,this)});else if(arguments.length){var a=c(arguments[0]);a.push.apply(a,this.toArray());return this.pushStack(a,"before",arguments)}},after:function(){if(this[0]&&this[0].parentNode)return this.domManip(arguments,false,function(b){this.parentNode.insertBefore(b,
this.nextSibling)});else if(arguments.length){var a=this.pushStack(this,"after",arguments);a.push.apply(a,c(arguments[0]).toArray());return a}},remove:function(a,b){for(var d=0,e;(e=this[d])!=null;d++)if(!a||c.filter(a,[e]).length){if(!b&&e.nodeType===1){c.cleanData(e.getElementsByTagName("*"));c.cleanData([e])}e.parentNode&&e.parentNode.removeChild(e)}return this},empty:function(){for(var a=0,b;(b=this[a])!=null;a++)for(b.nodeType===1&&c.cleanData(b.getElementsByTagName("*"));b.firstChild;)b.removeChild(b.firstChild);
return this},clone:function(a){var b=this.map(function(){if(!c.support.noCloneEvent&&!c.isXMLDoc(this)){var d=this.outerHTML,e=this.ownerDocument;if(!d){d=e.createElement("div");d.appendChild(this.cloneNode(true));d=d.innerHTML}return c.clean([d.replace(za,"").replace(fb,'="$1">').replace($,"")],e)[0]}else return this.cloneNode(true)});if(a===true){na(this,b);na(this.find("*"),b.find("*"))}return b},html:function(a){if(a===B)return this[0]&&this[0].nodeType===1?this[0].innerHTML.replace(za,""):null;
else if(typeof a==="string"&&!Ca.test(a)&&(c.support.leadingWhitespace||!$.test(a))&&!P[(Ba.exec(a)||["",""])[1].toLowerCase()]){a=a.replace(Aa,"<$1></$2>");try{for(var b=0,d=this.length;b<d;b++)if(this[b].nodeType===1){c.cleanData(this[b].getElementsByTagName("*"));this[b].innerHTML=a}}catch(e){this.empty().append(a)}}else c.isFunction(a)?this.each(function(f){var h=c(this);h.html(a.call(this,f,h.html()))}):this.empty().append(a);return this},replaceWith:function(a){if(this[0]&&this[0].parentNode){if(c.isFunction(a))return this.each(function(b){var d=
c(this),e=d.html();d.replaceWith(a.call(this,b,e))});if(typeof a!=="string")a=c(a).detach();return this.each(function(){var b=this.nextSibling,d=this.parentNode;c(this).remove();b?c(b).before(a):c(d).append(a)})}else return this.pushStack(c(c.isFunction(a)?a():a),"replaceWith",a)},detach:function(a){return this.remove(a,true)},domManip:function(a,b,d){var e,f,h,l=a[0],k=[];if(!c.support.checkClone&&arguments.length===3&&typeof l==="string"&&Da.test(l))return this.each(function(){c(this).domManip(a,
b,d,true)});if(c.isFunction(l))return this.each(function(x){var r=c(this);a[0]=l.call(this,x,b?r.html():B);r.domManip(a,b,d)});if(this[0]){e=l&&l.parentNode;e=c.support.parentNode&&e&&e.nodeType===11&&e.childNodes.length===this.length?{fragment:e}:c.buildFragment(a,this,k);h=e.fragment;if(f=h.childNodes.length===1?h=h.firstChild:h.firstChild){b=b&&c.nodeName(f,"tr");f=0;for(var o=this.length;f<o;f++)d.call(b?c.nodeName(this[f],"table")?this[f].getElementsByTagName("tbody")[0]||this[f].appendChild(this[f].ownerDocument.createElement("tbody")):
this[f]:this[f],f>0||e.cacheable||this.length>1?h.cloneNode(true):h)}k.length&&c.each(k,Oa)}return this}});c.buildFragment=function(a,b,d){var e,f,h;b=b&&b[0]?b[0].ownerDocument||b[0]:t;if(a.length===1&&typeof a[0]==="string"&&a[0].length<512&&b===t&&!Ca.test(a[0])&&(c.support.checkClone||!Da.test(a[0]))){f=true;if(h=c.fragments[a[0]])if(h!==1)e=h}if(!e){e=b.createDocumentFragment();c.clean(a,b,e,d)}if(f)c.fragments[a[0]]=h?e:1;return{fragment:e,cacheable:f}};c.fragments={};c.each({appendTo:"append",
prependTo:"prepend",insertBefore:"before",insertAfter:"after",replaceAll:"replaceWith"},function(a,b){c.fn[a]=function(d){var e=[];d=c(d);var f=this.length===1&&this[0].parentNode;if(f&&f.nodeType===11&&f.childNodes.length===1&&d.length===1){d[b](this[0]);return this}else{f=0;for(var h=d.length;f<h;f++){var l=(f>0?this.clone(true):this).get();c(d[f])[b](l);e=e.concat(l)}return this.pushStack(e,a,d.selector)}}});c.extend({clean:function(a,b,d,e){b=b||t;if(typeof b.createElement==="undefined")b=b.ownerDocument||
b[0]&&b[0].ownerDocument||t;for(var f=[],h=0,l;(l=a[h])!=null;h++){if(typeof l==="number")l+="";if(l){if(typeof l==="string"&&!eb.test(l))l=b.createTextNode(l);else if(typeof l==="string"){l=l.replace(Aa,"<$1></$2>");var k=(Ba.exec(l)||["",""])[1].toLowerCase(),o=P[k]||P._default,x=o[0],r=b.createElement("div");for(r.innerHTML=o[1]+l+o[2];x--;)r=r.lastChild;if(!c.support.tbody){x=db.test(l);k=k==="table"&&!x?r.firstChild&&r.firstChild.childNodes:o[1]==="<table>"&&!x?r.childNodes:[];for(o=k.length-
1;o>=0;--o)c.nodeName(k[o],"tbody")&&!k[o].childNodes.length&&k[o].parentNode.removeChild(k[o])}!c.support.leadingWhitespace&&$.test(l)&&r.insertBefore(b.createTextNode($.exec(l)[0]),r.firstChild);l=r.childNodes}if(l.nodeType)f.push(l);else f=c.merge(f,l)}}if(d)for(h=0;f[h];h++)if(e&&c.nodeName(f[h],"script")&&(!f[h].type||f[h].type.toLowerCase()==="text/javascript"))e.push(f[h].parentNode?f[h].parentNode.removeChild(f[h]):f[h]);else{f[h].nodeType===1&&f.splice.apply(f,[h+1,0].concat(c.makeArray(f[h].getElementsByTagName("script"))));
d.appendChild(f[h])}return f},cleanData:function(a){for(var b,d,e=c.cache,f=c.event.special,h=c.support.deleteExpando,l=0,k;(k=a[l])!=null;l++)if(!(k.nodeName&&c.noData[k.nodeName.toLowerCase()]))if(d=k[c.expando]){if((b=e[d])&&b.events)for(var o in b.events)f[o]?c.event.remove(k,o):c.removeEvent(k,o,b.handle);if(h)delete k[c.expando];else k.removeAttribute&&k.removeAttribute(c.expando);delete e[d]}}});var Ea=/alpha\([^)]*\)/i,gb=/opacity=([^)]*)/,hb=/-([a-z])/ig,ib=/([A-Z])/g,Fa=/^-?\d+(?:px)?$/i,
jb=/^-?\d/,kb={position:"absolute",visibility:"hidden",display:"block"},Pa=["Left","Right"],Qa=["Top","Bottom"],W,Ga,aa,lb=function(a,b){return b.toUpperCase()};c.fn.css=function(a,b){if(arguments.length===2&&b===B)return this;return c.access(this,a,b,true,function(d,e,f){return f!==B?c.style(d,e,f):c.css(d,e)})};c.extend({cssHooks:{opacity:{get:function(a,b){if(b){var d=W(a,"opacity","opacity");return d===""?"1":d}else return a.style.opacity}}},cssNumber:{zIndex:true,fontWeight:true,opacity:true,
zoom:true,lineHeight:true},cssProps:{"float":c.support.cssFloat?"cssFloat":"styleFloat"},style:function(a,b,d,e){if(!(!a||a.nodeType===3||a.nodeType===8||!a.style)){var f,h=c.camelCase(b),l=a.style,k=c.cssHooks[h];b=c.cssProps[h]||h;if(d!==B){if(!(typeof d==="number"&&isNaN(d)||d==null)){if(typeof d==="number"&&!c.cssNumber[h])d+="px";if(!k||!("set"in k)||(d=k.set(a,d))!==B)try{l[b]=d}catch(o){}}}else{if(k&&"get"in k&&(f=k.get(a,false,e))!==B)return f;return l[b]}}},css:function(a,b,d){var e,f=c.camelCase(b),
h=c.cssHooks[f];b=c.cssProps[f]||f;if(h&&"get"in h&&(e=h.get(a,true,d))!==B)return e;else if(W)return W(a,b,f)},swap:function(a,b,d){var e={},f;for(f in b){e[f]=a.style[f];a.style[f]=b[f]}d.call(a);for(f in b)a.style[f]=e[f]},camelCase:function(a){return a.replace(hb,lb)}});c.curCSS=c.css;c.each(["height","width"],function(a,b){c.cssHooks[b]={get:function(d,e,f){var h;if(e){if(d.offsetWidth!==0)h=oa(d,b,f);else c.swap(d,kb,function(){h=oa(d,b,f)});if(h<=0){h=W(d,b,b);if(h==="0px"&&aa)h=aa(d,b,b);
if(h!=null)return h===""||h==="auto"?"0px":h}if(h<0||h==null){h=d.style[b];return h===""||h==="auto"?"0px":h}return typeof h==="string"?h:h+"px"}},set:function(d,e){if(Fa.test(e)){e=parseFloat(e);if(e>=0)return e+"px"}else return e}}});if(!c.support.opacity)c.cssHooks.opacity={get:function(a,b){return gb.test((b&&a.currentStyle?a.currentStyle.filter:a.style.filter)||"")?parseFloat(RegExp.$1)/100+"":b?"1":""},set:function(a,b){var d=a.style;d.zoom=1;var e=c.isNaN(b)?"":"alpha(opacity="+b*100+")",f=
d.filter||"";d.filter=Ea.test(f)?f.replace(Ea,e):d.filter+" "+e}};if(t.defaultView&&t.defaultView.getComputedStyle)Ga=function(a,b,d){var e;d=d.replace(ib,"-$1").toLowerCase();if(!(b=a.ownerDocument.defaultView))return B;if(b=b.getComputedStyle(a,null)){e=b.getPropertyValue(d);if(e===""&&!c.contains(a.ownerDocument.documentElement,a))e=c.style(a,d)}return e};if(t.documentElement.currentStyle)aa=function(a,b){var d,e,f=a.currentStyle&&a.currentStyle[b],h=a.style;if(!Fa.test(f)&&jb.test(f)){d=h.left;
e=a.runtimeStyle.left;a.runtimeStyle.left=a.currentStyle.left;h.left=b==="fontSize"?"1em":f||0;f=h.pixelLeft+"px";h.left=d;a.runtimeStyle.left=e}return f===""?"auto":f};W=Ga||aa;if(c.expr&&c.expr.filters){c.expr.filters.hidden=function(a){var b=a.offsetHeight;return a.offsetWidth===0&&b===0||!c.support.reliableHiddenOffsets&&(a.style.display||c.css(a,"display"))==="none"};c.expr.filters.visible=function(a){return!c.expr.filters.hidden(a)}}var mb=c.now(),nb=/<script\b[^<]*(?:(?!<\/script>)<[^<]*)*<\/script>/gi,
ob=/^(?:select|textarea)/i,pb=/^(?:color|date|datetime|email|hidden|month|number|password|range|search|tel|text|time|url|week)$/i,qb=/^(?:GET|HEAD)$/,Ra=/\[\]$/,T=/\=\?(&|$)/,ja=/\?/,rb=/([?&])_=[^&]*/,sb=/^(\w+:)?\/\/([^\/?#]+)/,tb=/%20/g,ub=/#.*$/,Ha=c.fn.load;c.fn.extend({load:function(a,b,d){if(typeof a!=="string"&&Ha)return Ha.apply(this,arguments);else if(!this.length)return this;var e=a.indexOf(" ");if(e>=0){var f=a.slice(e,a.length);a=a.slice(0,e)}e="GET";if(b)if(c.isFunction(b)){d=b;b=null}else if(typeof b===
"object"){b=c.param(b,c.ajaxSettings.traditional);e="POST"}var h=this;c.ajax({url:a,type:e,dataType:"html",data:b,complete:function(l,k){if(k==="success"||k==="notmodified")h.html(f?c("<div>").append(l.responseText.replace(nb,"")).find(f):l.responseText);d&&h.each(d,[l.responseText,k,l])}});return this},serialize:function(){return c.param(this.serializeArray())},serializeArray:function(){return this.map(function(){return this.elements?c.makeArray(this.elements):this}).filter(function(){return this.name&&
!this.disabled&&(this.checked||ob.test(this.nodeName)||pb.test(this.type))}).map(function(a,b){var d=c(this).val();return d==null?null:c.isArray(d)?c.map(d,function(e){return{name:b.name,value:e}}):{name:b.name,value:d}}).get()}});c.each("ajaxStart ajaxStop ajaxComplete ajaxError ajaxSuccess ajaxSend".split(" "),function(a,b){c.fn[b]=function(d){return this.bind(b,d)}});c.extend({get:function(a,b,d,e){if(c.isFunction(b)){e=e||d;d=b;b=null}return c.ajax({type:"GET",url:a,data:b,success:d,dataType:e})},
getScript:function(a,b){return c.get(a,null,b,"script")},getJSON:function(a,b,d){return c.get(a,b,d,"json")},post:function(a,b,d,e){if(c.isFunction(b)){e=e||d;d=b;b={}}return c.ajax({type:"POST",url:a,data:b,success:d,dataType:e})},ajaxSetup:function(a){c.extend(c.ajaxSettings,a)},ajaxSettings:{url:location.href,global:true,type:"GET",contentType:"application/x-www-form-urlencoded",processData:true,async:true,xhr:function(){return new E.XMLHttpRequest},accepts:{xml:"application/xml, text/xml",html:"text/html",
script:"text/javascript, application/javascript",json:"application/json, text/javascript",text:"text/plain",_default:"*/*"}},ajax:function(a){var b=c.extend(true,{},c.ajaxSettings,a),d,e,f,h=b.type.toUpperCase(),l=qb.test(h);b.url=b.url.replace(ub,"");b.context=a&&a.context!=null?a.context:b;if(b.data&&b.processData&&typeof b.data!=="string")b.data=c.param(b.data,b.traditional);if(b.dataType==="jsonp"){if(h==="GET")T.test(b.url)||(b.url+=(ja.test(b.url)?"&":"?")+(b.jsonp||"callback")+"=?");else if(!b.data||
!T.test(b.data))b.data=(b.data?b.data+"&":"")+(b.jsonp||"callback")+"=?";b.dataType="json"}if(b.dataType==="json"&&(b.data&&T.test(b.data)||T.test(b.url))){d=b.jsonpCallback||"jsonp"+mb++;if(b.data)b.data=(b.data+"").replace(T,"="+d+"$1");b.url=b.url.replace(T,"="+d+"$1");b.dataType="script";var k=E[d];E[d]=function(m){if(c.isFunction(k))k(m);else{E[d]=B;try{delete E[d]}catch(p){}}f=m;c.handleSuccess(b,w,e,f);c.handleComplete(b,w,e,f);r&&r.removeChild(A)}}if(b.dataType==="script"&&b.cache===null)b.cache=
false;if(b.cache===false&&l){var o=c.now(),x=b.url.replace(rb,"$1_="+o);b.url=x+(x===b.url?(ja.test(b.url)?"&":"?")+"_="+o:"")}if(b.data&&l)b.url+=(ja.test(b.url)?"&":"?")+b.data;b.global&&c.active++===0&&c.event.trigger("ajaxStart");o=(o=sb.exec(b.url))&&(o[1]&&o[1].toLowerCase()!==location.protocol||o[2].toLowerCase()!==location.host);if(b.dataType==="script"&&h==="GET"&&o){var r=t.getElementsByTagName("head")[0]||t.documentElement,A=t.createElement("script");if(b.scriptCharset)A.charset=b.scriptCharset;
A.src=b.url;if(!d){var C=false;A.onload=A.onreadystatechange=function(){if(!C&&(!this.readyState||this.readyState==="loaded"||this.readyState==="complete")){C=true;c.handleSuccess(b,w,e,f);c.handleComplete(b,w,e,f);A.onload=A.onreadystatechange=null;r&&A.parentNode&&r.removeChild(A)}}}r.insertBefore(A,r.firstChild);return B}var J=false,w=b.xhr();if(w){b.username?w.open(h,b.url,b.async,b.username,b.password):w.open(h,b.url,b.async);try{if(b.data!=null&&!l||a&&a.contentType)w.setRequestHeader("Content-Type",
b.contentType);if(b.ifModified){c.lastModified[b.url]&&w.setRequestHeader("If-Modified-Since",c.lastModified[b.url]);c.etag[b.url]&&w.setRequestHeader("If-None-Match",c.etag[b.url])}o||w.setRequestHeader("X-Requested-With","XMLHttpRequest");w.setRequestHeader("Accept",b.dataType&&b.accepts[b.dataType]?b.accepts[b.dataType]+", */*; q=0.01":b.accepts._default)}catch(I){}if(b.beforeSend&&b.beforeSend.call(b.context,w,b)===false){b.global&&c.active--===1&&c.event.trigger("ajaxStop");w.abort();return false}b.global&&
c.triggerGlobal(b,"ajaxSend",[w,b]);var L=w.onreadystatechange=function(m){if(!w||w.readyState===0||m==="abort"){J||c.handleComplete(b,w,e,f);J=true;if(w)w.onreadystatechange=c.noop}else if(!J&&w&&(w.readyState===4||m==="timeout")){J=true;w.onreadystatechange=c.noop;e=m==="timeout"?"timeout":!c.httpSuccess(w)?"error":b.ifModified&&c.httpNotModified(w,b.url)?"notmodified":"success";var p;if(e==="success")try{f=c.httpData(w,b.dataType,b)}catch(q){e="parsererror";p=q}if(e==="success"||e==="notmodified")d||
c.handleSuccess(b,w,e,f);else c.handleError(b,w,e,p);d||c.handleComplete(b,w,e,f);m==="timeout"&&w.abort();if(b.async)w=null}};try{var g=w.abort;w.abort=function(){w&&Function.prototype.call.call(g,w);L("abort")}}catch(i){}b.async&&b.timeout>0&&setTimeout(function(){w&&!J&&L("timeout")},b.timeout);try{w.send(l||b.data==null?null:b.data)}catch(n){c.handleError(b,w,null,n);c.handleComplete(b,w,e,f)}b.async||L();return w}},param:function(a,b){var d=[],e=function(h,l){l=c.isFunction(l)?l():l;d[d.length]=
encodeURIComponent(h)+"="+encodeURIComponent(l)};if(b===B)b=c.ajaxSettings.traditional;if(c.isArray(a)||a.jquery)c.each(a,function(){e(this.name,this.value)});else for(var f in a)da(f,a[f],b,e);return d.join("&").replace(tb,"+")}});c.extend({active:0,lastModified:{},etag:{},handleError:function(a,b,d,e){a.error&&a.error.call(a.context,b,d,e);a.global&&c.triggerGlobal(a,"ajaxError",[b,a,e])},handleSuccess:function(a,b,d,e){a.success&&a.success.call(a.context,e,d,b);a.global&&c.triggerGlobal(a,"ajaxSuccess",
[b,a])},handleComplete:function(a,b,d){a.complete&&a.complete.call(a.context,b,d);a.global&&c.triggerGlobal(a,"ajaxComplete",[b,a]);a.global&&c.active--===1&&c.event.trigger("ajaxStop")},triggerGlobal:function(a,b,d){(a.context&&a.context.url==null?c(a.context):c.event).trigger(b,d)},httpSuccess:function(a){try{return!a.status&&location.protocol==="file:"||a.status>=200&&a.status<300||a.status===304||a.status===1223}catch(b){}return false},httpNotModified:function(a,b){var d=a.getResponseHeader("Last-Modified"),
e=a.getResponseHeader("Etag");if(d)c.lastModified[b]=d;if(e)c.etag[b]=e;return a.status===304},httpData:function(a,b,d){var e=a.getResponseHeader("content-type")||"",f=b==="xml"||!b&&e.indexOf("xml")>=0;a=f?a.responseXML:a.responseText;f&&a.documentElement.nodeName==="parsererror"&&c.error("parsererror");if(d&&d.dataFilter)a=d.dataFilter(a,b);if(typeof a==="string")if(b==="json"||!b&&e.indexOf("json")>=0)a=c.parseJSON(a);else if(b==="script"||!b&&e.indexOf("javascript")>=0)c.globalEval(a);return a}});
if(E.ActiveXObject)c.ajaxSettings.xhr=function(){if(E.location.protocol!=="file:")try{return new E.XMLHttpRequest}catch(a){}try{return new E.ActiveXObject("Microsoft.XMLHTTP")}catch(b){}};c.support.ajax=!!c.ajaxSettings.xhr();var ea={},vb=/^(?:toggle|show|hide)$/,wb=/^([+\-]=)?([\d+.\-]+)(.*)$/,ba,pa=[["height","marginTop","marginBottom","paddingTop","paddingBottom"],["width","marginLeft","marginRight","paddingLeft","paddingRight"],["opacity"]];c.fn.extend({show:function(a,b,d){if(a||a===0)return this.animate(S("show",
3),a,b,d);else{d=0;for(var e=this.length;d<e;d++){a=this[d];b=a.style.display;if(!c.data(a,"olddisplay")&&b==="none")b=a.style.display="";b===""&&c.css(a,"display")==="none"&&c.data(a,"olddisplay",qa(a.nodeName))}for(d=0;d<e;d++){a=this[d];b=a.style.display;if(b===""||b==="none")a.style.display=c.data(a,"olddisplay")||""}return this}},hide:function(a,b,d){if(a||a===0)return this.animate(S("hide",3),a,b,d);else{a=0;for(b=this.length;a<b;a++){d=c.css(this[a],"display");d!=="none"&&c.data(this[a],"olddisplay",
d)}for(a=0;a<b;a++)this[a].style.display="none";return this}},_toggle:c.fn.toggle,toggle:function(a,b,d){var e=typeof a==="boolean";if(c.isFunction(a)&&c.isFunction(b))this._toggle.apply(this,arguments);else a==null||e?this.each(function(){var f=e?a:c(this).is(":hidden");c(this)[f?"show":"hide"]()}):this.animate(S("toggle",3),a,b,d);return this},fadeTo:function(a,b,d,e){return this.filter(":hidden").css("opacity",0).show().end().animate({opacity:b},a,d,e)},animate:function(a,b,d,e){var f=c.speed(b,
d,e);if(c.isEmptyObject(a))return this.each(f.complete);return this[f.queue===false?"each":"queue"](function(){var h=c.extend({},f),l,k=this.nodeType===1,o=k&&c(this).is(":hidden"),x=this;for(l in a){var r=c.camelCase(l);if(l!==r){a[r]=a[l];delete a[l];l=r}if(a[l]==="hide"&&o||a[l]==="show"&&!o)return h.complete.call(this);if(k&&(l==="height"||l==="width")){h.overflow=[this.style.overflow,this.style.overflowX,this.style.overflowY];if(c.css(this,"display")==="inline"&&c.css(this,"float")==="none")if(c.support.inlineBlockNeedsLayout)if(qa(this.nodeName)===
"inline")this.style.display="inline-block";else{this.style.display="inline";this.style.zoom=1}else this.style.display="inline-block"}if(c.isArray(a[l])){(h.specialEasing=h.specialEasing||{})[l]=a[l][1];a[l]=a[l][0]}}if(h.overflow!=null)this.style.overflow="hidden";h.curAnim=c.extend({},a);c.each(a,function(A,C){var J=new c.fx(x,h,A);if(vb.test(C))J[C==="toggle"?o?"show":"hide":C](a);else{var w=wb.exec(C),I=J.cur()||0;if(w){var L=parseFloat(w[2]),g=w[3]||"px";if(g!=="px"){c.style(x,A,(L||1)+g);I=(L||
1)/J.cur()*I;c.style(x,A,I+g)}if(w[1])L=(w[1]==="-="?-1:1)*L+I;J.custom(I,L,g)}else J.custom(I,C,"")}});return true})},stop:function(a,b){var d=c.timers;a&&this.queue([]);this.each(function(){for(var e=d.length-1;e>=0;e--)if(d[e].elem===this){b&&d[e](true);d.splice(e,1)}});b||this.dequeue();return this}});c.each({slideDown:S("show",1),slideUp:S("hide",1),slideToggle:S("toggle",1),fadeIn:{opacity:"show"},fadeOut:{opacity:"hide"},fadeToggle:{opacity:"toggle"}},function(a,b){c.fn[a]=function(d,e,f){return this.animate(b,
d,e,f)}});c.extend({speed:function(a,b,d){var e=a&&typeof a==="object"?c.extend({},a):{complete:d||!d&&b||c.isFunction(a)&&a,duration:a,easing:d&&b||b&&!c.isFunction(b)&&b};e.duration=c.fx.off?0:typeof e.duration==="number"?e.duration:e.duration in c.fx.speeds?c.fx.speeds[e.duration]:c.fx.speeds._default;e.old=e.complete;e.complete=function(){e.queue!==false&&c(this).dequeue();c.isFunction(e.old)&&e.old.call(this)};return e},easing:{linear:function(a,b,d,e){return d+e*a},swing:function(a,b,d,e){return(-Math.cos(a*
Math.PI)/2+0.5)*e+d}},timers:[],fx:function(a,b,d){this.options=b;this.elem=a;this.prop=d;if(!b.orig)b.orig={}}});c.fx.prototype={update:function(){this.options.step&&this.options.step.call(this.elem,this.now,this);(c.fx.step[this.prop]||c.fx.step._default)(this)},cur:function(){if(this.elem[this.prop]!=null&&(!this.elem.style||this.elem.style[this.prop]==null))return this.elem[this.prop];var a=parseFloat(c.css(this.elem,this.prop));return a&&a>-1E4?a:0},custom:function(a,b,d){function e(l){return f.step(l)}
var f=this,h=c.fx;this.startTime=c.now();this.start=a;this.end=b;this.unit=d||this.unit||"px";this.now=this.start;this.pos=this.state=0;e.elem=this.elem;if(e()&&c.timers.push(e)&&!ba)ba=setInterval(h.tick,h.interval)},show:function(){this.options.orig[this.prop]=c.style(this.elem,this.prop);this.options.show=true;this.custom(this.prop==="width"||this.prop==="height"?1:0,this.cur());c(this.elem).show()},hide:function(){this.options.orig[this.prop]=c.style(this.elem,this.prop);this.options.hide=true;
this.custom(this.cur(),0)},step:function(a){var b=c.now(),d=true;if(a||b>=this.options.duration+this.startTime){this.now=this.end;this.pos=this.state=1;this.update();this.options.curAnim[this.prop]=true;for(var e in this.options.curAnim)if(this.options.curAnim[e]!==true)d=false;if(d){if(this.options.overflow!=null&&!c.support.shrinkWrapBlocks){var f=this.elem,h=this.options;c.each(["","X","Y"],function(k,o){f.style["overflow"+o]=h.overflow[k]})}this.options.hide&&c(this.elem).hide();if(this.options.hide||
this.options.show)for(var l in this.options.curAnim)c.style(this.elem,l,this.options.orig[l]);this.options.complete.call(this.elem)}return false}else{a=b-this.startTime;this.state=a/this.options.duration;b=this.options.easing||(c.easing.swing?"swing":"linear");this.pos=c.easing[this.options.specialEasing&&this.options.specialEasing[this.prop]||b](this.state,a,0,1,this.options.duration);this.now=this.start+(this.end-this.start)*this.pos;this.update()}return true}};c.extend(c.fx,{tick:function(){for(var a=
c.timers,b=0;b<a.length;b++)a[b]()||a.splice(b--,1);a.length||c.fx.stop()},interval:13,stop:function(){clearInterval(ba);ba=null},speeds:{slow:600,fast:200,_default:400},step:{opacity:function(a){c.style(a.elem,"opacity",a.now)},_default:function(a){if(a.elem.style&&a.elem.style[a.prop]!=null)a.elem.style[a.prop]=(a.prop==="width"||a.prop==="height"?Math.max(0,a.now):a.now)+a.unit;else a.elem[a.prop]=a.now}}});if(c.expr&&c.expr.filters)c.expr.filters.animated=function(a){return c.grep(c.timers,function(b){return a===
b.elem}).length};var xb=/^t(?:able|d|h)$/i,Ia=/^(?:body|html)$/i;c.fn.offset="getBoundingClientRect"in t.documentElement?function(a){var b=this[0],d;if(a)return this.each(function(l){c.offset.setOffset(this,a,l)});if(!b||!b.ownerDocument)return null;if(b===b.ownerDocument.body)return c.offset.bodyOffset(b);try{d=b.getBoundingClientRect()}catch(e){}var f=b.ownerDocument,h=f.documentElement;if(!d||!c.contains(h,b))return d||{top:0,left:0};b=f.body;f=fa(f);return{top:d.top+(f.pageYOffset||c.support.boxModel&&
h.scrollTop||b.scrollTop)-(h.clientTop||b.clientTop||0),left:d.left+(f.pageXOffset||c.support.boxModel&&h.scrollLeft||b.scrollLeft)-(h.clientLeft||b.clientLeft||0)}}:function(a){var b=this[0];if(a)return this.each(function(x){c.offset.setOffset(this,a,x)});if(!b||!b.ownerDocument)return null;if(b===b.ownerDocument.body)return c.offset.bodyOffset(b);c.offset.initialize();var d,e=b.offsetParent,f=b.ownerDocument,h=f.documentElement,l=f.body;d=(f=f.defaultView)?f.getComputedStyle(b,null):b.currentStyle;
for(var k=b.offsetTop,o=b.offsetLeft;(b=b.parentNode)&&b!==l&&b!==h;){if(c.offset.supportsFixedPosition&&d.position==="fixed")break;d=f?f.getComputedStyle(b,null):b.currentStyle;k-=b.scrollTop;o-=b.scrollLeft;if(b===e){k+=b.offsetTop;o+=b.offsetLeft;if(c.offset.doesNotAddBorder&&!(c.offset.doesAddBorderForTableAndCells&&xb.test(b.nodeName))){k+=parseFloat(d.borderTopWidth)||0;o+=parseFloat(d.borderLeftWidth)||0}e=b.offsetParent}if(c.offset.subtractsBorderForOverflowNotVisible&&d.overflow!=="visible"){k+=
parseFloat(d.borderTopWidth)||0;o+=parseFloat(d.borderLeftWidth)||0}d=d}if(d.position==="relative"||d.position==="static"){k+=l.offsetTop;o+=l.offsetLeft}if(c.offset.supportsFixedPosition&&d.position==="fixed"){k+=Math.max(h.scrollTop,l.scrollTop);o+=Math.max(h.scrollLeft,l.scrollLeft)}return{top:k,left:o}};c.offset={initialize:function(){var a=t.body,b=t.createElement("div"),d,e,f,h=parseFloat(c.css(a,"marginTop"))||0;c.extend(b.style,{position:"absolute",top:0,left:0,margin:0,border:0,width:"1px",
height:"1px",visibility:"hidden"});b.innerHTML="<div style='position:absolute;top:0;left:0;margin:0;border:5px solid #000;padding:0;width:1px;height:1px;'><div></div></div><table style='position:absolute;top:0;left:0;margin:0;border:5px solid #000;padding:0;width:1px;height:1px;' cellpadding='0' cellspacing='0'><tr><td></td></tr></table>";a.insertBefore(b,a.firstChild);d=b.firstChild;e=d.firstChild;f=d.nextSibling.firstChild.firstChild;this.doesNotAddBorder=e.offsetTop!==5;this.doesAddBorderForTableAndCells=
f.offsetTop===5;e.style.position="fixed";e.style.top="20px";this.supportsFixedPosition=e.offsetTop===20||e.offsetTop===15;e.style.position=e.style.top="";d.style.overflow="hidden";d.style.position="relative";this.subtractsBorderForOverflowNotVisible=e.offsetTop===-5;this.doesNotIncludeMarginInBodyOffset=a.offsetTop!==h;a.removeChild(b);c.offset.initialize=c.noop},bodyOffset:function(a){var b=a.offsetTop,d=a.offsetLeft;c.offset.initialize();if(c.offset.doesNotIncludeMarginInBodyOffset){b+=parseFloat(c.css(a,
"marginTop"))||0;d+=parseFloat(c.css(a,"marginLeft"))||0}return{top:b,left:d}},setOffset:function(a,b,d){var e=c.css(a,"position");if(e==="static")a.style.position="relative";var f=c(a),h=f.offset(),l=c.css(a,"top"),k=c.css(a,"left"),o=e==="absolute"&&c.inArray("auto",[l,k])>-1;e={};var x={};if(o)x=f.position();l=o?x.top:parseInt(l,10)||0;k=o?x.left:parseInt(k,10)||0;if(c.isFunction(b))b=b.call(a,d,h);if(b.top!=null)e.top=b.top-h.top+l;if(b.left!=null)e.left=b.left-h.left+k;"using"in b?b.using.call(a,
e):f.css(e)}};c.fn.extend({position:function(){if(!this[0])return null;var a=this[0],b=this.offsetParent(),d=this.offset(),e=Ia.test(b[0].nodeName)?{top:0,left:0}:b.offset();d.top-=parseFloat(c.css(a,"marginTop"))||0;d.left-=parseFloat(c.css(a,"marginLeft"))||0;e.top+=parseFloat(c.css(b[0],"borderTopWidth"))||0;e.left+=parseFloat(c.css(b[0],"borderLeftWidth"))||0;return{top:d.top-e.top,left:d.left-e.left}},offsetParent:function(){return this.map(function(){for(var a=this.offsetParent||t.body;a&&!Ia.test(a.nodeName)&&
c.css(a,"position")==="static";)a=a.offsetParent;return a})}});c.each(["Left","Top"],function(a,b){var d="scroll"+b;c.fn[d]=function(e){var f=this[0],h;if(!f)return null;if(e!==B)return this.each(function(){if(h=fa(this))h.scrollTo(!a?e:c(h).scrollLeft(),a?e:c(h).scrollTop());else this[d]=e});else return(h=fa(f))?"pageXOffset"in h?h[a?"pageYOffset":"pageXOffset"]:c.support.boxModel&&h.document.documentElement[d]||h.document.body[d]:f[d]}});c.each(["Height","Width"],function(a,b){var d=b.toLowerCase();
c.fn["inner"+b]=function(){return this[0]?parseFloat(c.css(this[0],d,"padding")):null};c.fn["outer"+b]=function(e){return this[0]?parseFloat(c.css(this[0],d,e?"margin":"border")):null};c.fn[d]=function(e){var f=this[0];if(!f)return e==null?null:this;if(c.isFunction(e))return this.each(function(l){var k=c(this);k[d](e.call(this,l,k[d]()))});if(c.isWindow(f))return f.document.compatMode==="CSS1Compat"&&f.document.documentElement["client"+b]||f.document.body["client"+b];else if(f.nodeType===9)return Math.max(f.documentElement["client"+
b],f.body["scroll"+b],f.documentElement["scroll"+b],f.body["offset"+b],f.documentElement["offset"+b]);else if(e===B){f=c.css(f,d);var h=parseFloat(f);return c.isNaN(h)?f:h}else return this.css(d,typeof e==="string"?e:e+"px")}})})(window);
</script><script type="text/javascript">//XRegExp 1.5.0 <xregexp.com> MIT License
var XRegExp;if(XRegExp){throw Error("can't load XRegExp twice in the same frame")}(function(){XRegExp=function(w,r){var q=[],u=XRegExp.OUTSIDE_CLASS,x=0,p,s,v,t,y;if(XRegExp.isRegExp(w)){if(r!==undefined){throw TypeError("can't supply flags when constructing one RegExp from another")}return j(w)}if(g){throw Error("can't call the XRegExp constructor within token definition functions")}r=r||"";p={hasNamedCapture:false,captureNames:[],hasFlag:function(z){return r.indexOf(z)>-1},setFlag:function(z){r+=z}};while(x<w.length){s=o(w,x,u,p);if(s){q.push(s.output);x+=(s.match[0].length||1)}else{if(v=m.exec.call(i[u],w.slice(x))){q.push(v[0]);x+=v[0].length}else{t=w.charAt(x);if(t==="["){u=XRegExp.INSIDE_CLASS}else{if(t==="]"){u=XRegExp.OUTSIDE_CLASS}}q.push(t);x++}}}y=RegExp(q.join(""),m.replace.call(r,h,""));y._xregexp={source:w,captureNames:p.hasNamedCapture?p.captureNames:null};return y};XRegExp.version="1.5.0";XRegExp.INSIDE_CLASS=1;XRegExp.OUTSIDE_CLASS=2;var c=/\$(?:(\d\d?|[$&`'])|{([$\w]+)})/g,h=/[^gimy]+|([\s\S])(?=[\s\S]*\1)/g,n=/^(?:[?*+]|{\d+(?:,\d*)?})\??/,g=false,k=[],m={exec:RegExp.prototype.exec,test:RegExp.prototype.test,match:String.prototype.match,replace:String.prototype.replace,split:String.prototype.split},a=m.exec.call(/()??/,"")[1]===undefined,e=function(){var p=/^/g;m.test.call(p,"");return !p.lastIndex}(),f=function(){var p=/x/g;m.replace.call("x",p,"");return !p.lastIndex}(),b=RegExp.prototype.sticky!==undefined,i={};i[XRegExp.INSIDE_CLASS]=/^(?:\\(?:[0-3][0-7]{0,2}|[4-7][0-7]?|x[\dA-Fa-f]{2}|u[\dA-Fa-f]{4}|c[A-Za-z]|[\s\S]))/;i[XRegExp.OUTSIDE_CLASS]=/^(?:\\(?:0(?:[0-3][0-7]{0,2}|[4-7][0-7]?)?|[1-9]\d*|x[\dA-Fa-f]{2}|u[\dA-Fa-f]{4}|c[A-Za-z]|[\s\S])|\(\?[:=!]|[?*+]\?|{\d+(?:,\d*)?}\??)/;XRegExp.addToken=function(s,r,q,p){k.push({pattern:j(s,"g"+(b?"y":"")),handler:r,scope:q||XRegExp.OUTSIDE_CLASS,trigger:p||null})};XRegExp.cache=function(r,p){var q=r+"/"+(p||"");return XRegExp.cache[q]||(XRegExp.cache[q]=XRegExp(r,p))};XRegExp.copyAsGlobal=function(p){return j(p,"g")};XRegExp.escape=function(p){return p.replace(/[-[\]{}()*+?.,\\^$|#\s]/g,"\\$&")};XRegExp.execAt=function(s,r,t,q){r=j(r,"g"+((q&&b)?"y":""));r.lastIndex=t=t||0;var p=r.exec(s);if(q){return(p&&p.index===t)?p:null}else{return p}};XRegExp.freezeTokens=function(){XRegExp.addToken=function(){throw Error("can't run addToken after freezeTokens")}};XRegExp.isRegExp=function(p){return Object.prototype.toString.call(p)==="[object RegExp]"};XRegExp.iterate=function(u,p,v,s){var t=j(p,"g"),r=-1,q;while(q=t.exec(u)){v.call(s,q,++r,u,t);if(t.lastIndex===q.index){t.lastIndex++}}if(p.global){p.lastIndex=0}};XRegExp.matchChain=function(q,p){return function r(s,x){var v=p[x].regex?p[x]:{regex:p[x]},u=j(v.regex,"g"),w=[],t;for(t=0;t<s.length;t++){XRegExp.iterate(s[t],u,function(y){w.push(v.backref?(y[v.backref]||""):y[0])})}return((x===p.length-1)||!w.length)?w:r(w,x+1)}([q],0)};RegExp.prototype.apply=function(q,p){return this.exec(p[0])};RegExp.prototype.call=function(p,q){return this.exec(q)};RegExp.prototype.exec=function(t){var r=m.exec.apply(this,arguments),q,p;if(r){if(!a&&r.length>1&&l(r,"")>-1){p=RegExp(this.source,m.replace.call(d(this),"g",""));m.replace.call(t.slice(r.index),p,function(){for(var u=1;u<arguments.length-2;u++){if(arguments[u]===undefined){r[u]=undefined}}})}if(this._xregexp&&this._xregexp.captureNames){for(var s=1;s<r.length;s++){q=this._xregexp.captureNames[s-1];if(q){r[q]=r[s]}}}if(!e&&this.global&&!r[0].length&&(this.lastIndex>r.index)){this.lastIndex--}}return r};if(!e){RegExp.prototype.test=function(q){var p=m.exec.call(this,q);if(p&&this.global&&!p[0].length&&(this.lastIndex>p.index)){this.lastIndex--}return !!p}}String.prototype.match=function(q){if(!XRegExp.isRegExp(q)){q=RegExp(q)}if(q.global){var p=m.match.apply(this,arguments);q.lastIndex=0;return p}return q.exec(this)};String.prototype.replace=function(r,s){var t=XRegExp.isRegExp(r),q,p,u;if(t&&typeof s.valueOf()==="string"&&s.indexOf("${")===-1&&f){return m.replace.apply(this,arguments)}if(!t){r=r+""}else{if(r._xregexp){q=r._xregexp.captureNames}}if(typeof s==="function"){p=m.replace.call(this,r,function(){if(q){arguments[0]=new String(arguments[0]);for(var v=0;v<q.length;v++){if(q[v]){arguments[0][q[v]]=arguments[v+1]}}}if(t&&r.global){r.lastIndex=arguments[arguments.length-2]+arguments[0].length}return s.apply(null,arguments)})}else{u=this+"";p=m.replace.call(u,r,function(){var v=arguments;return m.replace.call(s,c,function(x,w,A){if(w){switch(w){case"$":return"$";case"&":return v[0];case"`":return v[v.length-1].slice(0,v[v.length-2]);case"'":return v[v.length-1].slice(v[v.length-2]+v[0].length);default:var y="";w=+w;if(!w){return x}while(w>v.length-3){y=String.prototype.slice.call(w,-1)+y;w=Math.floor(w/10)}return(w?v[w]||"":"$")+y}}else{var z=+A;if(z<=v.length-3){return v[z]}z=q?l(q,A):-1;return z>-1?v[z+1]:x}})})}if(t&&r.global){r.lastIndex=0}return p};String.prototype.split=function(u,p){if(!XRegExp.isRegExp(u)){return m.split.apply(this,arguments)}var w=this+"",r=[],v=0,t,q;if(p===undefined||+p<0){p=Infinity}else{p=Math.floor(+p);if(!p){return[]}}u=XRegExp.copyAsGlobal(u);while(t=u.exec(w)){if(u.lastIndex>v){r.push(w.slice(v,t.index));if(t.length>1&&t.index<w.length){Array.prototype.push.apply(r,t.slice(1))}q=t[0].length;v=u.lastIndex;if(r.length>=p){break}}if(u.lastIndex===t.index){u.lastIndex++}}if(v===w.length){if(!m.test.call(u,"")||q){r.push("")}}else{r.push(w.slice(v))}return r.length>p?r.slice(0,p):r};function j(r,q){if(!XRegExp.isRegExp(r)){throw TypeError("type RegExp expected")}var p=r._xregexp;r=XRegExp(r.source,d(r)+(q||""));if(p){r._xregexp={source:p.source,captureNames:p.captureNames?p.captureNames.slice(0):null}}return r}function d(p){return(p.global?"g":"")+(p.ignoreCase?"i":"")+(p.multiline?"m":"")+(p.extended?"x":"")+(p.sticky?"y":"")}function o(v,u,w,p){var r=k.length,y,s,x;g=true;try{while(r--){x=k[r];if((w&x.scope)&&(!x.trigger||x.trigger.call(p))){x.pattern.lastIndex=u;s=x.pattern.exec(v);if(s&&s.index===u){y={output:x.handler.call(p,s,w),match:s};break}}}}catch(q){throw q}finally{g=false}return y}function l(s,q,r){if(Array.prototype.indexOf){return s.indexOf(q,r)}for(var p=r||0;p<s.length;p++){if(s[p]===q){return p}}return -1}XRegExp.addToken(/\(\?#[^)]*\)/,function(p){return m.test.call(n,p.input.slice(p.index+p[0].length))?"":"(?:)"});XRegExp.addToken(/\((?!\?)/,function(){this.captureNames.push(null);return"("});XRegExp.addToken(/\(\?<([$\w]+)>/,function(p){this.captureNames.push(p[1]);this.hasNamedCapture=true;return"("});XRegExp.addToken(/\\k<([\w$]+)>/,function(q){var p=l(this.captureNames,q[1]);return p>-1?"\\"+(p+1)+(isNaN(q.input.charAt(q.index+q[0].length))?"":"(?:)"):q[0]});XRegExp.addToken(/\[\^?]/,function(p){return p[0]==="[]"?"\\b\\B":"[\\s\\S]"});XRegExp.addToken(/^\(\?([imsx]+)\)/,function(p){this.setFlag(p[1]);return""});XRegExp.addToken(/(?:\s+|#.*)+/,function(p){return m.test.call(n,p.input.slice(p.index+p[0].length))?"":"(?:)"},XRegExp.OUTSIDE_CLASS,function(){return this.hasFlag("x")});XRegExp.addToken(/\./,function(){return"[\\s\\S]"},XRegExp.OUTSIDE_CLASS,function(){return this.hasFlag("s")})})();
</script><script type="text/javascript">/**
 * SyntaxHighlighter
 * http://alexgorbatchev.com/SyntaxHighlighter
 *
 * SyntaxHighlighter is donationware. If you are using it, please donate.
 * http://alexgorbatchev.com/SyntaxHighlighter/donate.html
 *
 * @version
 * 3.0.83 (July 02 2010)
 * 
 * @copyright
 * Copyright (C) 2004-2010 Alex Gorbatchev.
 *
 * @license
 * Dual licensed under the MIT and GPL licenses.
 */
//
// Begin anonymous function. This is used to contain local scope variables without polutting global scope.
//
var SyntaxHighlighter = function() { 

// CommonJS
if (typeof(require) != 'undefined' && typeof(XRegExp) == 'undefined')
{
	XRegExp = require('XRegExp').XRegExp;
}

// Shortcut object which will be assigned to the SyntaxHighlighter variable.
// This is a shorthand for local reference in order to avoid long namespace 
// references to SyntaxHighlighter.whatever...
var sh = {
	defaults : {
		/** Additional CSS class names to be added to highlighter elements. */
		'class-name' : '',
		
		/** First line number. */
		'first-line' : 1,
		
		/**
		 * Pads line numbers. Possible values are:
		 *
		 *   false - don't pad line numbers.
		 *   true  - automaticaly pad numbers with minimum required number of leading zeroes.
		 *   [int] - length up to which pad line numbers.
		 */
		'pad-line-numbers' : false,
		
		/** Lines to highlight. */
		'highlight' : null,
		
		/** Title to be displayed above the code block. */
		'title' : null,
		
		/** Enables or disables smart tabs. */
		'smart-tabs' : true,
		
		/** Gets or sets tab size. */
		'tab-size' : 4,
		
		/** Enables or disables gutter. */
		'gutter' : true,
		
		/** Enables or disables toolbar. */
		'toolbar' : true,
		
		/** Enables quick code copy and paste from double click. */
		'quick-code' : true,
		
		/** Forces code view to be collapsed. */
		'collapse' : false,
		
		/** Enables or disables automatic links. */
		'auto-links' : true,
		
		/** Gets or sets light mode. Equavalent to turning off gutter and toolbar. */
		'light' : false,
		
		'html-script' : false
	},
	
	config : {
		space : '&nbsp;',
		
		/** Enables use of <SCRIPT type="syntaxhighlighter" /> tags. */
		useScriptTags : true,
		
		/** Blogger mode flag. */
		bloggerMode : false,
		
		stripBrs : false,
		
		/** Name of the tag that SyntaxHighlighter will automatically look for. */
		tagName : 'pre',
		
		strings : {
			expandSource : 'expand source',
			help : '?',
			alert: 'SyntaxHighlighter\n\n',
			noBrush : 'Can\'t find brush for: ',
			brushNotHtmlScript : 'Brush wasn\'t configured for html-script option: ',
			
			// this is populated by the build script
			aboutDialog : '<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8" /><title>About SyntaxHighlighter</title></head><body style="font-family:Geneva,Arial,Helvetica,sans-serif;background-color:#fff;color:#000;font-size:1em;text-align:center;"><div style="text-align:center;margin-top:1.5em;"><div style="font-size:xx-large;">SyntaxHighlighter</div><div style="font-size:.75em;margin-bottom:3em;"><div>version 3.0.83 (July 02 2010)</div><div><a href="http://alexgorbatchev.com/SyntaxHighlighter" target="_blank" style="color:#005896">http://alexgorbatchev.com/SyntaxHighlighter</a></div><div>JavaScript code syntax highlighter.</div><div>Copyright 2004-2010 Alex Gorbatchev.</div></div><div>If you like this script, please <a href="https://www.paypal.com/cgi-bin/webscr?cmd=_s-xclick&hosted_button_id=2930402" style="color:#005896">donate</a> to <br/>keep development active!</div></div></body></html>'
		}
	},
	
	/** Internal 'global' variables. */
	vars : {
		discoveredBrushes : null,
		highlighters : {}
	},
	
	/** This object is populated by user included external brush files. */
	brushes : {},

	/** Common regular expressions. */
	regexLib : {
		multiLineCComments			: /\/\*[\s\S]*?\*\//gm,
		singleLineCComments			: /\/\/.*$/gm,
		singleLinePerlComments		: /#.*$/gm,
		doubleQuotedString			: /"([^\\"\n]|\\.)*"/g,
		singleQuotedString			: /'([^\\'\n]|\\.)*'/g,
		multiLineDoubleQuotedString	: new XRegExp('"([^\\\\"]|\\\\.)*"', 'gs'),
		multiLineSingleQuotedString	: new XRegExp("'([^\\\\']|\\\\.)*'", 'gs'),
		xmlComments					: /(&lt;|<)!--[\s\S]*?--(&gt;|>)/gm,
		url							: /\w+:\/\/[\w-.\/?%&=:@;]*/g,
		
		/** <?= ?> tags. */
		phpScriptTags 				: { left: /(&lt;|<)\?=?/g, right: /\?(&gt;|>)/g },
		
		/** <%= %> tags. */
		aspScriptTags				: { left: /(&lt;|<)%=?/g, right: /%(&gt;|>)/g },
		
		scriptScriptTags			: { left: /(&lt;|<)\s*script.*?(&gt;|>)/gi, right: /(&lt;|<)\/\s*script\s*(&gt;|>)/gi }
	},

	toolbar: {
		/**
		 * Generates HTML markup for the toolbar.
		 * @param {Highlighter} highlighter Highlighter instance.
		 * @return {String} Returns HTML markup.
		 */
		getHtml: function(highlighter)
		{
			var html = '<div class="toolbar">',
				items = sh.toolbar.items,
				list = items.list
				;
			
			function defaultGetHtml(highlighter, name)
			{
				return sh.toolbar.getButtonHtml(highlighter, name, sh.config.strings[name]);
			};
			
			for (var i = 0; i < list.length; i++)
				html += (items[list[i]].getHtml || defaultGetHtml)(highlighter, list[i]);
			
			html += '</div>';
			
			return html;
		},
		
		/**
		 * Generates HTML markup for a regular button in the toolbar.
		 * @param {Highlighter} highlighter Highlighter instance.
		 * @param {String} commandName		Command name that would be executed.
		 * @param {String} label			Label text to display.
		 * @return {String}					Returns HTML markup.
		 */
		getButtonHtml: function(highlighter, commandName, label)
		{
			return '<span><a href="#" class="toolbar_item'
				+ ' command_' + commandName
				+ ' ' + commandName
				+ '">' + label + '</a></span>'
				;
		},
		
		/**
		 * Event handler for a toolbar anchor.
		 */
		handler: function(e)
		{
			var target = e.target,
				className = target.className || ''
				;

			function getValue(name)
			{
				var r = new RegExp(name + '_(\\w+)'),
					match = r.exec(className)
					;

				return match ? match[1] : null;
			};
			
			var highlighter = getHighlighterById(findParentElement(target, '.syntaxhighlighter').id),
				commandName = getValue('command')
				;
			
			// execute the toolbar command
			if (highlighter && commandName)
				sh.toolbar.items[commandName].execute(highlighter);

			// disable default A click behaviour
			e.preventDefault();
		},
		
		/** Collection of toolbar items. */
		items : {
			// Ordered lis of items in the toolbar. Can't expect `for (var n in items)` to be consistent.
			list: ['expandSource', 'help'],

			expandSource: {
				getHtml: function(highlighter)
				{
					if (highlighter.getParam('collapse') != true)
						return '';
						
					var title = highlighter.getParam('title');
					return sh.toolbar.getButtonHtml(highlighter, 'expandSource', title ? title : sh.config.strings.expandSource);
				},
			
				execute: function(highlighter)
				{
					var div = getHighlighterDivById(highlighter.id);
					removeClass(div, 'collapsed');
				}
			},

			/** Command to display the about dialog window. */
			help: {
				execute: function(highlighter)
				{	
					var wnd = popup('', '_blank', 500, 250, 'scrollbars=0'),
						doc = wnd.document
						;
					
					doc.write(sh.config.strings.aboutDialog);
					doc.close();
					wnd.focus();
				}
			}
		}
	},

	/**
	 * Finds all elements on the page which should be processes by SyntaxHighlighter.
	 *
	 * @param {Object} globalParams		Optional parameters which override element's 
	 * 									parameters. Only used if element is specified.
	 * 
	 * @param {Object} element	Optional element to highlight. If none is
	 * 							provided, all elements in the current document 
	 * 							are returned which qualify.
	 *
	 * @return {Array}	Returns list of <code>{ target: DOMElement, params: Object }</code> objects.
	 */
	findElements: function(globalParams, element)
	{
		var elements = element ? [element] : toArray(document.getElementsByTagName(sh.config.tagName)), 
			conf = sh.config,
			result = []
			;

		// support for <SCRIPT TYPE="syntaxhighlighter" /> feature
		if (conf.useScriptTags)
			elements = elements.concat(getSyntaxHighlighterScriptTags());

		if (elements.length === 0) 
			return result;
	
		for (var i = 0; i < elements.length; i++) 
		{
			var item = {
				target: elements[i], 
				// local params take precedence over globals
				params: merge(globalParams, parseParams(elements[i].className))
			};

			if (item.params['brush'] == null)
				continue;
				
			result.push(item);
		}
		
		return result;
	},

	/**
	 * Shorthand to highlight all elements on the page that are marked as 
	 * SyntaxHighlighter source code.
	 * 
	 * @param {Object} globalParams		Optional parameters which override element's 
	 * 									parameters. Only used if element is specified.
	 * 
	 * @param {Object} element	Optional element to highlight. If none is
	 * 							provided, all elements in the current document 
	 * 							are highlighted.
	 */ 
	highlight: function(globalParams, element)
	{
		var elements = this.findElements(globalParams, element),
			propertyName = 'innerHTML', 
			highlighter = null,
			conf = sh.config
			;

		if (elements.length === 0) 
			return;
	
		for (var i = 0; i < elements.length; i++) 
		{
			var element = elements[i],
				target = element.target,
				params = element.params,
				brushName = params.brush,
				code
				;

			if (brushName == null)
				continue;

			// Instantiate a brush
			if (params['html-script'] == 'true' || sh.defaults['html-script'] == true) 
			{
				highlighter = new sh.HtmlScript(brushName);
				brushName = 'htmlscript';
			}
			else
			{
				var brush = findBrush(brushName);
				
				if (brush)
					highlighter = new brush();
				else
					continue;
			}
			
			code = target[propertyName];
			
			// remove CDATA from <SCRIPT/> tags if it's present
			if (conf.useScriptTags)
				code = stripCData(code);
				
			// Inject title if the attribute is present
			if ((target.title || '') != '')
				params.title = target.title;
				
			params['brush'] = brushName;
			highlighter.init(params);
			element = highlighter.getDiv(code);
			
			// carry over ID
			if ((target.id || '') != '')
				element.id = target.id;
			
			target.parentNode.replaceChild(element, target);
		}
	},

	/**
	 * Main entry point for the SyntaxHighlighter.
	 * @param {Object} params Optional params to apply to all highlighted elements.
	 */
	all: function(params)
	{
		attachEvent(
			window,
			'load',
			function() { sh.highlight(params); }
		);
	}
}; // end of sh

sh['all']			= sh.all;
sh['highlight']		= sh.highlight;

/**
 * Checks if target DOM elements has specified CSS class.
 * @param {DOMElement} target Target DOM element to check.
 * @param {String} className Name of the CSS class to check for.
 * @return {Boolean} Returns true if class name is present, false otherwise.
 */
function hasClass(target, className)
{
	return target.className.indexOf(className) != -1;
};

/**
 * Adds CSS class name to the target DOM element.
 * @param {DOMElement} target Target DOM element.
 * @param {String} className New CSS class to add.
 */
function addClass(target, className)
{
	if (!hasClass(target, className))
		target.className += ' ' + className;
};

/**
 * Removes CSS class name from the target DOM element.
 * @param {DOMElement} target Target DOM element.
 * @param {String} className CSS class to remove.
 */
function removeClass(target, className)
{
	target.className = target.className.replace(className, '');
};

/**
 * Converts the source to array object. Mostly used for function arguments and 
 * lists returned by getElementsByTagName() which aren't Array objects.
 * @param {List} source Source list.
 * @return {Array} Returns array.
 */
function toArray(source)
{
	var result = [];
	
	for (var i = 0; i < source.length; i++) 
		result.push(source[i]);
		
	return result;
};

/**
 * Splits block of text into lines.
 * @param {String} block Block of text.
 * @return {Array} Returns array of lines.
 */
function splitLines(block)
{
	return block.split('\n');
}

/**
 * Generates HTML ID for the highlighter.
 * @param {String} highlighterId Highlighter ID.
 * @return {String} Returns HTML ID.
 */
function getHighlighterId(id)
{
	var prefix = 'highlighter_';
	return id.indexOf(prefix) == 0 ? id : prefix + id;
};

/**
 * Finds Highlighter instance by ID.
 * @param {String} highlighterId Highlighter ID.
 * @return {Highlighter} Returns instance of the highlighter.
 */
function getHighlighterById(id)
{
	return sh.vars.highlighters[getHighlighterId(id)];
};

/**
 * Finds highlighter's DIV container.
 * @param {String} highlighterId Highlighter ID.
 * @return {Element} Returns highlighter's DIV element.
 */
function getHighlighterDivById(id)
{
	return document.getElementById(getHighlighterId(id));
};

/**
 * Stores highlighter so that getHighlighterById() can do its thing. Each
 * highlighter must call this method to preserve itself.
 * @param {Highilghter} highlighter Highlighter instance.
 */
function storeHighlighter(highlighter)
{
	sh.vars.highlighters[getHighlighterId(highlighter.id)] = highlighter;
};

/**
 * Looks for a child or parent node which has specified classname.
 * Equivalent to jQuery's $(container).find(".className")
 * @param {Element} target Target element.
 * @param {String} search Class name or node name to look for.
 * @param {Boolean} reverse If set to true, will go up the node tree instead of down.
 * @return {Element} Returns found child or parent element on null.
 */
function findElement(target, search, reverse /* optional */)
{
	if (target == null)
		return null;
		
	var nodes			= reverse != true ? target.childNodes : [ target.parentNode ],
		propertyToFind	= { '#' : 'id', '.' : 'className' }[search.substr(0, 1)] || 'nodeName',
		expectedValue,
		found
		;

	expectedValue = propertyToFind != 'nodeName'
		? search.substr(1)
		: search.toUpperCase()
		;
		
	// main return of the found node
	if ((target[propertyToFind] || '').indexOf(expectedValue) != -1)
		return target;
	
	for (var i = 0; nodes && i < nodes.length && found == null; i++)
		found = findElement(nodes[i], search, reverse);
	
	return found;
};

/**
 * Looks for a parent node which has specified classname.
 * This is an alias to <code>findElement(container, className, true)</code>.
 * @param {Element} target Target element.
 * @param {String} className Class name to look for.
 * @return {Element} Returns found parent element on null.
 */
function findParentElement(target, className)
{
	return findElement(target, className, true);
};

/**
 * Finds an index of element in the array.
 * @ignore
 * @param {Object} searchElement
 * @param {Number} fromIndex
 * @return {Number} Returns index of element if found; -1 otherwise.
 */
function indexOf(array, searchElement, fromIndex)
{
	fromIndex = Math.max(fromIndex || 0, 0);

	for (var i = fromIndex; i < array.length; i++)
		if(array[i] == searchElement)
			return i;
	
	return -1;
};

/**
 * Generates a unique element ID.
 */
function guid(prefix)
{
	return (prefix || '') + Math.round(Math.random() * 1000000).toString();
};

/**
 * Merges two objects. Values from obj2 override values in obj1.
 * Function is NOT recursive and works only for one dimensional objects.
 * @param {Object} obj1 First object.
 * @param {Object} obj2 Second object.
 * @return {Object} Returns combination of both objects.
 */
function merge(obj1, obj2)
{
	var result = {}, name;

	for (name in obj1) 
		result[name] = obj1[name];
	
	for (name in obj2) 
		result[name] = obj2[name];
		
	return result;
};

/**
 * Attempts to convert string to boolean.
 * @param {String} value Input string.
 * @return {Boolean} Returns true if input was "true", false if input was "false" and value otherwise.
 */
function toBoolean(value)
{
	var result = { "true" : true, "false" : false }[value];
	return result == null ? value : result;
};

/**
 * Opens up a centered popup window.
 * @param {String} url		URL to open in the window.
 * @param {String} name		Popup name.
 * @param {int} width		Popup width.
 * @param {int} height		Popup height.
 * @param {String} options	window.open() options.
 * @return {Window}			Returns window instance.
 */
function popup(url, name, width, height, options)
{
	var x = (screen.width - width) / 2,
		y = (screen.height - height) / 2
		;
		
	options +=	', left=' + x + 
				', top=' + y +
				', width=' + width +
				', height=' + height
		;
	options = options.replace(/^,/, '');

	var win = window.open(url, name, options);
	win.focus();
	return win;
};

/**
 * Adds event handler to the target object.
 * @param {Object} obj		Target object.
 * @param {String} type		Name of the event.
 * @param {Function} func	Handling function.
 */
function attachEvent(obj, type, func, scope)
{
	function handler(e)
	{
		e = e || window.event;
		
		if (!e.target)
		{
			e.target = e.srcElement;
			e.preventDefault = function()
			{
				this.returnValue = false;
			};
		}
			
		func.call(scope || window, e);
	};
	
	if (obj.attachEvent) 
	{
		obj.attachEvent('on' + type, handler);
	}
	else 
	{
		obj.addEventListener(type, handler, false);
	}
};

/**
 * Displays an alert.
 * @param {String} str String to display.
 */
function alert(str)
{
	window.alert(sh.config.strings.alert + str);
};

/**
 * Finds a brush by its alias.
 *
 * @param {String} alias		Brush alias.
 * @param {Boolean} showAlert	Suppresses the alert if false.
 * @return {Brush}				Returns bursh constructor if found, null otherwise.
 */
function findBrush(alias, showAlert)
{
	var brushes = sh.vars.discoveredBrushes,
		result = null
		;
	
	if (brushes == null) 
	{
		brushes = {};
		
		// Find all brushes
		for (var brush in sh.brushes) 
		{
			var info = sh.brushes[brush],
				aliases = info.aliases
				;
			
			if (aliases == null) 
				continue;
			
			// keep the brush name
			info.brushName = brush.toLowerCase();
			
			for (var i = 0; i < aliases.length; i++) 
				brushes[aliases[i]] = brush;
		}
		
		sh.vars.discoveredBrushes = brushes;
	}
	
	result = sh.brushes[brushes[alias]];

	if (result == null && showAlert != false)
		alert(sh.config.strings.noBrush + alias);
	
	return result;
};

/**
 * Executes a callback on each line and replaces each line with result from the callback.
 * @param {Object} str			Input string.
 * @param {Object} callback		Callback function taking one string argument and returning a string.
 */
function eachLine(str, callback)
{
	var lines = splitLines(str);
	
	for (var i = 0; i < lines.length; i++)
		lines[i] = callback(lines[i], i);
		
	return lines.join('\n');
};

/**
 * This is a special trim which only removes first and last empty lines
 * and doesn't affect valid leading space on the first line.
 * 
 * @param {String} str   Input string
 * @return {String}      Returns string without empty first and last lines.
 */
function trimFirstAndLastLines(str)
{
	return str.replace(/^[ ]*[\n]+|[\n]*[ ]*$/g, '');
};

/**
 * Parses key/value pairs into hash object.
 * 
 * Understands the following formats:
 * - name: word;
 * - name: [word, word];
 * - name: "string";
 * - name: 'string';
 * 
 * For example:
 *   name1: value; name2: [value, value]; name3: 'value'
 *   
 * @param {String} str    Input string.
 * @return {Object}       Returns deserialized object.
 */
function parseParams(str)
{
	var match, 
		result = {},
		arrayRegex = new XRegExp("^\\[(?<values>(.*?))\\]$"),
		regex = new XRegExp(
			"(?<name>[\\w-]+)" +
			"\\s*:\\s*" +
			"(?<value>" +
				"[\\w-%#]+|" +		// word
				"\\[.*?\\]|" +		// [] array
				'".*?"|' +			// "" string
				"'.*?'" +			// '' string
			")\\s*;?",
			"g"
		)
		;

	while ((match = regex.exec(str)) != null) 
	{
		var value = match.value
			.replace(/^['"]|['"]$/g, '') // strip quotes from end of strings
			;
		
		// try to parse array value
		if (value != null && arrayRegex.test(value))
		{
			var m = arrayRegex.exec(value);
			value = m.values.length > 0 ? m.values.split(/\s*,\s*/) : [];
		}
		
		result[match.name] = value;
	}
	
	return result;
};

/**
 * Wraps each line of the string into <code/> tag with given style applied to it.
 * 
 * @param {String} str   Input string.
 * @param {String} css   Style name to apply to the string.
 * @return {String}      Returns input string with each line surrounded by <span/> tag.
 */
function wrapLinesWithCode(str, css)
{
	if (str == null || str.length == 0 || str == '\n') 
		return str;

	str = str.replace(/</g, '&lt;');

	// Replace two or more sequential spaces with &nbsp; leaving last space untouched.
	str = str.replace(/ {2,}/g, function(m)
	{
		var spaces = '';
		
		for (var i = 0; i < m.length - 1; i++)
			spaces += sh.config.space;
		
		return spaces + ' ';
	});

	// Split each line and apply <span class="...">...</span> to them so that
	// leading spaces aren't included.
	if (css != null) 
		str = eachLine(str, function(line)
		{
			if (line.length == 0) 
				return '';
			
			var spaces = '';
			
			line = line.replace(/^(&nbsp;| )+/, function(s)
			{
				spaces = s;
				return '';
			});
			
			if (line.length == 0) 
				return spaces;
			
			return spaces + '<code class="' + css + '">' + line + '</code>';
		});

	return str;
};

/**
 * Pads number with zeros until it's length is the same as given length.
 * 
 * @param {Number} number	Number to pad.
 * @param {Number} length	Max string length with.
 * @return {String}			Returns a string padded with proper amount of '0'.
 */
function padNumber(number, length)
{
	var result = number.toString();
	
	while (result.length < length)
		result = '0' + result;
	
	return result;
};

/**
 * Replaces tabs with spaces.
 * 
 * @param {String} code		Source code.
 * @param {Number} tabSize	Size of the tab.
 * @return {String}			Returns code with all tabs replaces by spaces.
 */
function processTabs(code, tabSize)
{
	var tab = '';
	
	for (var i = 0; i < tabSize; i++)
		tab += ' ';

	return code.replace(/\t/g, tab);
};

/**
 * Replaces tabs with smart spaces.
 * 
 * @param {String} code    Code to fix the tabs in.
 * @param {Number} tabSize Number of spaces in a column.
 * @return {String}        Returns code with all tabs replaces with roper amount of spaces.
 */
function processSmartTabs(code, tabSize)
{
	var lines = splitLines(code),
		tab = '\t',
		spaces = ''
		;
	
	// Create a string with 1000 spaces to copy spaces from... 
	// It's assumed that there would be no indentation longer than that.
	for (var i = 0; i < 50; i++) 
		spaces += '                    '; // 20 spaces * 50
			
	// This function inserts specified amount of spaces in the string
	// where a tab is while removing that given tab.
	function insertSpaces(line, pos, count)
	{
		return line.substr(0, pos)
			+ spaces.substr(0, count)
			+ line.substr(pos + 1, line.length) // pos + 1 will get rid of the tab
			;
	};

	// Go through all the lines and do the 'smart tabs' magic.
	code = eachLine(code, function(line)
	{
		if (line.indexOf(tab) == -1) 
			return line;
		
		var pos = 0;
		
		while ((pos = line.indexOf(tab)) != -1) 
		{
			// This is pretty much all there is to the 'smart tabs' logic.
			// Based on the position within the line and size of a tab,
			// calculate the amount of spaces we need to insert.
			var spaces = tabSize - pos % tabSize;
			line = insertSpaces(line, pos, spaces);
		}
		
		return line;
	});
	
	return code;
};

/**
 * Performs various string fixes based on configuration.
 */
function fixInputString(str)
{
	var br = /<br\s*\/?>|&lt;br\s*\/?&gt;/gi;
	
	if (sh.config.bloggerMode == true)
		str = str.replace(br, '\n');

	if (sh.config.stripBrs == true)
		str = str.replace(br, '');
		
	return str;
};

/**
 * Removes all white space at the begining and end of a string.
 * 
 * @param {String} str   String to trim.
 * @return {String}      Returns string without leading and following white space characters.
 */
function trim(str)
{
	return str.replace(/^\s+|\s+$/g, '');
};

/**
 * Unindents a block of text by the lowest common indent amount.
 * @param {String} str   Text to unindent.
 * @return {String}      Returns unindented text block.
 */
function unindent(str)
{
	var lines = splitLines(fixInputString(str)),
		indents = new Array(),
		regex = /^\s*/,
		min = 1000
		;
	
	// go through every line and check for common number of indents
	for (var i = 0; i < lines.length && min > 0; i++) 
	{
		var line = lines[i];
		
		if (trim(line).length == 0) 
			continue;
		
		var matches = regex.exec(line);
		
		// In the event that just one line doesn't have leading white space
		// we can't unindent anything, so bail completely.
		if (matches == null) 
			return str;
			
		min = Math.min(matches[0].length, min);
	}
	
	// trim minimum common number of white space from the begining of every line
	if (min > 0) 
		for (var i = 0; i < lines.length; i++) 
			lines[i] = lines[i].substr(min);
	
	return lines.join('\n');
};

/**
 * Callback method for Array.sort() which sorts matches by
 * index position and then by length.
 * 
 * @param {Match} m1	Left object.
 * @param {Match} m2    Right object.
 * @return {Number}     Returns -1, 0 or -1 as a comparison result.
 */
function matchesSortCallback(m1, m2)
{
	// sort matches by index first
	if(m1.index < m2.index)
		return -1;
	else if(m1.index > m2.index)
		return 1;
	else
	{
		// if index is the same, sort by length
		if(m1.length < m2.length)
			return -1;
		else if(m1.length > m2.length)
			return 1;
	}
	
	return 0;
};

/**
 * Executes given regular expression on provided code and returns all
 * matches that are found.
 * 
 * @param {String} code    Code to execute regular expression on.
 * @param {Object} regex   Regular expression item info from <code>regexList</code> collection.
 * @return {Array}         Returns a list of Match objects.
 */ 
function getMatches(code, regexInfo)
{
	function defaultAdd(match, regexInfo)
	{
		return match[0];
	};
	
	var index = 0,
		match = null,
		matches = [],
		func = regexInfo.func ? regexInfo.func : defaultAdd
		;
	
	while((match = regexInfo.regex.exec(code)) != null)
	{
		var resultMatch = func(match, regexInfo);
		
		if (typeof(resultMatch) == 'string')
			resultMatch = [new sh.Match(resultMatch, match.index, regexInfo.css)];

		matches = matches.concat(resultMatch);
	}
	
	return matches;
};

/**
 * Turns all URLs in the code into <a/> tags.
 * @param {String} code Input code.
 * @return {String} Returns code with </a> tags.
 */
function processUrls(code)
{
	var gt = /(.*)((&gt;|&lt;).*)/;
	
	return code.replace(sh.regexLib.url, function(m)
	{
		var suffix = '',
			match = null
			;
		
		// We include &lt; and &gt; in the URL for the common cases like <http://google.com>
		// The problem is that they get transformed into &lt;http://google.com&gt;
		// Where as &gt; easily looks like part of the URL string.
	
		if (match = gt.exec(m))
		{
			m = match[1];
			suffix = match[2];
		}
		
		return '<a href="' + m + '">' + m + '</a>' + suffix;
	});
};

/**
 * Finds all <SCRIPT TYPE="syntaxhighlighter" /> elementss.
 * @return {Array} Returns array of all found SyntaxHighlighter tags.
 */
function getSyntaxHighlighterScriptTags()
{
	var tags = document.getElementsByTagName('script'),
		result = []
		;
	
	for (var i = 0; i < tags.length; i++)
		if (tags[i].type == 'syntaxhighlighter')
			result.push(tags[i]);
			
	return result;
};

/**
 * Strips <![CDATA[]]> from <SCRIPT /> content because it should be used
 * there in most cases for XHTML compliance.
 * @param {String} original	Input code.
 * @return {String} Returns code without leading <![CDATA[]]> tags.
 */
function stripCData(original)
{
	var left = '<![CDATA[',
		right = ']]>',
		// for some reason IE inserts some leading blanks here
		copy = trim(original),
		changed = false,
		leftLength = left.length,
		rightLength = right.length
		;
	
	if (copy.indexOf(left) == 0)
	{
		copy = copy.substring(leftLength);
		changed = true;
	}
	
	var copyLength = copy.length;
	
	if (copy.indexOf(right) == copyLength - rightLength)
	{
		copy = copy.substring(0, copyLength - rightLength);
		changed = true;
	}
	
	return changed ? copy : original;
};


/**
 * Quick code mouse double click handler.
 */
function quickCodeHandler(e)
{
	var target = e.target,
		highlighterDiv = findParentElement(target, '.syntaxhighlighter'),
		container = findParentElement(target, '.container'),
		textarea = document.createElement('textarea'),
		highlighter
		;

	if (!container || !highlighterDiv || findElement(container, 'textarea'))
		return;

	highlighter = getHighlighterById(highlighterDiv.id);
	
	// add source class name
	addClass(highlighterDiv, 'source');

	// Have to go over each line and grab it's text, can't just do it on the
	// container because Firefox loses all \n where as Webkit doesn't.
	var lines = container.childNodes,
		code = []
		;
	
	for (var i = 0; i < lines.length; i++)
		code.push(lines[i].innerText || lines[i].textContent);
	
	// using \r instead of \r or \r\n makes this work equally well on IE, FF and Webkit
	code = code.join('\r');
	
	// inject <textarea/> tag
	textarea.appendChild(document.createTextNode(code));
	container.appendChild(textarea);
	
	// preselect all text
	textarea.focus();
	textarea.select();
	
	// set up handler for lost focus
	attachEvent(textarea, 'blur', function(e)
	{
		textarea.parentNode.removeChild(textarea);
		removeClass(highlighterDiv, 'source');
	});
};

/**
 * Match object.
 */
sh.Match = function(value, index, css)
{
	this.value = value;
	this.index = index;
	this.length = value.length;
	this.css = css;
	this.brushName = null;
};

sh.Match.prototype.toString = function()
{
	return this.value;
};

/**
 * Simulates HTML code with a scripting language embedded.
 * 
 * @param {String} scriptBrushName Brush name of the scripting language.
 */
sh.HtmlScript = function(scriptBrushName)
{
	var brushClass = findBrush(scriptBrushName),
		scriptBrush,
		xmlBrush = new sh.brushes.Xml(),
		bracketsRegex = null,
		ref = this,
		methodsToExpose = 'getDiv getHtml init'.split(' ')
		;

	if (brushClass == null)
		return;
	
	scriptBrush = new brushClass();
	
	for(var i = 0; i < methodsToExpose.length; i++)
		// make a closure so we don't lose the name after i changes
		(function() {
			var name = methodsToExpose[i];
			
			ref[name] = function()
			{
				return xmlBrush[name].apply(xmlBrush, arguments);
			};
		})();
	
	if (scriptBrush.htmlScript == null)
	{
		alert(sh.config.strings.brushNotHtmlScript + scriptBrushName);
		return;
	}
	
	xmlBrush.regexList.push(
		{ regex: scriptBrush.htmlScript.code, func: process }
	);
	
	function offsetMatches(matches, offset)
	{
		for (var j = 0; j < matches.length; j++) 
			matches[j].index += offset;
	}
	
	function process(match, info)
	{
		var code = match.code,
			matches = [],
			regexList = scriptBrush.regexList,
			offset = match.index + match.left.length,
			htmlScript = scriptBrush.htmlScript,
			result
			;

		// add all matches from the code
		for (var i = 0; i < regexList.length; i++)
		{
			result = getMatches(code, regexList[i]);
			offsetMatches(result, offset);
			matches = matches.concat(result);
		}
		
		// add left script bracket
		if (htmlScript.left != null && match.left != null)
		{
			result = getMatches(match.left, htmlScript.left);
			offsetMatches(result, match.index);
			matches = matches.concat(result);
		}
		
		// add right script bracket
		if (htmlScript.right != null && match.right != null)
		{
			result = getMatches(match.right, htmlScript.right);
			offsetMatches(result, match.index + match[0].lastIndexOf(match.right));
			matches = matches.concat(result);
		}
		
		for (var j = 0; j < matches.length; j++)
			matches[j].brushName = brushClass.brushName;
			
		return matches;
	}
};

/**
 * Main Highlither class.
 * @constructor
 */
sh.Highlighter = function()
{
	// not putting any code in here because of the prototype inheritance
};

sh.Highlighter.prototype = {
	/**
	 * Returns value of the parameter passed to the highlighter.
	 * @param {String} name				Name of the parameter.
	 * @param {Object} defaultValue		Default value.
	 * @return {Object}					Returns found value or default value otherwise.
	 */
	getParam: function(name, defaultValue)
	{
		var result = this.params[name];
		return toBoolean(result == null ? defaultValue : result);
	},
	
	/**
	 * Shortcut to document.createElement().
	 * @param {String} name		Name of the element to create (DIV, A, etc).
	 * @return {HTMLElement}	Returns new HTML element.
	 */
	create: function(name)
	{
		return document.createElement(name);
	},
	
	/**
	 * Applies all regular expression to the code and stores all found
	 * matches in the `this.matches` array.
	 * @param {Array} regexList		List of regular expressions.
	 * @param {String} code			Source code.
	 * @return {Array}				Returns list of matches.
	 */
	findMatches: function(regexList, code)
	{
		var result = [];
		
		if (regexList != null)
			for (var i = 0; i < regexList.length; i++) 
				// BUG: length returns len+1 for array if methods added to prototype chain (oising@gmail.com)
				if (typeof (regexList[i]) == "object")
					result = result.concat(getMatches(code, regexList[i]));
		
		// sort and remove nested the matches
		return this.removeNestedMatches(result.sort(matchesSortCallback));
	},
	
	/**
	 * Checks to see if any of the matches are inside of other matches. 
	 * This process would get rid of highligted strings inside comments, 
	 * keywords inside strings and so on.
	 */
	removeNestedMatches: function(matches)
	{
		// Optimized by Jose Prado (http://joseprado.com)
		for (var i = 0; i < matches.length; i++) 
		{ 
			if (matches[i] === null)
				continue;
			
			var itemI = matches[i],
				itemIEndPos = itemI.index + itemI.length
				;
			
			for (var j = i + 1; j < matches.length && matches[i] !== null; j++) 
			{
				var itemJ = matches[j];
				
				if (itemJ === null) 
					continue;
				else if (itemJ.index > itemIEndPos) 
					break;
				else if (itemJ.index == itemI.index && itemJ.length > itemI.length)
					matches[i] = null;
				else if (itemJ.index >= itemI.index && itemJ.index < itemIEndPos) 
					matches[j] = null;
			}
		}
		
		return matches;
	},
	
	/**
	 * Creates an array containing integer line numbers starting from the 'first-line' param.
	 * @return {Array} Returns array of integers.
	 */
	figureOutLineNumbers: function(code)
	{
		var lines = [],
			firstLine = parseInt(this.getParam('first-line'))
			;
		
		eachLine(code, function(line, index)
		{
			lines.push(index + firstLine);
		});
		
		return lines;
	},
	
	/**
	 * Determines if specified line number is in the highlighted list.
	 */
	isLineHighlighted: function(lineNumber)
	{
		var list = this.getParam('highlight', []);
		
		if (typeof(list) != 'object' && list.push == null) 
			list = [ list ];
		
		return indexOf(list, lineNumber.toString()) != -1;
	},
	
	/**
	 * Generates HTML markup for a single line of code while determining alternating line style.
	 * @param {Integer} lineNumber	Line number.
	 * @param {String} code Line	HTML markup.
	 * @return {String}				Returns HTML markup.
	 */
	getLineHtml: function(lineIndex, lineNumber, code)
	{
		var classes = [
			'line',
			'number' + lineNumber,
			'index' + lineIndex,
			'alt' + (lineNumber % 2 == 0 ? 1 : 2).toString()
		];
		
		if (this.isLineHighlighted(lineNumber))
		 	classes.push('highlighted');
		
		if (lineNumber == 0)
			classes.push('break');
			
		return '<div class="' + classes.join(' ') + '">' + code + '</div>';
	},
	
	/**
	 * Generates HTML markup for line number column.
	 * @param {String} code			Complete code HTML markup.
	 * @param {Array} lineNumbers	Calculated line numbers.
	 * @return {String}				Returns HTML markup.
	 */
	getLineNumbersHtml: function(code, lineNumbers)
	{
		var html = '',
			count = splitLines(code).length,
			firstLine = parseInt(this.getParam('first-line')),
			pad = this.getParam('pad-line-numbers')
			;
		
		if (pad == true)
			pad = (firstLine + count - 1).toString().length;
		else if (isNaN(pad) == true)
			pad = 0;
			
		for (var i = 0; i < count; i++)
		{
			var lineNumber = lineNumbers ? lineNumbers[i] : firstLine + i,
				code = lineNumber == 0 ? sh.config.space : padNumber(lineNumber, pad)
				;
				
			html += this.getLineHtml(i, lineNumber, code);
		}
		
		return html;
	},
	
	/**
	 * Splits block of text into individual DIV lines.
	 * @param {String} code			Code to highlight.
	 * @param {Array} lineNumbers	Calculated line numbers.
	 * @return {String}				Returns highlighted code in HTML form.
	 */
	getCodeLinesHtml: function(html, lineNumbers)
	{
		html = trim(html);
		
		var lines = splitLines(html),
			padLength = this.getParam('pad-line-numbers'),
			firstLine = parseInt(this.getParam('first-line')),
			html = '',
			brushName = this.getParam('brush')
			;

		for (var i = 0; i < lines.length; i++)
		{
			var line = lines[i],
				indent = /^(&nbsp;|\s)+/.exec(line),
				spaces = null,
				lineNumber = lineNumbers ? lineNumbers[i] : firstLine + i;
				;

			if (indent != null)
			{
				spaces = indent[0].toString();
				line = line.substr(spaces.length);
				spaces = spaces.replace(' ', sh.config.space);
			}

			line = trim(line);
			
			if (line.length == 0)
				line = sh.config.space;
			
			html += this.getLineHtml(
				i,
				lineNumber, 
				(spaces != null ? '<code class="' + brushName + ' spaces">' + spaces + '</code>' : '') + line
			);
		}
		
		return html;
	},
	
	/**
	 * Returns HTML for the table title or empty string if title is null.
	 */
	getTitleHtml: function(title)
	{
		return title ? '<caption>' + title + '</caption>' : '';
	},
	
	/**
	 * Finds all matches in the source code.
	 * @param {String} code		Source code to process matches in.
	 * @param {Array} matches	Discovered regex matches.
	 * @return {String} Returns formatted HTML with processed mathes.
	 */
	getMatchesHtml: function(code, matches)
	{
		var pos = 0, 
			result = '',
			brushName = this.getParam('brush', '')
			;
		
		function getBrushNameCss(match)
		{
			var result = match ? (match.brushName || brushName) : brushName;
			return result ? result + ' ' : '';
		};
		
		// Finally, go through the final list of matches and pull the all
		// together adding everything in between that isn't a match.
		for (var i = 0; i < matches.length; i++) 
		{
			var match = matches[i],
				matchBrushName
				;
			
			if (match === null || match.length === 0) 
				continue;
			
			matchBrushName = getBrushNameCss(match);
			
			result += wrapLinesWithCode(code.substr(pos, match.index - pos), matchBrushName + 'plain')
					+ wrapLinesWithCode(match.value, matchBrushName + match.css)
					;

			pos = match.index + match.length + (match.offset || 0);
		}

		// don't forget to add whatever's remaining in the string
		result += wrapLinesWithCode(code.substr(pos), getBrushNameCss() + 'plain');

		return result;
	},
	
	/**
	 * Generates HTML markup for the whole syntax highlighter.
	 * @param {String} code Source code.
	 * @return {String} Returns HTML markup.
	 */
	getHtml: function(code)
	{
		var html = '',
			classes = [ 'syntaxhighlighter' ],
			tabSize,
			matches,
			lineNumbers
			;
		
		// process light mode
		if (this.getParam('light') == true)
			this.params.toolbar = this.params.gutter = false;

		className = 'syntaxhighlighter';

		if (this.getParam('collapse') == true)
			classes.push('collapsed');
		
		if ((gutter = this.getParam('gutter')) == false)
			classes.push('nogutter');

		// add custom user style name
		classes.push(this.getParam('class-name'));

		// add brush alias to the class name for custom CSS
		classes.push(this.getParam('brush'));

		code = trimFirstAndLastLines(code)
			.replace(/\r/g, ' ') // IE lets these buggers through
			;

		tabSize = this.getParam('tab-size');

		// replace tabs with spaces
		code = this.getParam('smart-tabs') == true
			? processSmartTabs(code, tabSize)
			: processTabs(code, tabSize)
			;

		// unindent code by the common indentation
		code = unindent(code);

		if (gutter)
			lineNumbers = this.figureOutLineNumbers(code);
		
		// find matches in the code using brushes regex list
		matches = this.findMatches(this.regexList, code);
		// processes found matches into the html
		html = this.getMatchesHtml(code, matches);
		// finally, split all lines so that they wrap well
		html = this.getCodeLinesHtml(html, lineNumbers);

		// finally, process the links
		if (this.getParam('auto-links'))
			html = processUrls(html);
		
		if (typeof(navigator) != 'undefined' && navigator.userAgent && navigator.userAgent.match(/MSIE/))
			classes.push('ie');
		
		html = 
			'<div id="' + getHighlighterId(this.id) + '" class="' + classes.join(' ') + '">'
				+ (this.getParam('toolbar') ? sh.toolbar.getHtml(this) : '')
				+ '<table border="0" cellpadding="0" cellspacing="0">'
					+ this.getTitleHtml(this.getParam('title'))
					+ '<tbody>'
						+ '<tr>'
							+ (gutter ? '<td class="gutter">' + this.getLineNumbersHtml(code) + '</td>' : '')
							+ '<td class="code">'
								+ '<div class="container">'
									+ html
								+ '</div>'
							+ '</td>'
						+ '</tr>'
					+ '</tbody>'
				+ '</table>'
			+ '</div>'
			;
			
		return html;
	},
	
	/**
	 * Highlights the code and returns complete HTML.
	 * @param {String} code     Code to highlight.
	 * @return {Element}        Returns container DIV element with all markup.
	 */
	getDiv: function(code)
	{
		if (code === null) 
			code = '';
		
		this.code = code;

		var div = this.create('div');

		// create main HTML
		div.innerHTML = this.getHtml(code);
		
		// set up click handlers
		if (this.getParam('toolbar'))
			attachEvent(findElement(div, '.toolbar'), 'click', sh.toolbar.handler);
		
		if (this.getParam('quick-code'))
			attachEvent(findElement(div, '.code'), 'dblclick', quickCodeHandler);
		
		return div;
	},
	
	/**
	 * Initializes the highlighter/brush.
	 *
	 * Constructor isn't used for initialization so that nothing executes during necessary
	 * `new SyntaxHighlighter.Highlighter()` call when setting up brush inheritence.
	 *
	 * @param {Hash} params Highlighter parameters.
	 */
	init: function(params)
	{
		this.id = guid();
		
		// register this instance in the highlighters list
		storeHighlighter(this);
		
		// local params take precedence over defaults
		this.params = merge(sh.defaults, params || {})
		
		// process light mode
		if (this.getParam('light') == true)
			this.params.toolbar = this.params.gutter = false;
	},
	
	/**
	 * Converts space separated list of keywords into a regular expression string.
	 * @param {String} str    Space separated keywords.
	 * @return {String}       Returns regular expression string.
	 */
	getKeywords: function(str)
	{
		str = str
			.replace(/^\s+|\s+$/g, '')
			.replace(/\s+/g, '|')
			;
		
		return '\\b(?:' + str + ')\\b';
	},
	
	/**
	 * Makes a brush compatible with the `html-script` functionality.
	 * @param {Object} regexGroup Object containing `left` and `right` regular expressions.
	 */
	forHtmlScript: function(regexGroup)
	{
		this.htmlScript = {
			left : { regex: regexGroup.left, css: 'script' },
			right : { regex: regexGroup.right, css: 'script' },
			code : new XRegExp(
				"(?<left>" + regexGroup.left.source + ")" +
				"(?<code>.*?)" +
				"(?<right>" + regexGroup.right.source + ")",
				"sgi"
				)
		};
	}
}; // end of Highlighter

return sh;
}(); // end of anonymous function

// CommonJS
typeof(exports) != 'undefined' ? exports['SyntaxHighlighter'] = SyntaxHighlighter : null;
</script><script type="text/javascript">// (inc clojure-brush) ;; an improved SyntaxHighlighter brush for clojure
//
// Copyright (C) 2011 Andrew Brehaut
//
// Distributed under the Eclipse Public License, the same as Clojure.
//
// https://github.com/brehaut/inc-clojure-brush
//
// Written by Andrew Brehaut
// V0.9.1, November 2011

if (typeof net == "undefined") net = {};
if (!(net.brehaut)) net.brehaut = {};

net.brehaut.ClojureTools = (function (SH) {
  "use strict";
  // utiliies
  if (!Object.create) Object.create = function object(o) {
    function F() {};
    F.prototype = o;  
    return new F();
  };
        
  // data
  
  function Token(value, index, tag, length) {
    this.value = value;
    this.index = index;
    this.length = length || value.length;
    this.tag = tag;
    this.secondary_tags = {};
  }
  
  // null_token exists so that LispNodes that have not had a closing tag attached
  // can have a dummy token to simplify annotation
  var null_token = new Token("", -1, "null", -1);
  
  /* LispNodes are aggregate nodes for sexpressions. 
   *
   */
  function LispNode(tag, children, opening) {
    this.tag = tag;            // current metadata for syntax inference
    this.parent = null;        // the parent expression
    this.list = children;      // all the child forms in order
    this.opening = opening;    // the token that opens this form.
    this.closing = null_token; // the token that closes this form.
    this.meta = null;          // metadata nodes will be attached here if they are found
  }

  var null_lispnode = new LispNode("null", [], null_token);

  
  function PrefixNode(tag, token, attached_node) {
    this.tag = tag;
    this.token = token;
    this.attached_node = attached_node;
    this.parent = null;
  }

  
  
  // tokenize

  function tokenize(code) {
    var tokens = [];
    var tn = 0;
    
    var zero = "0".charCodeAt(0);
    var nine = "9".charCodeAt(0); 
    var lower_a = "a".charCodeAt(0);
    var lower_f = "f".charCodeAt(0);    
    var upper_a = "A".charCodeAt(0);
    var upper_f = "F".charCodeAt(0);
    
    var dispatch = false; // have we just seen a # character?
    
    // i tracks the start of the current window
    // extent is the window for slicing
    
    for (var i = 0, 
             extent = i, 
             j = code.length; 
             i < j && extent <= j;) {          
                
      var c = code[i];
      
      // we care about capturing the whole token when dispatch is used, so back up the
      // starting index by 1
      if (dispatch) i--; 
      
      switch (c) {
        // dispatch alters the value of the next thing read
        case "#":
          dispatch = true;
          i++;
          extent++;
          continue;
          
        case " ":    // ignore whitespace
        case "\t":
        case "\n":
        case "\r":
        case ",":   
          extent++
          break; 
          
        // simple terms
        case "^":
        case "`":
        case ")":
        case "[":
        case "]":
        case "}":
        case "@":
          tokens[tn++] = new Token(c, i, c, ++extent - i);
          break;
        
        case "'":
          tokens[tn++] = new Token(code.slice(i, ++extent), i, dispatch ? "#'" : "'", extent - i);
          break
        
        case "(":
          tokens[tn++] = new Token(code.slice(i, ++extent), i, "(", extent - i);
          break;          
          
        case "{":
          tokens[tn++] = new Token(code.slice(i, ++extent), i, dispatch ? "#{" : "{", extent - i);
          break;  
        
        case "\\":
          if (code.slice(i + 1, i + 8) === "newline") {
            tokens[tn++] = new Token("\\newline", i, "value", 8);
            extent = i + 9; 
          }
          else if (code.slice(i + 1, i + 6) === "space") {
            tokens[tn++] = new Token("\\space", i, "value", 6);
            extent = i + 6;
          }
          else if (code.slice(i + 1, i + 4) === "tab") {
            tokens[tn++] = new Token("\\tab", i, "value", 4);
            extent = i + 5;
          } // work around fun bug with &,>,< in character literals
          else if (code.slice(i + 1, i + 6) === "&amp;") {
            tokens[tn++] = new Token("\\&amp;", i, "value", 6);
            extent = i + 6; 
          }
          else if (code.slice(i + 1, i + 5) === "&lt;") {
            tokens[tn++] = new Token("\\&lt;", i, "value", 5);
            extent = i + 5;
          }
          else if (code.slice(i + 1, i + 5) === "&gt;") {
            tokens[tn++] = new Token("\\&gt;", i, "value", 5);
            extent = i + 5;
          }
          
          else {
            extent += 2;
            tokens[tn++] = new Token(code.slice(i, extent), i, "value", 2);
          }
          break;
        
        case "~": // slice
          if (code[i + 1] === "@") {
            extent += 2;
            tokens[tn++] = new Token(code.slice(i, extent), i, "splice", 2);
          }
          else {
            tokens[tn++] = new Token(code.slice(i, ++extent), i, "unquote", 2);
          }
          break;
        
        // complicated terms
        case "\"": // strings and regexps
          for (extent++; extent <= j; extent++) {
            if (code[extent] === "\\") extent++;
            else if (code[extent] === "\"") break;
          }
          tokens[tn++] = new Token(code.slice(i, ++extent), i, dispatch ? "regexp" : "string", extent - i);       
          break;
          
        case ";":
          for (; extent <= j && code[extent] !== "\n" && code[extent] !== "\r"; extent++);
          tokens[tn++] = new Token(code.slice(i, ++extent), i, "comments", extent - i);   
          break;
        
        case "+": // numbers; fall through to symbol for + and - not prefixing a number
        case "-":
        case "0":
        case "1":
        case "2":
        case "3":
        case "4":
        case "5":
        case "6":
        case "7":
        case "8":
        case "9":
        // todo: exponents, hex
        // http://my.safaribooksonline.com/9781449310387/14?reader=pf&readerfullscreen=&readerleftmenu=1
          var c2 = code.charCodeAt(i + 1);
          if (((c === "+" || c === "-") && (c2 >= zero && c2 <= nine)) // prefixes
              || (c !== "+" && c !== "-")) {
            if (c === "+" || c === "-") extent++; 
            for (; extent <= j; extent++) {
              var charCode = code.charCodeAt(extent);
              if (charCode < zero || charCode > nine) break;
            }
            
            c = code[extent];
            c2 = code.charCodeAt(extent + 1);
            if ((c === "r" || c === "R" || c === "/" || c === ".") // interstitial characters
                && (c2 >= zero && c2 <= nine)) {
              for (extent++; extent <= j; extent++) {
                var charCode = code.charCodeAt(extent);
                if (charCode < zero || charCode > nine) break;
              }
            }
            
            c = code[extent];
            c2 = code.charCodeAt(extent + 1);
            if ((c === "x" || c === "X") && 
                ((c2 >= zero && c2 <= nine) 
                 || (c2 >= lower_a && c2 <= lower_f)
                 || (c2 >= upper_a && c2 <= upper_f))) {
              for (extent++; extent <= j; extent++) {
                var charCode = code.charCodeAt(extent);
                if (((charCode >= zero && charCode <= nine) 
                    || (charCode >= lower_a && charCode <= lower_f)
                    || (charCode >= upper_a && charCode <= upper_f))) continue;
                break;
              }
            }
            
            c = code[extent];
            c2 = code.charCodeAt(extent + 1);
            if ((c === "e" || c === "E") 
                && (c2 >= zero && c2 <= nine)) {
              for (extent++; extent <= j; extent++) {
                var charCode = code.charCodeAt(extent);
                if (charCode < zero || charCode > nine) break;
              }
            }
            
            c = code[extent];
            if (c === "N" || c === "M") extent++;

            tokens[tn++] = new Token(code.slice(i, extent), i, "value", extent - i);
            break;
          }

        case "_":
          if (dispatch && c === "_") {
            tokens[tn++] = new Token(code.slice(i, ++extent), i, "skip", extent - i);
            break;
          } // if not a skip, fall through to symbols
        
        // Allow just about any other symbol as a symbol. This is far more permissive than 
        // clojure actually allows, but should catch any weirdo crap that accidentally gets
        // into the code.
        default: 
          for (extent++; extent <= j; extent++) {
            switch (code[extent]) {
              case " ":
              case "\t":
              case "\n":
              case "\r":
              case "\\":
              case ",":
              case "{":
              case "}":
              case "(":
              case ")":
              case "[":
              case "]":
              case "^":
              case "`":
              case "@":   
                break;
              case ";":   
                // theres a weird bug via syntax highligher that gives us escaped entities.
                // need to watch out for these
                if (code.slice(extent-3, extent+1) === "&lt;"
                    ||code.slice(extent-3, extent+1) === "&gt;"
                    ||code.slice(extent-4, extent+1) === "&amp;") {
                  continue;
                }
                break;
              default:
                continue;
            }
            break;
          }
          
          var value = code.slice(i, extent);
          var tag = "symbol";
          if (value[0] == ":") {
            tag = "keyword";
          }
          else if (value === "true" || value === "false" || value === "nil") {
            tag = "value";
          }
          tokens[tn++] = new Token(value, i, tag, extent - i);
      }
      
      dispatch = false;
      i = extent;
    } 

    return tokens;
  }


  function build_tree(tokens) {
    var toplevel = {
      list: [], 
      tag: "toplevel", 
      parent: null, 
      opening: null,
      closing: null,
      depth: -1
    };
    
    // loop variables hoisted out as semi globals to track position in token stream
    var i = -1;
    var j = tokens.length;
    
    function parse_one(t) {
      // ignore special tokens and forms that dont belong in the tree
      for (; t && (t.tag === "comments" || t.tag === "invalid" || t.tag == "skip") && i < j; ) {
        if (t.tag === "skip") {
          t.tag = "preprocessor";
          annotate_comment(parse_one(tokens[++i]));
        }
        t = tokens[++i];
      }
      
      if (!t) return {}; // hackity hack
      
      switch (t.tag) {
        case "{":
          return build_aggregate(new LispNode("map", [], t), "}");
        case "(":
          return build_aggregate(new LispNode("list", [], t), ")");
        case "#{":
          return build_aggregate(new LispNode("set", [], t), "}");
        case "[":
          return build_aggregate(new LispNode("vector", [], t), "]");
        case "'":
          return new PrefixNode("quote", t, parse_one(tokens[++i]));
        case "#'":
          return new PrefixNode("varquote", t, parse_one(tokens[++i]));  
        case "@":
          return new PrefixNode("deref", t, parse_one(tokens[++i]));  
        case "`":
          return new PrefixNode("quasiquote", t, parse_one(tokens[++i]));  
        case "unquote":
          return new PrefixNode("unquote", t, parse_one(tokens[++i]));
        case "splice":
          return new PrefixNode("splice", t, parse_one(tokens[++i]));  
        case "^":
          t.tag = "meta";
          var meta = parse_one(tokens[++i]);
          var next = parse_one(tokens[++i]);
          next.meta = meta;
          return next;
      }
      
      return t;
    }
    
    // build_aggregate collects to ether sub forms for one aggregate for. 
    function build_aggregate(current, expected_closing) {
      for (i++; i < j; i++) {
        var t = tokens[i];

        if (t.tag === "}" || t.tag === ")" || t.tag === "]") {
          if (t.tag !== expected_closing) t.tag = "invalid";
          current.closing = t;
          if (expected_closing) return current;
        }
        var node = parse_one(t);

        node.parent = current;
        current.list[current.list.length] = node;
      }
      
      return current;
    }
    
    build_aggregate(toplevel, null);
    
    return toplevel;
  }

  // annotation rules to apply to a form based on its head

  var show_locals = true;  // HACK. would rather not use a (semi)-global.

  /* annotate_comment is a special case annotation. 
   * in addition to its role in styling specific forms, it is called by parse_one to
   * ignore any forms skipped with #_
   */ 
  function annotate_comment(exp) {
    exp.tag = "comments";

    if (exp.list) {
      exp.opening.tag = "comments";
      exp.closing.tag = "comments";
    
      for (var i = 0; i < exp.list.length; i++) {
        var child = exp.list[i];
        if (child.list) {
          annotate_comment(child);
        }
        if (child.attached_node) {
          annotate_comment(child.attached_node);
        }
        else {
          child.tag = "comments";
        }
      }
    }
  }

  /* custom annotation rules are stored here */
  var annotation_rules = {};
  
  // this function is exposed to allow ad hoc extension of the customisation rules
  function register_annotation_rule(names, rule) {
    for (var i = 0; i < names.length; i++) {
      annotation_rules[names[i]] = rule;
    }
  }


  function annotate_destructuring (exp, scope) {
    if (exp.list) {
      if (exp.tag === "vector") {
        for (var i = 0; i < exp.list.length; i++) {
          annotate_destructuring(exp.list[i], scope);
        }
      } 
      else if (exp.tag === "map") {
        for (var i = 0; i < exp.list.length; i += 2) {
          var key = exp.list[i];
          var val = exp.list[i + 1];
          
          if (key.tag === "keyword" && val.tag === "vector") {
            for (var ii = 0, jj = val.list.length; ii < jj; ii++) {
              if (val.list[ii].tag !== "symbol") continue;
              val.list[ii].tag = "variable";
              scope[val.list[ii].value] = true;
            }
          }
          else {
            annotate_destructuring(key, scope);
            annotate_expressions(val, scope);
          }
        } 
      }
    } 
    else if (exp.tag === "symbol" && (exp.value !== "&" && exp.value !== "&amp;")){
      exp.tag = "variable";
      scope[exp.value] = true;
    }
  }

  function _annotate_binding_vector (exp, scope) {
    if (exp.tag !== "vector") return;
  
    var bindings = exp.list;

    if (bindings.length % 2 === 1) return;
    
    for (var i = 0; i < bindings.length; i += 2) {
      annotate_destructuring(bindings[i], scope);
      annotate_expressions(bindings[i + 1], scope);
    }    
  }

  function annotate_binding (exp, scope) {
    var bindings = exp.list[1];
    if (!show_locals) return; // HACK

    if (bindings) {
      scope = Object.create(scope);
      _annotate_binding_vector(bindings, scope);
    }
    for (var i = 2; i < exp.list.length; i++) {
      annotate_expressions(exp.list[i], scope);
    }
  }
  
  function _annotate_function_body (exp, scope, start_idx) {
    var argvec = exp.list[start_idx];
    if (argvec.tag !== "vector") return;

    scope = Object.create(scope);

    for (var i = 0, j = argvec.list.length; i < j; i++) {
      annotate_destructuring(argvec.list[i], scope);
    }
    
    for (var i = start_idx, j = exp.list.length; i < j; i++) {
      annotate_expressions(exp.list[i], scope);
    }
  }
  
  function annotate_function (exp, scope) {
    for (var i = 1, j = exp.list.length; i < j; i++) {
      var child = exp.list[i];
      
      if (child.tag === "vector") {
        _annotate_function_body (exp, scope, i);
        return;
      }
      else if (child.tag === "list") {
        _annotate_function_body(child, scope, 0)
      }
    }
  }
  
  function annotate_letfn (exp, scope) {
    scope = Object.create(scope);
    var bindings = exp.list[1];
    
    var fn;
    for (var i = 0, j = bindings.list.length; i < j; i++) {
      fn = bindings.list[i];
      if (!fn.list[0]) continue;
      fn.list[0].tag = "variable";
      scope[fn.list[0].value] = true;
    }
    
    for (i = 0, j = bindings.list.length; i < j; i++) {
      var fn = bindings.list[i];
      annotate_function(fn, scope);
    }
    
    for (i = 2, j = exp.list.length; i < j; i++) {
      annotate_expressions(exp.list[i], scope);
    }
  }

  register_annotation_rule(
    ["comment"],
    annotate_comment
  );
  
  register_annotation_rule(
    ["let", "when-let", "if-let", "binding", "doseq", "for", "dotimes", "let*"],
    annotate_binding
  );
  
  register_annotation_rule(
    ["defn", "defn-", "fn", "bound-fn", "defmacro", "fn*", "defmethod"],
    annotate_function
  );
  
  register_annotation_rule(
    ["letfn"],
    annotate_letfn
  );

  // standard annotations

  function _annotate_metadata_recursive(meta, scope) {
    if (!meta) return;

    if (meta.list !== undefined && meta.list !== null) {
      for (var i = 0, j = meta.list.length; i < j; i++) {
        meta.opening.secondary_tags.meta = true
        meta.closing.secondary_tags.meta = true
        _annotate_metadata_recursive(meta.list[i], scope);
      }
    }
    else if (meta.attached_node) {
      meta.token.secondary_tags.meta = true;
      _annotate_metadata_recursive(meta.attached_node, scope);
    }
    else {
      meta.secondary_tags.meta = true;
    }
  }
  
  function annotate_metadata(exp) {
    if (!(exp && exp.meta)) return;
    var meta = exp.meta;
    
     annotate_expressions(meta, {});    
    _annotate_metadata_recursive(meta, {});
  }


  function annotate_quoted(exp, scope) {
    if (!exp) return;

    if (exp.list !== undefined && exp.list !== null) {
      for (var i = 0, j = exp.list.length; i < j; i++) {
        exp.opening.secondary_tags.quoted = true
        exp.closing.secondary_tags.quoted = true
        annotate_quoted(exp.list[i], scope);
      }
    }
    else if (exp.attached_node) {
      if (exp.tag === "unquote" || exp.tag === "splice") return;
      exp.token.secondary_tags.quoted = true;
      annotate_quoted(exp.attached_node, scope);
    }
    else {
      exp.secondary_tags.quoted = true;
    }
  }


  function annotate_expressions(exp, scope) {
    annotate_metadata(exp);
    
    switch (exp.tag) {
      case "toplevel": 
        for (var i = 0; i < exp.list.length; i++) {
          annotate_expressions(exp.list[i], scope);
        }
        break;
      
      case "list": // functions, macros, special forms, comments
        var head = exp.list[0];
      
        if (head) {
          if (head.tag === "list" || head.tag === "vector" 
           || head.tag === "map" || head.tag === "set") {
            annotate_expressions(head, scope);
          }
          else if (head.attached_node) {
            annotate_expressions(head.attached_node, scope);
          }
          else {
            head.tag = (head.value.match(/(^\.)|(\.$)|[A-Z].*\//)
                        ? "method"
                        : "function");
          }

          // apply specific rules
          if (annotation_rules.hasOwnProperty(head.value)) {
            annotation_rules[head.value](exp, scope);
          } 
          else {
            for (var i = 1; i < exp.list.length; i++) {
              annotate_expressions(exp.list[i], scope);
            }
          } 
        }
        else { // empty list
          exp.opening.tag = "value";
          exp.closing.tag = "value";
        }
      
        break;
      
      case "vector": // data
      case "map":
      case "set":
        for (var i = 0; i < exp.list.length; i++) {
          annotate_expressions(exp.list[i], scope);
        }
        break;
      
      case "symbol":
        if (exp.value.match(/[A-Z].*\/[A-Z_]+/)) {
          exp.tag = "constant";
        }
        else if (show_locals && scope[exp.value]) {
          exp.tag = "variable";
        }
        else if (exp.tag === "symbol" && exp.value.match(/([A-Z].*\/)?[A-Z_]+/)) {
          exp.tag = "type";
        }
        break;
      
      case "quote":
      case "quasiquote":
        annotate_quoted(exp.attached_node, scope);
        
      default:
        if (exp.attached_node) annotate_expressions(exp.attached_node, scope);
    }
  }

  // translation of tag to css:
  var css_translation = {
    "constant":     "constants",
    "keyword":      "constants",
    "method":       "color1",
    "type":         "color3", 
    "function":     "functions",
    "string":       "string",
    "regexp":       "string",
    "value":        "value",
    "comments":     "comments",
    "symbol":       "symbol",
    "variable":     "variable",
    "splice":       "preprocessor", 
    "unquote":      "preprocessor",     
    "preprocessor": "preprocessor",
    "meta":         "preprocessor", 
    "'":            "preprocessor", 
    "#'":           "preprocessor",    
    "(":            "plain",
    ")":            "plain",
    "{":            "keyword",
    "}":            "keyword",
    "#{":           "keyword",   
    "[":            "keyword",
    "]":            "keyword",
    "invalid":      "invalid",
    "@":            "plain" 
  };
  
  function translate_tags_to_css(tokens) {
    for (var i = 0, j = tokens.length; i < j; i++) {
      var token = tokens[i];
      token.css = css_translation[token.tag];
      for (var k in token.secondary_tags) if (token.secondary_tags.hasOwnProperty(k))
        token.css += " " + k ;
    };
  }
  
  
  // create the new brush

  SH.brushes.Clojure = function () {};
  SH.brushes.Clojure.prototype = new SyntaxHighlighter.Highlighter();
  
  SH.brushes.Clojure.prototype.findMatches = function find_matches (regexpList, code) {
    // this is a nasty global hack. need to resolve this
    if (this.params && this.params.locals) {
      show_locals = this.params.locals === true || this.params.locals === "true"; 
    }
    else {
      show_locals = true;
    }
    
    var tokens = tokenize(code);
    annotate_expressions(build_tree(tokens), {});
    translate_tags_to_css(tokens);

    return tokens;
  };
  
  SH.brushes.Clojure.aliases = ['clojure', 'Clojure', 'clj'];
  SH.brushes.Clojure.register_annotation_rule = register_annotation_rule;

  return {
    tokenize: tokenize,
    build_tree: build_tree
  };
})(SyntaxHighlighter);
</script><title>experiment -- Marginalia</title></head><body><table><tr><td class="docs"><div class="header"><h1 class="project-name">experiment</h1><h2 class="project-version">0.9.0</h2><br /><p>Evaluation platform of a new model for running, recording and sharing self-experiments</p>
</div><div class="dependencies"><h3>dependencies</h3><table><tr><td class="dep-name">org.clojure/clojure</td><td class="dotted"><hr /></td><td class="dep-version">1.3.0</td></tr><tr><td class="dep-name">org.clojure/tools.logging</td><td class="dotted"><hr /></td><td class="dep-version">0.2.3</td></tr><tr><td class="dep-name">org.clojure/math.numeric-tower</td><td class="dotted"><hr /></td><td class="dep-version">0.0.1</td></tr><tr><td class="dep-name">congomongo</td><td class="dotted"><hr /></td><td class="dep-version">0.1.8</td></tr><tr><td class="dep-name">org.clojars.alexnixon/clucy</td><td class="dotted"><hr /></td><td class="dep-version">0.3.2-SNAPSHOT</td></tr><tr><td class="dep-name">swank-clojure</td><td class="dotted"><hr /></td><td class="dep-version">1.4.0</td></tr><tr><td class="dep-name">clucy</td><td class="dotted"><hr /></td><td class="dep-version">0.3.0</td></tr><tr><td class="dep-name">noir</td><td class="dotted"><hr /></td><td class="dep-version">1.2.2</td></tr><tr><td class="dep-name">quartz-clj</td><td class="dotted"><hr /></td><td class="dep-version">1.1.0-SNAPSHOT</td></tr><tr><td class="dep-name">handlebars-clj</td><td class="dotted"><hr /></td><td class="dep-version">0.9-SNAPSHOT</td></tr><tr><td class="dep-name">clj-logging-config</td><td class="dotted"><hr /></td><td class="dep-version">1.9.1</td></tr><tr><td class="dep-name">clj-time</td><td class="dotted"><hr /></td><td class="dep-version">0.3.2</td></tr><tr><td class="dep-name">cheshire</td><td class="dotted"><hr /></td><td class="dep-version">3.0.0</td></tr><tr><td class="dep-name">clj-http</td><td class="dotted"><hr /></td><td class="dep-version">0.3.0</td></tr><tr><td class="dep-name">clj-oauth</td><td class="dotted"><hr /></td><td class="dep-version">1.3.1-SNAPSHOT</td></tr><tr><td class="dep-name">clodown</td><td class="dotted"><hr /></td><td class="dep-version">1.0.2</td></tr><tr><td class="dep-name">com.draines/postal</td><td class="dotted"><hr /></td><td class="dep-version">1.7-SNAPSHOT</td></tr><tr><td class="dep-name">incanter</td><td class="dotted"><hr /></td><td class="dep-version">1.3.0</td></tr><tr><td class="dep-name">log4j</td><td class="dotted"><hr /></td><td class="dep-version">1.2.16</td></tr><tr><td class="dep-name">org.slf4j/slf4j-log4j12</td><td class="dotted"><hr /></td><td class="dep-version">1.6.1</td></tr></table></div><div class="dependencies"><h3>dev dependencies</h3><table><tr><td class="dep-name">clojure-source</td><td class="dotted"><hr /></td><td class="dep-version">1.3.0</td></tr><tr><td class="dep-name">swank-clojure</td><td class="dotted"><hr /></td><td class="dep-version">1.4.0</td></tr><tr><td class="dep-name">lein-daemon</td><td class="dotted"><hr /></td><td class="dep-version">0.4.0</td></tr><tr><td class="dep-name">lein-multi</td><td class="dotted"><hr /></td><td class="dep-version">1.1.0-SNAPSHOT</td></tr><tr><td class="dep-name">lein-marginalia</td><td class="dotted"><hr /></td><td class="dep-version">0.7.0</td></tr></table></div></td><td class="codes" style="text-align: center; vertical-align: middle;color: #666;padding-right:20px"><br /><br /><br />(this space intentionally left almost blank)</td></tr><tr><td class="docs"><div class="toc"><a name="toc"><h3>namespaces</h3></a><ul><li><a href="#experiment.content">experiment.content</a></li><li><a href="#experiment.controller">experiment.controller</a></li><li><a href="#experiment.server">experiment.server</a></li><li><a href="#experiment.infra.api">experiment.infra.api</a></li><li><a href="#experiment.infra.auth">experiment.infra.auth</a></li><li><a href="#experiment.infra.handlebar">experiment.infra.handlebar</a></li><li><a href="#experiment.infra.middleware">experiment.infra.middleware</a></li><li><a href="#experiment.infra.models">experiment.infra.models</a></li><li><a href="#experiment.infra.services">experiment.infra.services</a></li><li><a href="#experiment.infra.session">experiment.infra.session</a></li><li><a href="#experiment.models.article">experiment.models.article</a></li><li><a href="#experiment.models.comment">experiment.models.comment</a></li><li><a href="#experiment.models.core">experiment.models.core</a></li><li><a href="#experiment.models.eventlog">experiment.models.eventlog</a></li><li><a href="#experiment.models.events">experiment.models.events</a></li><li><a href="#experiment.models.harness">experiment.models.harness</a></li><li><a href="#experiment.models.instruments">experiment.models.instruments</a></li><li><a href="#experiment.models.omh">experiment.models.omh</a></li><li><a href="#experiment.model.omh-client">experiment.model.omh-client</a></li><li><a href="#experiment.models.profile">experiment.models.profile</a></li><li><a href="#experiment.models.samples">experiment.models.samples</a></li><li><a href="#experiment.models.schedule">experiment.models.schedule</a></li><li><a href="#experiment.models.suggestions">experiment.models.suggestions</a></li><li><a href="#experiment.models.trackers">experiment.models.trackers</a></li><li><a href="#experiment.models.trial">experiment.models.trial</a></li><li><a href="#experiment.models.user">experiment.models.user</a></li><li><a href="#experiment.libs.datetime">experiment.libs.datetime</a></li><li><a href="#experiment.libs.fitbit">experiment.libs.fitbit</a></li><li><a href="#experiment.libs.fulltext">experiment.libs.fulltext</a></li><li><a href="#experiment.libs.highcharts">experiment.libs.highcharts</a></li><li><a href="#experiment.libs.mail">experiment.libs.mail</a></li><li><a href="#experiment.libs.properties">experiment.libs.properties</a></li><li><a href="#experiment.libs.rescuetime">experiment.libs.rescuetime</a></li><li><a href="#experiment.libs.sms">experiment.libs.sms</a></li><li><a href="#experiment.libs.sparkline">experiment.libs.sparkline</a></li><li><a href="#experiment.libs.strava">experiment.libs.strava</a></li><li><a href="#experiment.libs.twitter">experiment.libs.twitter</a></li><li><a href="#experiment.libs.withings">experiment.libs.withings</a></li><li><a href="#experiment.libs.zeo">experiment.libs.zeo</a></li><li><a href="#experiment.views.admin">experiment.views.admin</a></li><li><a href="#experiment.views.article-page">experiment.views.article-page</a></li><li><a href="#experiment.views.authviews">experiment.views.authviews</a></li><li><a href="#experiment.views.bootstrap">experiment.views.bootstrap</a></li><li><a href="#experiment.views.calendar">experiment.views.calendar</a></li><li><a href="#experiment.views.charts">experiment.views.charts</a></li><li><a href="#experiment.views.common">experiment.views.common</a></li><li><a href="#experiment.views.dashboard">experiment.views.dashboard</a></li><li><a href="#experiment.views.discuss">experiment.views.discuss</a></li><li><a href="#experiment.views.explore">experiment.views.explore</a></li><li><a href="#experiment.views.facebook">experiment.views.facebook</a></li><li><a href="#experiment.views.google">experiment.views.google</a></li><li><a href="#experiment.views.help">experiment.views.help</a></li><li><a href="#experiment.views.home">experiment.views.home</a></li><li><a href="#experiment.views.menu">experiment.views.menu</a></li><li><a href="#experiment.views.omh">experiment.views.omh</a></li><li><a href="#experiment.views.pages">experiment.views.pages</a></li><li><a href="#experiment.views.settings">experiment.views.settings</a></li><li><a href="#experiment.views.study1">experiment.views.study1</a></li><li><a href="#experiment.views.study2">experiment.views.study2</a></li><li><a href="#experiment.views.templates">experiment.views.templates</a></li><li><a href="#experiment.views.test">experiment.views.test</a></li><li><a href="#experiment.views.trials">experiment.views.trials</a></li><li><a href="#experiment.views.welcome">experiment.views.welcome</a></li></ul></div></td><td class="codes">&nbsp;</td></tr><tr><td class="docs"><div class="docs-header"><a class="anchor" href="#experiment.content" name="experiment.content"><h1 class="project-name">experiment.content</h1><a class="toc-link" href="#toc">toc</a></a></div></td><td class="codes" /></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(ns experiment.content
  (:use experiment.models.article))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn make-article [article]
  (create-article! (:name article) (:title article) (:body article)))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn make-articles []
  (doall
   (map
    make-article
    [{:name &quot;about&quot;
      :title &quot;About PersonalExperiments.org&quot;
      :body &quot;
The goal of this site is to help users learn about themselves and share that learning with others.  We are exploring new methods of supporting users in building and running experiments, and in the future we aim to provide tools that improve the way we share our successes and failures with others.  The site is focused on supporting Personal Experiments.
## Who created the site?
This site is a joint project between three institutions and led by [Ian Eslick](http://ianeslick.com).  Our collaborators include the [New Media Medicine Group](http://newmed.media.mit.edu) of the [The MIT Media Laboratory](http://www.media.mit.edu/), the non-profit [Lybba](http://lybba.org/), and the [C3N Project](http://c3nproject.org) of the [Cincinnati Childrens Hospital and Medical Center](http://cincinnatichildrens.org/).  All of the participating institutions are dedicated to empowering patients through openness and encouraging increased patient engagement in the healthcare process.
## Why did we create it?
Science is simply a discipline we apply to our investigation of the
world to increase our confidence that our conclusions are reliable.
The scientific method outlines a very high level process of
hypothesis, prediction, experimentation, evaluation, and confirmation.
In medicine, the experimental model reaches it's most robust and
reliable form in the randomized, double-blind, placebo-controlled
clinical trial.  These trials have evolved to try to control all the
sources of error and ensure that we have the utmost confidence in the
result of a trial.
The problem with these trials today is that they do not provide a
personalized answer; these trials focus on determining how large
groups of people respond and not necessarily to predict who will have
side effects or who will do better or worse.  The single-subject
experimentation is an alternative experimental model which allows us
to evaluate a treatment just for ourselves, when it is safe to do so.
However, the results of these personal experiments do not directly
generalize to other people.  Just because we have the same symptoms,
what works for you may not work for me.
A further problem with large population clinical trials is that they
are expensive, and so most trials are run with a profit
motive (e.g. future drug sales).  There is nothing wrong with this,
but it does mean that unprofitable treatments, or unpopular
treatments, are rarely subject to trials and thus there is no
information for us, or our physicians, to work with.
## [A new model of discovery?](http://ianeslick.com/personalized-health-experiments-for-wellbeing)
Our longer term objective is to explore when and how we can take the
results of dozens of similar tests of a treatment and help someone
choose among multiple treatments - we don't need to know why something
works, we just want to know if it works and who it works for.  If we
have some evidence about who it works for, we can help people
prioritize their own exploration.
A Personal Experiment is an encapsulation of the scientific method and
also supports crowd-sourced peer review of each of the steps.  The
quality of instruments, experiments, and treatment protocols can all
be discussed and rated.  The opinions of many users can be used to
assess whether an experimental outcome is to be trusted or not.
This site does not directly support a model of hypothesis driven
research.  For example if we find out that eating butter increases
mental performance on tests, then we might want to know why.  Is it
the saturated fat, the medium chain fatty acids, the cholesterol, or
the trace proteins that is having the effect?  Hypothesis-driven
research would ask people to participate in experiments that would
separate which of the constituent elements was having an effect.
There are ethical and practical complexities to supporting this model
for a population, but an ambitious user could use the site to isolate
factors on their own.
Instead, we see the aims of a science of Collective Discovery as being
more modest; we want to find reliable predictors that help us know
which treatments improve symptoms for a given individual.  At it's
best, this is an engine for personalized medicine.  Moreover, reliable
patterns of effectiveness can also be used to suggest new avenues for
clinical investigation.
&quot;}
{:name &quot;treatment&quot;
 :title &quot;Making changes as Treatment&quot;
 :body &quot;
We are constantly changing what we do and observing the outcomes; it's how we all learned about world when we are children.  Changes can be anything such as a new kind of diet, a drug or supplement, or a new life habit such as meditation or attending church.  In this site, we  call any specific change that we can document a treatment.
## Search for treatments
![Treatment List](/img/intro/treatments.png)
&quot;}
{:name &quot;experiment&quot;
 :title &quot;What is a Personal Experiment?&quot;
 :body &quot;
An experiment is simply a protocol that specifies when and how long to try a treatment, how to record our symptoms, and how we will assess at the end whether the treatment changed the symptoms the way we hoped.
## It's more than just 'trying things out'
The challenge in making changes is that it can be hard to separate the impact of a treatment on a symptom from all the different things that can influence that symptom.  If we're hoping that a diet reduces fatigue, then we need to know that it isn't a lack of sleep that is causing us to feel tired.  Trying out the treatment multiple times helps to smooth over other causes that may interfere if we just try it out one time.
We also want to compare how we are doing on a treatment to how we're doing when we're off of it.  Being off a treatment is called a 'baseline', how we're doing in our normal course of life.  Our symptoms may vary even when we're not trying treatments, so the goal of a baseline period is to capture enough information to know if the changes during treatment are changing enough in the right direction to be a success.
## Example Experiment Screenshot
![Experiment Detail](/img/intro/experiment-detail.png)
&quot;}
{:name &quot;track&quot;
 :title &quot;Measuring your symptoms&quot;
 :body &quot;
Humans have poor memories of everyday occurrences.  Psychologists have identified many different sources of error in our recall.  This is why it is imperative to write down, as best we can, what is happening when it happens.  Of course this is hard to do if you're stuck with pencil and paper (or Excel), but fortunately there are myriad new technologies that can help simplify recording data from established methods like SMS messaging, to fancy devices like the [Zeo](http://myzeo.com) sleep monitor and the [FitBit](http://fitbit.com) activity tracker.  We support web, mobile web, e-mail, SMS, and devices that make their APIs public.
A measurement for a specific symptom is called an \&quot;instrument\&quot;.  A symptom may be measured in multiple ways, so there may be multiple instruments for any given symptom.  Knowing how to measure things we care about can be hard, part of the role of this site is to help you share ways of measuring these things.
## ![Tracking measurements](/img/intro/trackers.png)
&quot;}
{:name &quot;share&quot;
 :title &quot;Evaluating and Sharing outcomes&quot;
 :body &quot;
When we've finished the experiment, we'll have a set of measurements for each period of the experiment (baseline and treatment periods) and now we'll want to analyze whether that treatment worked for us or not.  There are mathematical techniques that can estimate whether a result was 'significant', but we will be using visual techniques that help you identify when the measurements are meaningful.  For example, in the following prototype, any data point that lies outside the red or purple lines is significant.  Here the treatment (eating butter) leads to a significant decrease in test time (test-taking speed) over the space of a week.  The benefit persists for a few days, then receeds.
![apparent Control Chart](/img/intro/control-chart2.png)
## Sharing results
If you try a specific experiment, with the same instruments, treatment protocol, and evaluation as other people, then we can start to understand how well that treatment performs when tested that way.  Of course an experiment may not be a very good one and be prone to letting you conclude it works when it doesn't.  We support discussion and ratings for each experiment to help everyone chime in on whether the results of the experiment really reflect the effectiveness of the treatment.
![Discussion](/img/intro/sharing.png)
&quot;}
{:name &quot;design&quot;
 :title &quot;Design an Experiment&quot;
 :body &quot;
Support for designing your own experiments coming soon...
&quot;}
])))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn terms-of-use []
  (create-article!
   &quot;terms&quot;
   &quot;Terms of Use&quot;
   &quot;
## Effective December, 2011
The following terms constitute an agreement (the 'Agreement') between you and PersonalExperiments.org. This agreement governs your use of the Site, both as a casual visitor and a registered member, as described below.
By accessing or using the Site, you agree to be bound by the terms of this Agreement. If you register on the Site as a member, then you will be subject to the terms and conditions for both users and members.
## Membership Eligibility
Children under the age of 13 are prohibited from registering as members. By registering as a member you represent that you are age 13 or older.
PersonalExperiments.org has the right at any time to change or discontinue any aspect of this Site, including the content, hours of availability, and equipment needed for access to or use. You understand and agree that this Site is provided to you exclusively under these Terms of Use.  PersonalExperiments.org reserves the right to terminate your account at any time, for any reason, including if either party learns that you have provided false or misleading registration information or have violated the Terms of Use.
## This Site Does Not Provide Medical Advice
All of the material provided on the Site, such as text, treatments, dosages, outcomes, charts, patient profiles, graphics, photographs, images, advice, messages, forum postings, and any other material provided on the Site are for informational purposes only and are not a substitute for professional medical advice or treatment. Always seek the advice of your physician or other qualified health provider with any questions you may have regarding your health. Never disregard professional medical advice or delay in seeking it because of something you have read on this Site.
If you think you may have a medical emergency, call your doctor or 911 immediately. PersonalExperiments.org does not recommend or endorse any specific tests, physicians, products, procedures, opinions, or other information that may be mentioned on the Site. Reliance on any information provided by PersonalExperiments.org, by persons appearing on the Site at the invitation of the site administrators, or by other members is solely at your own risk.
## Acceptable and Lawful Use of Site by Members
Members shall not post or upload any information or other content on the Site that (a) is false, inaccurate or misleading; (b) is obscene or indecent; (c) infringes any copyright, patent, trademark, trade secret or other proprietary rights or rights of publicity or privacy of any party; or (d) is defamatory, libelous, threatening, abusive, hateful, or contains pornography. Members shall not interfere with other members' use and enjoyment of Site. Members may not use the Site to conduct any activity that is illegal or violates the rights of others, provide instructional information about illegal activities, or promote physical harm or injury against any group or individual.
All members represent and warrant that the information they provided when registering as a member, and all information that they subsequently provide regarding themselves and their membership, is true, accurate and not misleading.
## Use of Site by Members and Non-Members
You may not use any robot, spider, scraper, or other automated means to access the Site or content or services provided on the Site for any purposes. You may not post content on the Site that contains any viruses, Trojan horses, worms, time bombs, spiders, or other computer programming routines that are intended to damage, detrimentally interfere with, surreptitiously intercept or expropriate any system, data or personal information. You shall not attempt to make the Site unavailable through denial-of-service attacks or similar means. You shall not use contact information provided by members, or collect information about our members, to facilitate the sending of unsolicited bulk communications such as SPAM or SPIM or allow others use of your membership account to take such actions.
All the text, images, marks, logos, compilations (meaning the collection, arrangement and assembly of information) of the Web Site, including any Submissions (as defined below), and any of the foregoing sent to you by e-mail or other means (collectively, the 'Site Content') are proprietary to PersonalExperiments.org or to third parties where designated. Separate provisions apply to Health Data submitted by users and are defined below.
PersonalExperiments.org authorizes you to view, download, and print the Site Content subject to the following conditions: (a) you may only download and print the Site Content in limited quantities, as required to evaluate whether the good and services displayed on the Web Site are appropriate for your intended use; (b) you may not modify the Site Content; (c) any displays or print outs of the Site Content must be marked 'Copyright  2011 PersonalExperiments.org. All rights reserved.'; and (d) you may not remove any copyright, trademark or other proprietary notices that have been placed in the Site Content. Except as expressly permitted above, copying, modifying reproduction, redistribution, republication, uploading, posting, transmitting, distributing or otherwise exploiting in any way the Site Content, or any portion of the Site Content, is strictly prohibited without the prior written permission of PersonalExperiments.org. In addition, you may not link to any part of the Web Site or any Site Content or frame or otherwise display in any manner the Site Content at any other web site or elsewhere without our prior written consent.
## Non-Commercial Use by Members
The Member Area and the content and information contained in the Member Area is for the personal use of individual members only and may not be used in connection with any commercial endeavors. Organizations, companies, and/or businesses may not become members and should not use the Site without the written pre-authorization from PersonalExperiments.org.
## Privacy
You agree that you have read, understood and accept the terms of PersonalExperiments.org Privacy Policy, for the use of the Site (the 'Privacy Policy') This Policy governs the collection, use and sharing of personal and non-personal information for all those who elect to use the Site including Submissions.
## Submissions
PersonalExperiments.org welcomes your comments regarding the Site and Site Content. In the event that you submit ideas, suggestions, materials or other information to PersonalExperiments.org, whether at the request of MIT Media Lab and LTA or through your use of the Site (all of the foregoing being 'Submissions'), the Submissions will be deemed, and will remain, the sole property of PersonalExperiments.org. The Submissions will not be treated as confidential by PersonalExpeirment.org, or their respective Affiliates (as defined below), nor will such parties be liable for any use or disclosure of any Submissions. Without limiting the foregoing, PersonsalExperiments.org own all presently known or hereafter existing rights to the Submissions of every kind, in perpetuity, and will be entitled to unrestricted use of the Submissions for any lawful purpose whatsoever, commercial or otherwise, by any means, by any media, without compensation to the provider, author, creator or inventor of the Submissions (the 'Participant'). Each Participant irrevocably and unconditionally waives and covenants not to assert any such rights against PersonalExperiments.org or its affiliates, employees, departments, successors, assigns, licensees, and customers (collectively, 'PersonalExperiments.org Affiliates'), as well as any users of the Site.
## Posting and Use of Content in the Member Area
The Member Area includes community areas, such as forums and other member areas, where members may post messages, images, and other content. If you are a member, you (or the author) own(s) the copyright in the messages, images, and other content you post in the Member Area. However, by posting such content to the Member Area, you grant PersonalExperiments.org and its respective Affiliates the right to use, copy, display, perform, distribute, translate, edit, and create derivative works of your postings, subject to the terms of the Privacy Policy.
While some community areas in the Member Area are monitored periodically for topicality, PersonalExperiment.org have no obligation to prescreen postings and are not responsible for their content. We encourage you to notify us of inappropriate or illegal content and we reserve the right to remove postings for any reason.
You agree not to disclose to any person or entity personally identifiable information about other members that you learn while using this Site (whether posted in the Member Area by a member or emailed to you by a member) without the written consent of such member. You may disclose information of a general nature that will not reasonably lead to the identification of the member who provided such information or whom such information is about, to third parties outside this Site, subject to the above restriction on non-commercial use.
## Member Password and Login Identity
You are responsible for maintaining the confidentiality of your member password and login, and are fully responsible for all activities that occur under your password or account with or without your knowledge. If you knowingly provide your login and password information to another person, your membership privileges may be suspended temporarily or terminated. You agree to immediately notify PersonalExperiments.org of any unauthorized use of your membership password or login or any other breach of security.
## Health Data
This site encourages you to submit and share data about your health and history. You have specific rights to any personal health data you have entered including changing, deleting, downloading, and sharing this data. The use of your data by PersonalExperiment.org are governed by the Privacy Policy. Your personal data will be used by the Site to construct an aggregate, de-identified view of the patient population. You agree not to enter personal identifiers into any survey or journal forms on the Site. Only the profile section should contain identifiers.
Health Data does not include any information or comments in the forums or public commenting section which are to be considered public and are governed as described in Submissions above. Private contact between users can be done via an e-mail exchange to facilitate non-public discourse.
Health data can be removed from future aggregate views on the site, but your prior data will be maintained in an archived, de-identified form. To have your data and identifiers removed from active use in the system, send an e-mail with your instructions to ianeslick@gmail.com.
## Links to Third Party Web Site Are Not Endorsements
The Site contains links to third-party web sites. The linked sites are not under our control, and we are not responsible for the content of any linked site. We provide these links as a convenience only, and a link does not imply endorsement of, sponsorship of, or affiliation with the linked site by PersonalExperiments.org. Links to merchants or advertisers are owned and operated by independent retailers or service providers, and therefore, we make no warranties or representations regarding their products, services or business practices. You are encouraged to exercise appropriate due diligence before proceeding with any transaction with any of these third parties.
## Membership Termination
You agree that PersonalExpeirments.org may, with or without cause, immediately terminate your membership and access to the Member Area, without prior notice. Without limiting the foregoing, reasons for termination may include, but are not limited to, the following: (a) breaches or violations of this Agreement or other incorporated agreements or policies, (b) requests by law enforcement or other government agencies, (c) a request by you (self-initiated membership cancellation), (d) unexpected technical issues or problems, and (e) extended periods of inactivity. PersonalExperiments.org have no obligation to maintain, store, or transfer information or data to you that you have posted on or uploaded to the Site.
## Modifications to this Agreement
We reserve the right to modify this Agreement at any time, and without prior notice, by posting amended terms on this Site. We encourage you to review this Agreement periodically for any updates or changes, which will be reflected by the revised date of the Agreement.
## Disclaimer of Warranties
The Site and the content and services made available on the Site are provided on an 'as is' and 'as available' basis. PersonalExperiments.org disclaims all express and implied warranties and representations, including, but not limited to, any implied warranty of fitness for a particular purpose, with regard to the Site, the Site content, or any advice or services provided through the Site to the extent permitted by law. PersonalExperiment.org does not warrant that access to the Site or its content or services will be uninterrupted or error-free or that defects in the Site will be corrected.
The advice, recommendations, information, and conclusions posted or emailed by other members of the Site are not in any way vetted, approved or endorsed by PersonalExperiments.org. You acknowledge that you use such information at your own risk.
## Limitation of Liability
Under no circumstances shall PersonalExperiment.org and their respective Affiliates be liable for any indirect, incidental, special, or consequential damages (even if it has been advised of the possibility of such damages) due to your use of this Site or to your reliance on any of the content contained or the services provided therein.
## Indemnification
You agree to indemnify, defend, and hold harmless PersonalExperiments.org and their respective Affiliates, from and against any claims, actions or demands, damages, expenses, liabilities and settlements, including without limitation, attorneys fees and other costs incurred or resulting from, or alleged to result from, your violation of this Agreement.
## International Users
PersonalExperiments.org does not warrant that it is appropriate, to download, store or disclose information on the Site outside of the United States ('International Use'), in compliance with the users local jurisdiction. Personal information ('Information') that is submitted to this Site will be collected, processed, stored, disclosed and disposed of in accordance with applicable U.S. law and our Privacy Policy. If you are an International User, you acknowledge and agree that PersonalExperiments.org may collect and use your Information and disclose it to other entities outside your resident jurisdiction. In addition, such Information may be stored on servers located outside your resident jurisdiction. By providing us with your Information, you acknowledge that you consent to the transfer of such Information outside your resident jurisdiction, as detailed in our Privacy Policy. If you do not consent to such transfer, you may not use this Site.
## Member Notices
If you register as a member, you agree that PersonalExpeirments.org may send notices to you by email at the email address you provide when registering to become a member (or which you later update using the functionality of the Site).
## Governing Law and Venue
Those who choose to access this website do so at their own risk and on their own initiative and are responsible for compliance with all applicable local laws. These terms shall be governed by and construed in accordance with the California State Laws. Any dispute under these terms shall be subject to the exclusive jurisdiction of the courts of California (subject to appeal) and, by using this website, you hereby submit to the jurisdiction of such courts for such purposes and waive any and all objections as to jurisdiction or venue in such courts.
## Digital Millennium Copyright Act
The Digital Millennium Copyright Act (17 U.S.C. 512, as amended) governs the operation and maintenance of this Site. 
## No Waiver
No delay or failure to act by PersonalExperiments.org in exercising any of its respective rights occurring upon any noncompliance or default by you, with respect to any of the terms and conditions of this Agreement, will impair any such right or be construed to be a waiver thereof, and a waiver by PersonalExperiments.org of any of the covenants, conditions or agreements to be performed by you, will not be construed to be a waiver of any succeeding breach thereof or of any other covenant, condition or agreement hereof contained. As used in this Agreement, 'including' means 'including but not limited to.'
## Severability
If any provision of this Agreement is found by a court of competent jurisdiction to be invalid, illegal or unenforceable, under any present or future law, then as long as each partys rights and obligations under this Agreement are not materially or adversely affected thereby, such provisions shall be fully severable, and the remaining provisions of the Agreement will remain in full force and effect to the greatest extent permitted by law. Except as otherwise expressly provided herein, this Agreement sets forth the entire agreement between you and PersonalExperiments.org regarding its subject matter, and supersedes all prior promises, agreements or representations, whether written or oral, regarding such subject matter. You agree that the electronic text of this Agreement constitutes a 'writing', and your assent to the terms and conditions hereof constitutes a 'signing' for all purposes.
## Use of Name
Users of the Site shall not use the name of 'PersonalExperiments.org', 'Ian Eslick', the 'Massachusetts Institute of Technology', the 'MIT Media Laboratory', or any variation, adaptation or abbreviation thereof, or of any of its trustees, officers, faculty, students, employees or agents, or any trademark owned by MIT, or any terms of this Agreement I any promotional material or public announcement or disclosure, without the prior written consent of MITs Technology Licensing Office.
All other brand names and logos that appear throughout PersonalExperiment.org web pages are marks owned by third parties.
All software used on the Site is proprietary to us or to third parties, and except as may be required to exercise the foregoing license, any redistribution, sale, decompilation, reverse engineering, disassembly, translation or other reduction of such software to human-readable form is prohibited.
You agree, represent and warrant, that your use Site and the Site Content, or any portion thereof, will be consistent with the foregoing license, covenants and restrictions and will neither infringe, nor violate the rights of any other party or breach any contract or legal duty to any other parties. In addition, you agree that you will comply with all applicable laws and regulations (the 'Laws') relating to the Site, the Site Content or your use of the same, and you will be solely responsible for your violations of any of the Laws.
## Assignment
PersonalExperiments.org may assign this Agreement, at any time, to a subsidiary, parent company or a successor to its business, as part of a merger or sale of substantially all of its assets. You may not assign or transfer this Agreement.
If you have questions or comments about our Terms of Use, please contact us at: ianeslick@gmail.com. You can also direct questions or comments, or violations of this Agreement, to:
Ian Eslick
MIT Media Laboratory
E15-274G
77 Massachusetts Avenue
Cambridge, MA 02139
USA
&quot;))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn privacy []
  (create-article!
   &quot;privacy&quot;
   &quot;Privacy Policy&quot;
   &quot;
## Effective December 11th, 2011
PersonalExperiments.org acknowledges that our website, www.personalexperiments.org (the Site), can only provide the Community with an effective tool if we build trust among members. This privacy policy (the Policy or Privacy Policy) outlines the type of information PersonalExperiments.org collects from our members and how it is shared with other parties. We reserve the right to modify this policy at any time, and without prior notice, by posting amended terms on this website. We encourage you to review this policy periodically for any updates.
## WHAT KIND OF DATA WE COLLECT AND WHY
PersonalExperiments.org enables patients to provide information about their disease history, family history and lifestyle online so that the collective knowledge of thousands of patients can be shared with others affected by the disease, as well as researchers. Our collective success in achieving this goal depends on members' willingness to share their data with others.
The type of data patients may add to their profiles ('Profile Data')  may include: 
*   Condition/disease information, including diagnosis date, first symptom information, and family history
*   Treatments tried, including treatment start dates, stop dates, and dosages
*   Symptoms experienced, including severity and duration
*   Biographical information, including age, location (city, state &amp; country), and general notes.
*   Experimental data recorded from self-experiments run on the site
Patients may voluntarily enter information that identifies them ('Personally Identifiable Information' such as name, address, email, and birth date) into their Profile Data. PersonalExperiments.org will hold Profile Data and personally identifiable information provided by patients in the strictest confidence and maintain the security of such information in accordance with all applicable laws. Such data will only be available to the site manager and will not be released to any parties in any form that will identify the patient, without the patients prior written authorization. You will be asked for an email address and to make a selection of preferences about how your personal information can be used to contact you for administrative and research purposes. For example, you can authorize researchers to contact you with information about drug trials or requests for further information.
The site allows patients and researchers to make their own surveys and requests for data. Data entered into any survey in the Collect section of the website is available to the rest of the community in aggregate form as described above. You should never enter Personally Identifiable Information into any of these forms if you are concerned about privacy. Please comment on any forms that you feel violate common sense protection of privacy.
We may periodically ask you to complete short surveys about the site itself. Your participation in these surveys is not required, and your refusal to do so will not impact your experience on the website. Our aim is to create the best possible tool for research, as well as provide global information for patients. We would appreciate any input on site surveys etc. that you are willing to provide.
Cookies are required to use the PersonalExperiments.org service. A cookie is a small data file, which often includes an anonymous unique identifier that is sent to your browser from a web site's computers and stored on your computer's hard drive. PersonalExperiments.org uses two types of cookies: Session Cookies, and Persistent Cookies. Session Cookies are temporary cookies that remain in the cookie file of your browser until you leave the Website. Session cookies do no store any personally identifying information, only a unique visitor ID number that we can use to customize the PersonalExperiments.org functionality for you. Persistent Cookies remain in the cookie file of your browser for much longer, even after you leave the PersonalExperiments.org website. Persistent cookies do no store any personally identifying information, only preferences that should persist from visit to visit, like 'Remember Me'.
## HOW YOUR PERSONALLY IDENTIFIABLE DATA IS USED
In order to help researchers and to learn from our collective experiences, your Survey and Experiment data will be aggregated and made available to other members in aggregate non-identifiable form. For example, we may report the number of patients trying a particular treatment or the number of patients experiencing a particular symptom. This aggregate data will not include your personal information.
By completing your Profile Data, your personal information will be added to our database, which will be used for research purposes only. For example, we may look at scientific questions such as, 'Do certain experimental treatments seem associated with certain sub-populations of patients?' At PersonalExperiments.org and in conjunction with external researchers, were interested in better understanding the experience of living with chronic conditions and improving treatment options and health outcomes for everyone.
PersonalExperiments.org will not rent, sell or share information that  personally identifies you for marketing purposes. We may subsequently assign control of PersonalExperiments.org and all of its rights and obligations to another entity, to ensure its continued availability and use. You will receive timely notice of such an assignment, and have the option of deleting your personal information prior to such a transfer.
PersonalExperiments.orgs goal is to allow researchers direct and anonymous communication with you through our system. Furthermore, we may also provide researchers with anonymized data (which may or may not be aggregated) for research purposes only. Personal identifiers will be used only to contact and to de-duplicate information and will not be available to anyone without your explicit permission.
## OTHER SECURITY ISSUES
PersonalExperiments.org will take reasonable measures to safeguard your personal information and identity from any other members with whom you may interact in the course of using the Site or who may have access to information you have posted in the Discuss area. Researchers requesting access to the data on PersonalExperiments.org will be personally vetted by PersonalExperiments.org staff or approved partners.
At some point we may choose to implement a method by which we can increase confidence in the identity of a user of PersonalExperiments.org (a researcher, a patient, a family member, etc.). This method will involve trusted individuals providing a reference for another individual. We and our partners may also take the extra step of directly identifying researchers and limiting access to any researchers who have not gone through this process.
## RISKS AND BENEFITS
A key objective in providing the PersonalExperiments.org platform is to improve health outcomes and expedite the development of successful treatments for a wide variety of conditions. Although there are no certain benefits to using the Site, by pooling information and resources, we hope that PersonalExperiments.org will foster the necessary access to otherwise un-captured global patient data that can accelerate the pace of personal and clinical discovery.
Users may elect to stop using the Site at any time. You are free to skip any questions or data fields that make you feel uncomfortable. You will have full control over your information, including the ability to download, remove all personal identifiers, or to remove data from the system subject to the conditions described below.
## QUESTIONS ABOUT THE PRIVACY POLICY
If you have questions or comments about our Privacy Policy, please contact us at: ianeslick@gmail.com. You can also direct questions or comments to:
PersonalExperiments.org c/o Ian Eslick
MIT Media Laboratory
77 Masachusetts Avenue, E15-274G 
Cambridge, MA 02139
USA
&quot;))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn study1-docs []
  (doall
   (map
    make-article
    [{:name &quot;study1-protocol&quot;
      :title &quot;Authoring Single-Subject Experimental Protocols&quot;
      :body &quot;
## Procedure  
1.  Register at the site http://experiment.media.mit.edu by clicking on \&quot;Authoring an Experiment\&quot; on the home page.  [This requires at a minimum your e-mail address for follow up contact during the study period (ending in March of 2012).  After that, personal identifiers will be removed from the data we collect in this study unless you opt-in to keep your account]
2.  Log-in to the site and read introductory material about single-subject experiments.  This should take no more than 30 minutes.
3.  Click on \&quot;Author an Experiment\&quot;.  [Each authoring activity may take from between 15 minutes to 2 hours depending on how extensively you wish to perform the online research].  Authoring consists of:
a.  Reading patient reports of trying different treatments
b.  Go to websites that describe the treatment and/or symptoms as well as potential factors that would lead to false conclusions and how to adjust for them.
c.  Fill out the template to define the experiment
4.  When you are done, click on \&quot;Take the Survey\&quot; to take an exit survey.  This survey will be hosted at http://qualtrics.com
## Authoring an Experiment
The primary goal of this study is to educate patients on running single-subject experiments in their own lives and understanding what aspects of this are easy or accessible, and which are more difficult.  This will help inform future work we do on the site to support users who want to understand whether the changes they want to make in their life will have the impact they hope.
An experiment is made up of a number of different parts, described in more detail in the introductory materials.
-   Outcome variables and how to measure them
-   Confounding variables and how to measure them
-   Description of treatment protocol 
-   Explicit dosing information, if applicable   
-   The schedule for baseline and intervention including onset and washout times
-   The method of analysis (e.g. difference of means, control charts)
-   Pre-conditions (e.g. what symptoms need to be present for treatment to be relevant, including prior diagnoses, symptoms, etc)
-   Possible predictors of a positive response ('People who do X usually find this works')
&quot;}
     ])))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn bootstrap-articles []
  (make-articles)
  (privacy)
  (terms-of-use))</pre></td></tr><tr><td class="spacer docs">&nbsp;</td><td class="codes" /></tr><tr><td class="docs"><div class="docs-header"><a class="anchor" href="#experiment.controller" name="experiment.controller"><h1 class="project-name">experiment.controller</h1><a class="toc-link" href="#toc">toc</a></a></div></td><td class="codes" /></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(ns experiment.controller
  (:use
   experiment.infra.models
   experiment.models.user
   experiment.models.trial
   experiment.models.events
   experiment.models.trackers)
  (:require
   [quartz-clj.core :as q]
   [experiment.libs.datetime :as dt]
   [experiment.libs.properties :as prop]
   [clojure.tools.logging :as log]
   [clj-time.core :as time]))</pre></td></tr><tr><td class="docs"><hr />

<h2>Scheduling Events</h2>

<p>This top level event controller is a wrapper around
quartz-clj and the Quartz 2.1 library.  It provides support
for running regular maintenance tasks, including queueing and
operating on user events.</p>
</td><td class="codes"></td></tr><tr><td class="docs"><h2>Application Job: Event Actions</h2>

<p>Call schedule-event to create a quartz task based on EventActionJob
which will trigger at the :start time, extract the event context
from MongoDB and call the fire-event multi-method on it.</p>

<p>Depends on:</p>

<ul>
<li>quartz-clj</li>
<li>experiment.models.events <br /></li>
<li>experiment.models.schedule</li>
</ul>
</td><td class="codes"></td></tr><tr><td class="docs"><p>Extract an event associated with a task </p>
</td><td class="codes"><pre class="brush: clojure">(defn event-from-context
  [ctx]
  (if-let [id ((q/context-data ctx) &quot;eid&quot;)]
    (if-let [event (fetch-model :event {:_id (deserialize-id id)})]
      event
      (log/error (str &quot;Event &quot; id &quot; not found&quot;)))
    (log/error (str &quot;No event ID (eid) found in job context&quot;))))</pre></td></tr><tr><td class="docs"><h2>EventActionJob</h2>

<p>When an event is scheduled, this job will call fire-event
on the event object pulled from the DB (via context reference)</p>
</td><td class="codes"></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(q/defjob EventActionJob [context]
  (when-let [event (event-from-context context)]
    (fire-event event)))</pre></td></tr><tr><td class="docs"><h2>Setup Jobs</h2>
</td><td class="codes"></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn report-scheduling-event [event]
  (when event
    (log/tracef &quot;Scheduling tracker event (%s) for %s&quot;
                (:variable (event-inst event))
                (:username (event-user event))))
  event)</pre></td></tr><tr><td class="docs"><p>Schedule the firing of an event stored in the mongo DB collection :event</p>

<ul>
<li>:_id - must be a valid MongoDB id in :event collection</li>
<li>:start - must contain a valid time reference (long, java, or Joda date)</li>
</ul>
</td><td class="codes"><pre class="brush: clojure">(defn schedule-event
  [event]
  (when event
    (q/schedule-task [(str &quot;EventAction-&quot; (:_id event))
                      &quot;experiment-events&quot;]
                     EventActionJob
                     :start (:start event)
                     :datamap {&quot;eid&quot; (serialize-id (:_id event))})))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn schedule-tracker [tracker inter]
  (doseq [event (tracker-events tracker inter)]
    (-&gt; event
        register-event
        report-scheduling-event
        schedule-event)))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn schedule-reminder [trial inter]
  (doseq [event (reminder-events trial inter)]
    (-&gt; event
        register-event
        report-scheduling-event
        schedule-event)))</pre></td></tr><tr><td class="docs"><h2>Site Job: Event Manager</h2>

<p>Every hour wake up and make sure that any pending events
for a few hours ahead are queued in quartz.  Keep track of
the end of the last interval that was queued.</p>
</td><td class="codes"></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(def ^{:documentation &quot;How many hours ahead do you want the scheduler to queue tasks?&quot;}
  scheduling-horizon 24)</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(def ^{:documentation &quot;How many hours do you want to schedule at a time?&quot;}
  scheduling-quantum 6)</pre></td></tr><tr><td class="docs"><p>We add a quantum of events to the schedule when the end of the
   last scheduled interval is not beyond the scheduling horizon</p>
</td><td class="codes"><pre class="brush: clojure">(defn- need-to-schedule?
  [last]
  (time/after? (time/plus (time/now) (time/hours scheduling-horizon))
               (.getEnd last)))</pre></td></tr><tr><td class="docs"><p>On startup, schedule out to the scheduling horizon.  Whenever</p>
</td><td class="codes"><pre class="brush: clojure">(defn- next-interval
  [last]
  (if (nil? last)
    (time/interval (time/now)
                   (time/plus (time/now) (time/hours scheduling-horizon)))
    (when (need-to-schedule? last)
      (time/interval (.getEnd last)
                     (time/plus (.getEnd last) (time/hours scheduling-quantum))))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(def user-fields* [:trials :trackers :services :preferences :type :_id])</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn get-expired-events []
  [])</pre></td></tr><tr><td class="docs"><p>Schedule any events pending within the provided interval</p>
</td><td class="codes"><pre class="brush: clojure">(defn schedule-pending-events
  [inter]
  (doseq [user (fetch-models :user {:trackers {:$exists true}} :only user-fields*)]
    (dt/with-user-timezone [user]
      (doseq [trial (trials user)]
        (schedule-reminder trial inter)
        (doseq [tracker (:trackers trial)]
          (schedule-tracker tracker inter)))
      (doseq [tracker (trackers user)]
        (schedule-tracker tracker inter))))
  (doseq [expired (get-expired-events)]
    (cancel-event expired)))</pre></td></tr><tr><td class="docs"><p>Loop over all event generating objects and queue any events
   within the event manager horizon defined by next-interval</p>
</td><td class="codes"><pre class="brush: clojure">(defn event-manager-task
  [context]
  (when (= (prop/get :mode) :dev)
    (when-let [inter (next-interval (:last (q/context-data context)))]
      (log/info &quot;Scheduling new events from &quot; (.getStart inter) &quot; to &quot; (.getEnd inter))
      (schedule-pending-events inter)
      (.put context :last inter))
    context))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(q/defjob EventJob [context]
  (event-manager-task context))</pre></td></tr><tr><td class="docs"><h2>Site Job: Update Manager</h2>
</td><td class="codes"></td></tr><tr><td class="docs"><p>Update resources from 3rd party resources on a daily schedule</p>
</td><td class="codes"><pre class="brush: clojure">(defn update-task
  [context]
  (when (= (prop/get :mode) :prod)
    (println &quot;Running daily download task&quot;)))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(q/defjob UpdateJob [context]
  (update-task context))</pre></td></tr><tr><td class="docs"><h2>Top Level Controller API</h2>
</td><td class="codes"></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn start []
  (q/start)
  (q/schedule-repeated-task [&quot;Reminders&quot; &quot;experiment&quot;]
                            EventJob
                            (q/simple-schedule :hours 1 :forever true))
  (q/schedule-repeated-task [&quot;Updates&quot; &quot;experiment&quot;]
                            UpdateJob
                            (q/cron-schedule &quot;0 30 0 * * ?&quot;)))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn pause []
  (q/pause))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn stop []
  (q/shutdown))</pre></td></tr><tr><td class="docs"><p>CRONTAB Cheat Sheet</p>

<pre><code>* * * * * command to be executed
- - - - -
| | | | |
| | | | +- - - - day of week (0 - 6) (Sunday=0)
| | | +- - - - - month (1 - 12)
| | +- - - - - - day of month (1 - 31)
| +- - - - - - - hour (0 - 23)
+- - - - - - - - minute (0 - 59)

Alarm clock set to 6:30AM
30 6 * * * /home/nano/alarm
</code></pre>
</td><td class="codes"></td></tr><tr><td class="docs"><h2>TESTING</h2>
</td><td class="codes"></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(q/defjob Test1 [context]
  (let [time (.getFireTime context)
	key (.getKey (.getJobDetail context))]
    (println (format &quot;Job [%s] fired at %s&quot; key time))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn run-test [num seconds-interval]
  (q/schedule-repeated-task [&quot;test1&quot; &quot;testgroup&quot;] Test1 num seconds-interval))</pre></td></tr><tr><td class="spacer docs">&nbsp;</td><td class="codes" /></tr><tr><td class="docs"><div class="docs-header"><a class="anchor" href="#experiment.server" name="experiment.server"><h1 class="project-name">experiment.server</h1><a class="toc-link" href="#toc">toc</a></a></div></td><td class="codes" /></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(ns experiment.server
  (:use
   [experiment.infra.middleware]
   [clj-logging-config.log4j])
  (:require
   [noir.server :as server]
   [clojure.tools.logging :as log]
   [experiment.controller :as ctrl]
   [experiment.infra.session :as session]
   [experiment.libs.sms :as sms]
   [experiment.libs.properties :as props]
   [experiment.libs.fulltext :as ft]
   [experiment.models.events :as events]
   [experiment.models.trackers :as track]
   [somnium.congomongo :as mongo]
   [experiment.infra.api]))</pre></td></tr><tr><td class="docs"><p>Define redirection rules for different client types</p>
</td><td class="codes"></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defonce agent-redirect-rules
  (atom
   {#&quot;/app(.*)&quot;
    [;;[:iphone &quot;/iphone/app%s&quot;]
     [:ie6 &quot;/not-supported&quot;]
     [:ie7 &quot;/not-supported&quot;]]}))</pre></td></tr><tr><td class="docs"><p>Redirection rules</p>
</td><td class="codes"><pre class="brush: clojure">(server/add-middleware redirect-url-for-user-agent
                       agent-redirect-rules)</pre></td></tr><tr><td class="docs"><p>Make body available as parsed JSON when mime type is json</p>
</td><td class="codes"><pre class="brush: clojure">(server/add-middleware extract-json-payload)</pre></td></tr><tr><td class="docs"><p>Always track the current user when logged in</p>
</td><td class="codes"><pre class="brush: clojure">(server/add-middleware session-user)</pre></td></tr><tr><td class="docs"><p>Track the current timezone</p>
</td><td class="codes"><pre class="brush: clojure">(server/add-middleware session-timezone-handler)</pre></td></tr><tr><td class="docs"><p>Load all the site views</p>
</td><td class="codes"><pre class="brush: clojure">(server/load-views &quot;clojure/experiment/views/&quot;)</pre></td></tr><tr><td class="docs"><p>Ensure MongoDB users keep alive and retry</p>
</td><td class="codes"><pre class="brush: clojure">(def mongo-options
  (mongo/mongo-options
   :auto-connect-retry true
   :socketKeepAlive true
   :w 1))</pre></td></tr><tr><td class="docs"><p>Store the Noir/Jetty server instance</p>
</td><td class="codes"><pre class="brush: clojure">(defonce noir nil)</pre></td></tr><tr><td class="docs"><hr />

<h2>Start Experiment Server</h2>

<p>Sets up various subsystems, default database connection,
starts Noir server and Quartz scheduler.</p>

<p>Pass in :dev or :prod modes (or pulls from site.properties file)
Be sure to setup the site.properties file before running the site
FYI - site.properties is read at compile time for many subsystems
such as various services, see experiment.libs.properties</p>
</td><td class="codes"></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn start [&amp; [mode]]
  ;; Update mode property for site conditionals
  (when mode (props/put :mode mode))
  ;; Mongo Setup
  (mongo/set-connection!
   (mongo/make-connection
    (props/get :db.name) {} mongo-options))
  ;; Indexing setup
  (ft/start)
  ;; Setup logging
  (let [mode (keyword (or mode (props/get :mode) :dev))]
    (if (= mode :dev)
      (do (server/add-middleware swank-connection)
          (set-loggers! &quot;default&quot;
                        {:level :warn
                         :pattern &quot;%d - %m%n&quot;}
                        &quot;experiment&quot;
                        {:level :debug
                         :pattern &quot;%d - %m%n&quot;}
                        &quot;org.mortbay.log&quot;
                        {:level :error}
                        &quot;org.quartz.core.QuartzSchedulerThread&quot;
                        {:level :error}))
      (set-logger! &quot;default&quot;
		   :level :warn
		   :pattern &quot;%d - %m%n&quot;
                   :out &quot;experiment.log&quot;))
    ;; Setup SMS subsystem
    (sms/set-credentials {:user (props/get :sms.username)
                          :pw (props/get :sms.password)})
    (sms/set-reply-handler 'track/sms-reply-handler)
    ;; Start and save server
    (let [port (Integer. (get (System/getenv) &quot;PORT&quot; &quot;8080&quot;))
	  server (server/start
		  port {:mode (props/get :mode)
			:ns 'experiment
			:session-store (session/mongo-session-store)})]
      (alter-var-root #'noir (fn [old] server)))
    ;; Start event scheduler
    (ctrl/start)))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn stop []
  (ctrl/stop)
  (server/stop noir)
  (alter-var-root #'noir (fn [a] nil)))</pre></td></tr><tr><td class="docs"><p>The default project entry points starts the server in production mode</p>
</td><td class="codes"><pre class="brush: clojure">(defn -main
  []
  (start :prod))</pre></td></tr><tr><td class="spacer docs">&nbsp;</td><td class="codes" /></tr><tr><td class="docs"><div class="docs-header"><a class="anchor" href="#experiment.infra.api" name="experiment.infra.api"><h1 class="project-name">experiment.infra.api</h1><a class="toc-link" href="#toc">toc</a></a></div></td><td class="codes" /></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(ns experiment.infra.api
  (:use noir.core
	experiment.infra.models)
  (:require
   [clojure.data :as data]
   [clojure.string :as str]
   [clojure.tools.logging :as log]
   [cheshire.core :as json]
   [noir.response :as response]
   [noir.request :as request]
   [experiment.libs.fulltext :as ft]))</pre></td></tr><tr><td class="docs"><h2>Be clear about what methods are content pages and which are APIs</h2>
</td><td class="codes"></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn add-meta-status [resp result]
  (assoc resp :status (or (:status (meta result)) 200)))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defmacro defapi [name spec params &amp; body]
  `(defpage ~name ~spec ~params
     (let [result# (do ~@body)]
       (-&gt; (response/json result#)
           (experiment.infra.api/add-meta-status result#)))))</pre></td></tr><tr><td class="docs"><p>Utilities</p>
</td><td class="codes"></td></tr><tr><td class="docs"><p>Convenience for setting kv-pairs at an interior point in a document</p>
</td><td class="codes"><pre class="brush: clojure">(defn modify-response [write]
  (let [cmdRes (.getCachedLastError write)]
    (if (.ok cmdRes)
      {:result &quot;success&quot;}
      {:result &quot;error&quot; :message (.getErrorMessage cmdRes)})))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn- submodel-location [string]
  (map keyword (str/split string #&quot;/&quot;)))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn- root-signature [type id]
  {:type type :_id (deserialize-id id)})</pre></td></tr><tr><td class="docs"><hr />

<h2>Backbone Model CRUD API</h2>

<p>This package implements an interface for Backbone clients or
any front-end that wishes to manipulate Client-Server models.
This API leverages the ClientServer model api in
experiment.infra.models to transform objects and handle CRUD
operations.</p>
</td><td class="codes"></td></tr><tr><td class="docs"><h2>Create - POST</h2>
</td><td class="codes"><pre class="brush: clojure">(defapi backbone-api-create [:post &quot;/api/root/:type&quot;]
  {:keys [type json-payload]}
  (server-&gt;client 
   (try
     (doto (create-model! (new-client-&gt;server (assoc json-payload :type type)))
       ft/index)
     (catch java.lang.Throwable t
       (response/status
        400
        (str &quot;Error: Problem deserializing or saving new model &quot; json-payload))))))</pre></td></tr><tr><td class="docs"><h2>Update - PUT</h2>

<p>The payload consists of :id, :type and all new or changed
fields - but it can consist of all fields too.  The new or
changed fields are saved over the existing model; differences
on the server side (say, implemented by 'hook', are returned
to the client.</p>
</td><td class="codes"></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defapi backbone-api-update-model [:put &quot;/api/root/:type/:id&quot;]
  {:keys [type id json-payload]}
  (let [new-model (client-&gt;server json-payload)
        result (update-model! new-model)]
    (if (string? result) ;; error?
      {}
      (server-&gt;client
       (doto (fetch-model (:type new-model) {:_id (:_id new-model)})
         ft/index)))))</pre></td></tr><tr><td class="docs"><p>Read - GET</p>
</td><td class="codes"><pre class="brush: clojure">(defapi backbone-api-read-all [:get &quot;/api/root/:type&quot;]
  {:keys [type options] :as params}
  (vec
   (map server-&gt;client
        (apply fetch-models type (when options (json/parse-string options true))))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defapi backbone-api-read [:get &quot;/api/root/:type/:id&quot;]
  {:keys [type id] :as params}
  (server-&gt;client
   (fetch-model type {:_id (deserialize-id id)})))</pre></td></tr><tr><td class="docs"><p>Delete - DELETE</p>
</td><td class="codes"><pre class="brush: clojure">(defapi backbone-api-delete-id [:delete &quot;/api/root/:type/:id&quot;]
  {:keys [type id]}
  (doto {:type type :_id (deserialize-id id)}
    ft/delete
    delete-model!))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defapi backbone-api-delete-model [:delete &quot;/api/root/:type&quot;]
  {:keys [type json-payload]}
  (doto (client-&gt;server json-payload)
    ft/delete
    delete-model!))</pre></td></tr><tr><td class="docs"><hr />

<h2>Backbone SubModel CRUD API</h2>
</td><td class="codes"></td></tr><tr><td class="docs"><p>Create Submodel</p>

<ul>
<li>Submodels adhere to client-server protocol</li>
<li>Submodels must have type for dispatch</li>
<li>Submodels must have a unique ID, used to construct path inside parent model</li>
<li>Submodels use the :id field instead of :_id indicating they are not stored
directly in Mongo.</li>
<li>Submodel IDs are SHA256 strings prefixed by SM for visual clarity</li>
</ul>
</td><td class="codes"></td></tr><tr><td class="docs"><h3>CREATE Submodel - add a submodel to embedded collection</h3>

<p>Since it is the temporary model doing the POST, we use the
instance embed API, but without the ID</p>
</td><td class="codes"><pre class="brush: clojure">(defapi backbone-sub-api-create [:post &quot;/api/embed/:mtype/:mid/*&quot;]
  {:keys [mtype mid * json-payload] :as args}
  (let [parent (resolve-dbref mtype mid)
        location (submodel-location *)]
    (when-let [submodel
               (and parent
                    (new-client-&gt;server
                     (assoc json-payload
                       :submodel true)))]
      (server-&gt;client
       (let [model (create-submodel! parent location submodel)]
         (ft/index model)
         model)))))</pre></td></tr><tr><td class="docs"><h3>GET Submodel</h3>
</td><td class="codes"><pre class="brush: clojure">(defapi backbone-sub-api-read [:get &quot;/api/embed/:mtype/:mid/*&quot;]
  {:keys [mtype mid *] :as args}
  (let [location (submodel-location *)]
    (server-&gt;client
     (get-submodel (root-signature mtype mid) location))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defapi backbone-sub-api-read-all [:get &quot;/api/embed/coll/:mtype/:mid/*&quot;]
  {:keys [mtype mid *] :as args}
  (let [location (submodel-location *)]
    (server-&gt;client
     (vals (get-submodel (root-signature mtype mid) location)))))</pre></td></tr><tr><td class="docs"><h3>UPDATE Submodel</h3>
</td><td class="codes"><pre class="brush: clojure">(defapi backbone-sub-api-update [:put &quot;/api/embed/:mtype/:mid/*&quot;]
  {:keys [mtype mid * id json-payload] :as args}
  (let [location (submodel-location *)
        submod (client-&gt;server (assoc json-payload :submodel true))]
    (set-submodel! (root-signature mtype mid) location submod)
    (server-&gt;client 
     (get-submodel (root-signature mtype mid) location))))</pre></td></tr><tr><td class="docs"><h3>DELETE Submodel</h3>
</td><td class="codes"><pre class="brush: clojure">(defapi backbone-sub-api-delete-id [:delete &quot;/api/embed/:mtype/:mid/*&quot;]
  {:keys [mtype mid *]}
  (let [location (submodel-location *)]
    (do (delete-submodel! (root-signature mtype mid) location)
        true)))</pre></td></tr><tr><td class="spacer docs">&nbsp;</td><td class="codes" /></tr><tr><td class="docs"><div class="docs-header"><a class="anchor" href="#experiment.infra.auth" name="experiment.infra.auth"><h1 class="project-name">experiment.infra.auth</h1><a class="toc-link" href="#toc">toc</a></a></div></td><td class="codes" /></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(ns experiment.infra.auth
  (:use somnium.congomongo)
  (:require [experiment.infra.session :as session]
	    [clojure.string :as str]
	    [noir.util.crypt :as crypt]))</pre></td></tr><tr><td class="docs"><p>Authentication</p>
</td><td class="codes"></td></tr><tr><td class="docs"><p>Set the salt and encrypt the user's plaintext password</p>
</td><td class="codes"><pre class="brush: clojure">(defn set-user-password
  [user plaintext]
  (assoc user
    :password (crypt/encrypt plaintext)))</pre></td></tr><tr><td class="docs"><p>Session Authentication and Common State</p>

<p>NOTE: Models are not defined yet, so we'll special case
support for the current-user</p>
</td><td class="codes"></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn valid-password? [user plaintext]
  (crypt/compare plaintext (:password user)))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn lookup-user-for-auth [id]
  (or (fetch-one :user :where {:username id})
      (fetch-one :user :where {:email id})))</pre></td></tr><tr><td class="docs"><p>Due to the use of middleware to track the user, we need to
   ensure that any handler redirects after log-ins</p>
</td><td class="codes"><pre class="brush: clojure">(defn login
  [auth]
  (let [user (lookup-user-for-auth (:username auth))]
    (if (valid-password? user (:password auth))
      (do (session/clear!)
	  (session/put! :logged-in? true)
	  (session/put! :userid (:_id user))
	  user)
      nil)))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn logout []
  (session/clear!))</pre></td></tr><tr><td class="spacer docs">&nbsp;</td><td class="codes" /></tr><tr><td class="docs"><div class="docs-header"><a class="anchor" href="#experiment.infra.handlebar" name="experiment.infra.handlebar"><h1 class="project-name">experiment.infra.handlebar</h1><a class="toc-link" href="#toc">toc</a></a></div></td><td class="codes" /></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(ns experiment.infra.handlebar
  (:use handlebars.templates
        experiment.infra.api
        noir.core)
  (:require [noir.response :as response]))</pre></td></tr><tr><td class="docs"><p>A handler to define a template renderer that we can
evalute on the server w/ an object or render to the client
as a script template (or dynamically via a loader?)</p>
</td><td class="codes"></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defpage get-templates [:get &quot;/api/template/get/:name&quot;]
  {:keys [name]}
  (response/content-type
   &quot;text/x-jquery-html&quot;
   (html-template (get-template name))))</pre></td></tr><tr><td class="spacer docs">&nbsp;</td><td class="codes" /></tr><tr><td class="docs"><div class="docs-header"><a class="anchor" href="#experiment.infra.middleware" name="experiment.infra.middleware"><h1 class="project-name">experiment.infra.middleware</h1><a class="toc-link" href="#toc">toc</a></a></div></td><td class="codes" /></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(ns experiment.infra.middleware
  (:require
   [clojure.tools.logging :as log]
   [somnium.congomongo :as mongo]
;;   [experiment.infra.session :as session2]
   [noir.session :as session]
   [noir.request :as req]
   [noir.response :as resp]
   [cheshire.core :as json]
   [clojure.string :as str]))</pre></td></tr><tr><td class="docs"><h1>Middleware: Support breaking to swank in handlers</h1>
</td><td class="codes"></td></tr><tr><td class="docs"><p>RING Middleware: Binds <em>current-connection</em> to the
   swank connection that was active at the time the server
   was started.</p>
</td><td class="codes"><pre class="brush: clojure">(defn swank-connection
  [handler] 
  (let [conn swank.core.connection/*current-connection*] 
    (fn [request] 
      (binding [swank.core.connection/*current-connection* conn] 
        (handler request)))))</pre></td></tr><tr><td class="docs"><h1>Middleware: Bind the current user</h1>
</td><td class="codes"></td></tr><tr><td class="docs"><h1>User fetcher: (fn & {:keys [id username]}) => canonical user object</h1>

<p>  defined by downstream dependencies to set the current user</p>
</td><td class="codes"><pre class="brush: clojure">(def user-fetcher nil)</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn set-user-fetcher [ffn]
  (assert (fn? ffn))
  (alter-var-root #'user-fetcher (fn [old] ffn)))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(def ^{:dynamic true} *current-user* nil)</pre></td></tr><tr><td class="docs"><p>RING MIDDLEWARE: Binds the current session user, when logged in.
   Use tools in infra/sessions and infra/auth to login and logout
   users</p>
</td><td class="codes"><pre class="brush: clojure">(defn session-user
  [handler]
  (fn [req]
    (let [userid (session/get :userid)]
      (binding [*current-user*
                (and userid user-fetcher
                     (user-fetcher :id userid))]
        (handler req)))))</pre></td></tr><tr><td class="docs"><h1>Middleware: Session timezone</h1>
</td><td class="codes"></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(def ^{:dynamic true} *timezone* nil)</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn user-timezone []
  (when *current-user*
    (let [tz (or (get-in *current-user* [:preferences :tz])
                 (get-in *current-user* [:preferences :tz_default]))]
      (when (&gt; (count tz) 0)
        (org.joda.time.DateTimeZone/forID tz)))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn user-timezone-default! [default]
  (when *current-user*
    (println &quot;Setting default for &quot; (:username *current-user*))
    (somnium.congomongo/update! :user
                                {:_id (:_id *current-user*)}
                                {:$set {:preferences.tz_default default}}
                                :upsert false)))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn request-timezone [req]
  (let [stz (session/get :timezone)
        rtz (get-in req [:params :_timezone])]
    (when (and (not stz) rtz)
      (session/put! :timezone rtz))
    (org.joda.time.DateTimeZone/forID (or stz rtz nil))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn compute-timezone [req]
  (let [user-tz (user-timezone)
        req-tz (request-timezone req)
        default (org.joda.time.DateTimeZone/getDefault)]
    (when (and (not user-tz) req-tz)
      (user-timezone-default! req-tz))
    (if-let [tz (or user-tz req-tz)]
      (or tz default)
      default)))</pre></td></tr><tr><td class="docs"><p>RING Middleware: Binds <em>timezone</em> to a timezone based on the
   following algorithm (assumes session-user is set in chain)
   - User object timezone (Home TZ explicitly set by user)
   - Detected browser timezone (if set on session by javascript)
   - Server timezone (default)</p>
</td><td class="codes"><pre class="brush: clojure">(defn session-timezone-handler
  [handler]
  (fn [req]
    (let [tz (compute-timezone req)]
      (binding [*timezone* tz]
        (handler req)))))</pre></td></tr><tr><td class="docs"><p>Use active session TZ; default to server's TZ</p>
</td><td class="codes"><pre class="brush: clojure">(defn session-timezone
  []
  (or *timezone*
      (org.joda.time.DateTimeZone/getDefault)))</pre></td></tr><tr><td class="docs"><p>Server TZ</p>
</td><td class="codes"><pre class="brush: clojure">(defn server-timezone
  []
  (org.joda.time.DateTimeZone/getDefault))</pre></td></tr><tr><td class="docs"><h1>Middleware: pre-parse JSON payloads</h1>
</td><td class="codes"></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn- extract-json [req]
  (if-let [ctype (get-in req [:headers &quot;content-type&quot;])]
    (if (and (string? ctype) (re-find #&quot;application/json&quot; ctype)
             (not (get-in req [:params :json-payload])))
      (update-in req [:params] assoc :json-payload
                 (try
                   (let [serialized (slurp (:body req))]
;;                     (println &quot;Serialized: &quot; serialized)
                     (json/parse-string serialized true))
                   (catch java.lang.Throwable e
                     (log/error &quot;Ignoring JSON payload&quot;))))
      req)
    req))</pre></td></tr><tr><td class="docs"><p>RING MIDDLEWARE: When the content type is application/json,
   parse the data and make available in parameter list as :json-payload</p>
</td><td class="codes"><pre class="brush: clojure">(defn extract-json-payload
  [handler]
  (fn [req]
    (handler (extract-json req))))</pre></td></tr><tr><td class="docs"><h1>Middleware: redirect to a URL based on the user agent</h1>

<ul>
<li>Very special purpose facility</li>
<li>Be nice to make more general?</li>
</ul>
</td><td class="codes"></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(def user-agent-names
  {:iphone #&quot;.*iPhone.*&quot;
   :msie #&quot;.*MSIE.*&quot;
   :ie&lt;8 #&quot;.*MSIE\s[1-7].*&quot;
   :ie8 #&quot;.*MSIE\s8.*&quot;
   :ie9 #&quot;.*MSIE\s9.*&quot;
   :safari #&quot;.*Safari.*&quot;
   :mozilla #&quot;.*Mozilla.*&quot;
   :firefox #&quot;.*Firefox.*&quot;
   :droid1 #&quot;.*Android\s1.*&quot;
   :droid2 #&quot;.*Android\s2.*&quot;})</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn- multiple-matches-error [matches]
  (throw
   (java.lang.Error.
    (format &quot;Multiple matches: %s&quot; (map first matches)))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn- match-agent-and-rewrite [agent-string matches [agent-tag rewrite]]
  (let [regex (user-agent-names agent-tag)]
    (when (and regex (re-find regex agent-string))
      (apply format rewrite matches))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn- match-agent [agent-string matches agent-rules]
  (some (partial match-agent-and-rewrite agent-string matches) agent-rules))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn- match-uri-prefix [uri rule]
  (let [[prefix-regex agents] rule]
    (when-let [matches (re-matches prefix-regex uri)]
      [prefix-regex (rest matches) agents])))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn- match-prefix [uri rules]
  (let [matches (keep (partial match-uri-prefix uri) rules)]
    (cond (= (count matches) 0) nil
	  (&gt; (count matches) 1) (multiple-matches-error matches)
	  true (rest (first matches)))))</pre></td></tr><tr><td class="docs"><p>RING MIDDLEWARE: When the User Agent matches the provided rules,
   rewrite the URL appropriately and redirect to it.
   [base agent target]</p>
</td><td class="codes"><pre class="brush: clojure">(defn redirect-url-for-user-agent
  [handler prefix-map]
  (fn [req]
    (let [uri (:uri req)
	  user-agent ((:headers req) &quot;user-agent&quot;)
	  prefix-rule-map (if (= (type prefix-map) clojure.lang.Atom)
			    (deref prefix-map)
			    prefix-map)]
      (if-let [[matches agent-rules] (match-prefix uri prefix-rule-map)]
	(if-let [new-uri (match-agent user-agent matches agent-rules)]
	  (do (println &quot;Agent redirect of &quot; uri &quot; to &quot; new-uri)
	      (resp/redirect new-uri))
	  (handler req))
	(handler req)))))</pre></td></tr><tr><td class="spacer docs">&nbsp;</td><td class="codes" /></tr><tr><td class="docs"><div class="docs-header"><a class="anchor" href="#experiment.infra.models" name="experiment.infra.models"><h1 class="project-name">experiment.infra.models</h1><a class="toc-link" href="#toc">toc</a></a></div></td><td class="codes" /></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(ns experiment.infra.models
  (:use
   noir.core)
  (:require
   clojure.set
   [clojure.string :as str]
   [clojure.walk :as walk]
   [clojure.tools.logging :as log]
   [experiment.libs.datetime :as dt]
   [somnium.congomongo :as mongo]
   [noir.response :as response]
   [noir.request :as request]
   [clodown.core :as md]
   [experiment.infra.session :as session])
  (:import [org.bson.types ObjectId]
           [com.mongodb DBRef]))</pre></td></tr><tr><td class="docs"><hr />

<h2>Server-Client Model Framework</h2>
</td><td class="codes"></td></tr><tr><td class="docs"><p>This framework provides hooks for different data
models, implemented as standard maps, with a
convention of :type as the type specifier and
client-side ID of :id and server-side id of :_id
The APIs included here are somewhat MongoDB specific
still, but provide a good baseline abstraction for
models that live in a document DB and have different
behavior and valid slots in the server or client context.</p>
</td><td class="codes"></td></tr><tr><td class="docs"><p>A predicate to test that we have a valid parent model:
   :_id field ala mongo with valid ObjectID
   :type field indicating type of the model</p>
</td><td class="codes"><pre class="brush: clojure">(defn model?
  [model]
  (and (:type model)
       (:_id model)
       (instance? ObjectId (:_id model))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(declare embedded-objectid?)</pre></td></tr><tr><td class="docs"><p>A predict to test that we have a valid submodel</p>
</td><td class="codes"><pre class="brush: clojure">(defn submodel? 
  [submodel]
  (and (:type submodel)
       (or (:submodel submodel)
           (and (:id submodel)
                (re-find #&quot;SM&quot; (:id submodel))))))</pre></td></tr><tr><td class="docs"><p>Enforces invariant properties of a specific model.  Model
   creation and updating both must satisfy this test for
   mutation to proceed.  Test that appropriate values
   exist and have coherent values.</p>
</td><td class="codes"><pre class="brush: clojure">(defmulti valid-model? 
  (fn [model] (when-let [type (:type model)]
                (keyword type))))</pre></td></tr><tr><td class="docs"><p>Which parameters coming from a client are the IDs of
   foreign objects that should be stored as DB refs?</p>
</td><td class="codes"><pre class="brush: clojure">(defmulti db-reference-params
  (fn [model] (when-let [type (:type model)]
                (keyword type))))</pre></td></tr><tr><td class="docs"><p>Maps a model to a mongodb collection.  Embedded models
   are TBD, but I imagine we'll return a vector that includes
   the parent's collection + id + path</p>
</td><td class="codes"><pre class="brush: clojure">(defmulti model-collection 
  (fn [model] (when-let [type (:type model)]
                (keyword type))))</pre></td></tr><tr><td class="docs"><p>Which server-side raw or derived (via hook) keys 
   to send to the client.  Default is to be permissive.</p>
</td><td class="codes"><pre class="brush: clojure">(defmulti public-keys
  (fn [model] (when-let [type (:type model)]
                (keyword type))))</pre></td></tr><tr><td class="docs"><p>Performs a select-keys on client data so we don't store
   illegal client-side slots on the server.</p>
</td><td class="codes"><pre class="brush: clojure">(defmulti import-keys 
  (fn [model] (when-let [type (:type model)]
                (keyword type))))</pre></td></tr><tr><td class="docs"><p>Performs a select-keys on client data so we don't store
   illegal client-side slots on the server.</p>
</td><td class="codes"><pre class="brush: clojure">(defmulti index-keys 
  (fn [model] (when-let [type (:type model)]
                (keyword type))))</pre></td></tr><tr><td class="docs"><p>An optional function that is the identity fn by default which
   takes the server model and transforms it to a public/client
   view before serialization</p>
</td><td class="codes"><pre class="brush: clojure">(defmulti server-&gt;client-hook
  (fn [model]
    (keyword (:type model))))</pre></td></tr><tr><td class="docs"><p>The import hook runs on the internal representation of the model
   after import but before the object is saved to the underlying store</p>
</td><td class="codes"><pre class="brush: clojure">(defmulti client-&gt;server-hook
  (fn [model]
    (keyword (:type model))))</pre></td></tr><tr><td class="docs"><p>For embedded objects we expose a generic API for creating objects
   from client arguments dispatching on the :type field of the arguments</p>
</td><td class="codes"><pre class="brush: clojure">(defmulti make-annotation
  (fn [model]
    (keyword (:type model))))</pre></td></tr><tr><td class="docs"><h2>Default Model behaviors</h2>
</td><td class="codes"></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defmethod valid-model? :default
  [model]
  true)</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defmethod model-collection :default
  [model]
  (if (map? model)
    (do (assert (:type model))
        (name (:type model)))
    (do (assert (or (string? model) (keyword? model)))
        (name model))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defmethod db-reference-params :default
  [model]
  [])</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defmethod public-keys :default
  [model]
  nil)</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defmethod import-keys :default
  [model]
  nil)</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defmethod index-keys :default
  [model]
  nil)</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defmethod server-&gt;client-hook :default
  [model]
  model)</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defmethod client-&gt;server-hook :default
  [model]
  model)</pre></td></tr><tr><td class="docs"><h2>MongoDB Helpers</h2>
</td><td class="codes"></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn objectid? [id]
  (= (type id) ObjectId))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn dbref? [ref]
  (= (type ref) DBRef))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn embedded-objectid? [id]
  (and (string? id)
       (= (first id) \S)
       (= (second id) \M)))</pre></td></tr><tr><td class="docs"><p>Convert a MongoDB ID for client use</p>
</td><td class="codes"><pre class="brush: clojure">(defn serialize-id
  [id]
  (assert (or (objectid? id) (embedded-objectid? id)))
  (str id))</pre></td></tr><tr><td class="docs"><p>Convert a client ID reference to an ObjectId</p>
</td><td class="codes"><pre class="brush: clojure">(defn deserialize-id
  [id]
  (assert (string? id))
  (if (embedded-objectid? id)
    id
    (mongo/object-id id)))</pre></td></tr><tr><td class="docs"><p>Convert a DBRef object to a pair referencing a namespace and UID</p>
</td><td class="codes"><pre class="brush: clojure">(defn- serialize-dbref
  [dbref]
  (assert (instance? DBRef dbref))
  (let [ref (.getRef dbref)
	id (.getId dbref)]
    (when (and ref id)
      [ref (.toString id)])))</pre></td></tr><tr><td class="docs"><p>Convert a client-side object reference pair to a DBRef</p>
</td><td class="codes"><pre class="brush: clojure">(defn- deserialize-dbref
  [ref]
  (assert (and (= (count ref) 2) (every? string? ref)))
  (mongo/db-ref (first ref) (mongo/object-id (second ref))))</pre></td></tr><tr><td class="docs"><h2>Model import/export handlers</h2>
</td><td class="codes"></td></tr><tr><td class="docs"><h3>Convert object IDs to/from client</h3>
</td><td class="codes"></td></tr><tr><td class="docs"><p>Export a local model-id as a foreign ID</p>
</td><td class="codes"><pre class="brush: clojure">(defn serialize-model-id
  [smodel]
  (if (:_id smodel) ;; primary model
    (dissoc (assoc smodel :id (serialize-id (:_id smodel))) :_id)
    smodel ;; submodel is already serialized))</pre></td></tr><tr><td class="docs"><p>Import a foregin model-id as a local ID</p>
</td><td class="codes"><pre class="brush: clojure">(defn deserialize-model-id
  [cmodel]
  (if (:submodel cmodel)
    cmodel
    (dissoc (assoc cmodel :_id (deserialize-id (:id cmodel))) :id)))</pre></td></tr><tr><td class="docs"><h3>Handle embedded DBRefs</h3>
</td><td class="codes"></td></tr><tr><td class="docs"><p>If the object is a DBRef, convert to client format</p>
</td><td class="codes"><pre class="brush: clojure">(defn- serialize-ref
  [ref]
  (if (mongo/db-ref? ref)
    (serialize-dbref ref)
    ref))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn serialize-model-refs [smodel]
  (walk/postwalk serialize-ref smodel))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn- deserialize-model-ref [model key]
  (if-let [[ns id] (model key)]
    (if (and ns id)
      (assoc model key (deserialize-dbref [ns id]))
      model)
    model))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn deserialize-model-refs [cmodel]
  &quot;Import model references from the client&quot;
  (reduce deserialize-model-ref cmodel (db-reference-params cmodel)))</pre></td></tr><tr><td class="docs"><h3>Utilities for augmenting fields</h3>
</td><td class="codes"></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn markdown-convert* [model k]
  (let [new-key (keyword (str (name k) &quot;-html&quot;))
        orig (model k)]
    (if (&gt; (count orig) 1)
      (assoc model new-key (md/mdp orig))
      (assoc model new-key &quot;&lt;p&gt;&lt;p/&gt;&quot;))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn markdown-convert [model k &amp; ks]
  (reduce markdown-convert* model (cons k ks)))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn ref-oid [ref]
  (when ref
    (cond (dbref? ref) (.getId ref)
          (model? ref) (:_id ref))))</pre></td></tr><tr><td class="docs"><p>Converts a user reference field to a boolean
   if field reference(s) matches user or current-user</p>
</td><td class="codes"><pre class="brush: clojure">(defn owner-as-bool
  [model field &amp; {:keys [user admins] :or {admins [] user (session/current-user)}}]
  (let [uid (:_id user)
        value (model field)
        users (concat (cond (nil? value)
                            (list)
                            (dbref? value)
                            (list value)
                            true
                            value)
                      admins)]
    (if (&gt; (count (filter #(= uid (ref-oid %)) users)) 0)
      (assoc model field true)
      (assoc model field false))))</pre></td></tr><tr><td class="docs"><h3>Filter public-keys on import/export for safety</h3>
</td><td class="codes"></td></tr><tr><td class="docs"><p>Must define public-keys for safety purposes</p>
</td><td class="codes"><pre class="brush: clojure">(defn filter-public-keys
  [cmodel]
  (if-let [keys (public-keys cmodel)]
    (select-keys cmodel (conj keys :_id :id :type))
    (throw (java.lang.Error. (str &quot;public-keys not defined for &quot; (:type cmodel))))))</pre></td></tr><tr><td class="docs"><p>Must define import-keys for safety purposes</p>
</td><td class="codes"><pre class="brush: clojure">(defn filter-import-keys
  [cmodel]
  (if-let [keys (import-keys cmodel)]
    (select-keys cmodel (conj keys :_id :id :type :submodel))
    (throw (java.lang.Error. (str &quot;import-keys not defined for &quot; (:type cmodel))))))</pre></td></tr><tr><td class="docs"><p>Return a Mongo DBRef for a model object</p>
</td><td class="codes"><pre class="brush: clojure">(defn as-dbref
  ([model]
     (let [{:keys [type _id]} model]
       (assert (and type _id))
       (mongo/db-ref type _id)))
  ([name id]
     (mongo/db-ref name id)))</pre></td></tr><tr><td class="docs"><p>Ensure an ID string is an ObjectID</p>
</td><td class="codes"><pre class="brush: clojure">(defn as-oid
  [id]
  (cond (objectid? id) id
	(string? id) (mongo/object-id id)
	true (assert (str &quot;Unrecognized id: &quot; id))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn oid? [id]
  (objectid? id))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn resolve-dbref
  ([ref]
     (if (mongo/db-ref? ref)
       (somnium.congomongo.coerce/coerce (.fetch ^DBRef ref) [:mongo :clojure])
       ref))
  ([coll id]
     (assert (or (keyword? coll) (string? coll)))
     (mongo/fetch-one coll :where {:_id (as-oid id)})))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn safe-resolve-dbref [&amp; args]
  (try
    (apply resolve-dbref args)
    (catch java.lang.Throwable e nil)))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn assign-uid [model]
  (if (not (:id model))
    (assoc model :id (str &quot;SM&quot; (ObjectId/get)))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn embed-dbrefs [model]
  (clojure.walk/prewalk
   (fn [node]
     (if (dbref? node)
       (resolve-dbref node)
       node))
   model))</pre></td></tr><tr><td class="docs"><p>Extend DBRef with IDeref protocol for dereferencing?</p>

<p>(extend DBRef
  clojure.lang.IDeref
  {:deref resolve-dbref})</p>
</td><td class="codes"></td></tr><tr><td class="docs"><h3>Support for sub-objects and partial object updates</h3>
</td><td class="codes"></td></tr><tr><td class="docs"><p>Resolve string or keyword location and indirect into
   a model object so we can extract sub-content from the results
   of a mongo query using said location</p>
</td><td class="codes"><pre class="brush: clojure">(defn lookup-location
  [model location]
  (cond (string? location)
        (let [fields (str/split location #&quot;\.&quot;)]
          (get-in model (map keyword fields)))
        (keyword? location)
        (model location)
        (sequential? location)
        (get-in model location)))</pre></td></tr><tr><td class="docs"><p>Make a mongo-friendly sub-object path from a dotted location
   string, an array of keys</p>
</td><td class="codes"><pre class="brush: clojure">(defn serialize-path
  ([location leaf]
     (if (sequential? location)
       (serialize-path (concat location (list leaf)))
       (serialize-path (list (name location) (name leaf)))))
  ([location]
     (if (sequential? location)
       (str/join \. (map name location))
       location)))</pre></td></tr><tr><td class="docs"><p>Return a map from model keys to keys that are paths
   to the keys of an embedded model</p>
</td><td class="codes"><pre class="brush: clojure">(defn- serialize-slot-paths
  [model path]
  (zipmap (keys model)
          (map (comp (partial serialize-path path) name)
               (keys model))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn null-value-keys [model]
  (map first (filter #(nil? (second %)) model)))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defmacro nil-on-empty [body]
  `(let [result# ~body]
     (when (not (empty? result#))
       result#)))</pre></td></tr><tr><td class="docs"><p>Convert our options to an mongo argument list</p>
</td><td class="codes"><pre class="brush: clojure">(defn translate-options
  [options]
  (let [lead (first options)]
    (assert lead)
    (cond (or (keyword? lead) (string? lead))
          (cond (empty? (rest options))
                (list lead)
                (map? (second options))
                (concat (list lead :where)
                        (rest options))
                true options)
          (map? lead)
          (concat (list (:type lead) :where (dissoc lead :type))
                  (rest options)))))</pre></td></tr><tr><td class="docs"><h3>Handling conversions from canonical clojure form to/from mongo</h3>
</td><td class="codes"></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn mongo-&gt;canonical* [obj]
  (cond (dt/date? obj)
        (dt/as-joda obj)
        true obj))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn mongo-&gt;canonical [obj]
  (walk/postwalk mongo-&gt;canonical* obj))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn canonical-&gt;mongo* [obj]
  (cond (dt/date? obj) (dt/as-java obj)
        true obj))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn canonical-&gt;mongo [obj]
  (walk/postwalk canonical-&gt;mongo* obj))</pre></td></tr><tr><td class="docs"><h3>Handle canonical server form to client transforms</h3>
</td><td class="codes"></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn server-&gt;client*
  ([node]
     (server-&gt;client* node false))
  ([node force]
     (if (or (model? node) (submodel? node) force)
       (-&gt; node
           server-&gt;client-hook
           filter-public-keys)
       node)))</pre></td></tr><tr><td class="docs"><p>Convert a server-side object into a map that is ready
   for JSON encoding and use by a client of the system</p>
</td><td class="codes"><pre class="brush: clojure">(defn server-&gt;client
  ([smodel]
     (server-&gt;client smodel false))
  ([smodel force]
     (cond (empty? smodel)
           nil
           (map? smodel)
           (-&gt; (if force
                 (server-&gt;client* smodel true)
                 (walk/postwalk server-&gt;client* smodel))
               serialize-model-id
               serialize-model-refs)
           (sequential? smodel)
           (vec (doall (map server-&gt;client smodel)))
           true
           (response/status
            500
            (format &quot;Cannot export model %s&quot; smodel)))))</pre></td></tr><tr><td class="docs"><p>Take a map transmitted from a client and convert it
   into a server-side object suitable to be stored or
   manipulated</p>
</td><td class="codes"><pre class="brush: clojure">(defn client-&gt;server
  [cmodel]
  (-&gt; cmodel
      filter-import-keys
      deserialize-model-id 
      deserialize-model-refs
      client-&gt;server-hook))</pre></td></tr><tr><td class="docs"><p>When a client creates a new object on the server, we
   don't transform the :id field</p>
</td><td class="codes"><pre class="brush: clojure">(defn new-client-&gt;server
  [cmodel]
  (-&gt; cmodel
      filter-import-keys
      deserialize-model-refs
      client-&gt;server-hook))</pre></td></tr><tr><td class="docs"><h3>Merge over updates for API</h3>
</td><td class="codes"></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn update-by-modifiers
  ([model]
     (let [bare (dissoc model :_id :id :type)]
       {:$set (canonical-&gt;mongo bare)}))
  ([submodel path]
     {:$set (clojure.set/rename-keys
             (canonical-&gt;mongo submodel)
             (serialize-slot-paths submodel path))}))</pre></td></tr><tr><td class="docs"><hr />

<h2>Client-Server Models API</h2>
</td><td class="codes"></td></tr><tr><td class="docs"><p>Basic API (see implementations below)</p>
</td><td class="codes"><pre class="brush: clojure">(declare create-model! fetch-model fetch-models
         update-model! modify-model! delete-model!)</pre></td></tr><tr><td class="docs"><p>Legacy</p>
</td><td class="codes"><pre class="brush: clojure">(defmulti annotate-model! (fn [type field anndo] (keyword type)))</pre></td></tr><tr><td class="docs"><p>Model Evolution Hooks</p>
</td><td class="codes"></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defmulti create-model-hook (comp keyword :type))
(defmulti update-model-hook (comp keyword :type))
(defmulti delete-model-hook (comp keyword :type))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defmethod create-model-hook :default
  [model]
  (update-model-hook model))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defmethod update-model-hook :default
  [model]
  model)</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defmethod delete-model-hook :default
  [model]
  model)</pre></td></tr><tr><td class="docs"><p>Model CRUD API implementation</p>
</td><td class="codes"></td></tr><tr><td class="docs"><p>Create a new model in the database using all the model hooks defined
   above</p>
</td><td class="codes"><pre class="brush: clojure">(defn create-model!
  [model]
  (assert (not (model? model)))
  (if (valid-model? model)
    (mongo/insert! (model-collection model)
                   (canonical-&gt;mongo
                    (create-model-hook model)))
    &quot;Invalid Model&quot;))</pre></td></tr><tr><td class="docs"><p>Update model merges the provided key-value pairs with the
   database key-value pair set.  Setting any key-value pair
   with embedded objects will overwrite the entire set (i.e.
   no merging or appending of elements in a value</p>
</td><td class="codes"><pre class="brush: clojure">(defn update-model!
  [model]
  (if (and (:_id model) (:type model))
    (let [result (mongo/update! (model-collection model)
                                (select-keys model [:_id])
                                (update-by-modifiers
                                 (update-model-hook model))
                                :upsert false)]
      (if-let [err (.getError result)]
        &quot;DB Error&quot;
        true))
    &quot;Invalid Model&quot;))</pre></td></tr><tr><td class="docs"><p>A cheap hack to open up the use of raw Mongo APIs for modifying
   a document.</p>
</td><td class="codes"><pre class="brush: clojure">(defn modify-model!
  [model modifier]
  (assert (map? modifier))
  (mongo/update! (model-collection model)
                 (select-keys model [:_id])
                 (canonical-&gt;mongo modifier)
                 :upsert false))</pre></td></tr><tr><td class="docs"><p>Get a model from the database</p>
</td><td class="codes"><pre class="brush: clojure">(defn fetch-model
  [&amp; options]
  (nil-on-empty
   (let [[type &amp; args] (translate-options options)]
     (mongo-&gt;canonical
      (apply mongo/fetch-one (model-collection type) args)))))</pre></td></tr><tr><td class="docs"><p>Get a seq of models from the database</p>
</td><td class="codes"><pre class="brush: clojure">(defn fetch-models
  [&amp; options]
  (let [[type &amp; args] (translate-options options)]
    (mongo-&gt;canonical
     (apply mongo/fetch (model-collection type) args))))</pre></td></tr><tr><td class="docs"><p>Delete a model from the database; must have a valid :_id</p>
</td><td class="codes"><pre class="brush: clojure">(defn delete-model!
  [model]
  (delete-model-hook model)
  (mongo/destroy! (model-collection model) (select-keys model [:_id]))
  true)</pre></td></tr><tr><td class="docs"><hr />

<h2>Client-Server SubModels API</h2>

<p>The Submodel API provides the same abstraction over a document
database as the primary CRUD API, but allows the addition of
a location specifier which operates on embedded objects.</p>

<p>Writes to mongo go through create-model-hook or update-model-hook
  then canonical->mongo
Reads from mongo go through mongo->canonical</p>

<p>(set-submodel! parent "profile.addresses.id"
               {:type "address" :name "Joe User"})
=>
{:foo {:bar {:id {type "address" :name "Joe User"}}}}</p>
</td><td class="codes"></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(declare create-submodel! set-submodel!
         get-submodel get-submodels
         delete-submodel!)</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn create-submodel!
  [parent location submodel]
  (assert (and (model? parent) (:type submodel)))
  (let [new (create-model-hook (assign-uid submodel))
        pcoll (model-collection parent)
        pref (select-keys parent [:_id :type])
        path (serialize-path location (:id new))]
    ;; Ensure we have a fresh target to insert into
    (mongo/update! pcoll pref {:$set {path {}}})
    ;; Insert all the slots
    (mongo/update! pcoll pref (update-by-modifiers new path))
    ;; Return the new model
    new))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn get-submodel
  ([parent location]
     (assert (and (:type parent) (:_id parent)))
     (let [parent (mongo/fetch-one (model-collection parent)
                                :where (select-keys parent [:_id])
                                :only [(serialize-path location)])]
       (mongo-&gt;canonical
        (lookup-location parent location)))))</pre></td></tr><tr><td class="docs"><p>(defn get-submodels
 [model type]
 (mongo/fetch (model-collection model)
              :where (select-keys model [:_id])
              :only (serialize-path (submodel-path model {:type type}))))</p>
</td><td class="codes"></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn set-submodel!
  [model location submodel]
  (let [updates (update-by-modifiers
                 (update-model-hook submodel)
                 location)]
    (mongo/update! (model-collection model)
                   (select-keys model [:_id])
                   updates                 
                   :upsert false)))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn delete-submodel!
  [model location]
  (delete-model-hook
   (get-submodel model location))
  (mongo/update! (model-collection model)
                 (select-keys model [:_id])
                 {:$unset {(serialize-path location) 1}}
                 :upsert false))</pre></td></tr><tr><td class="docs"><h2>Misc Store Utilities</h2>
</td><td class="codes"></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn unset-collection-field 
  ([type field]
     (unset-collection-field type field {}))
  ([type field criteria]
     (mongo/update! (model-collection {:type type})
		    criteria {:$unset {field 1}} :multiple true)))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn set-collection-field
  ([type field value]
     (set-collection-field type field value {}))
  ([type field value criteria]
     (mongo/update! (model-collection {:type type})
		    criteria {:$set {field value}} :multiple true)))</pre></td></tr><tr><td class="spacer docs">&nbsp;</td><td class="codes" /></tr><tr><td class="docs"><div class="docs-header"><a class="anchor" href="#experiment.infra.services" name="experiment.infra.services"><h1 class="project-name">experiment.infra.services</h1><a class="toc-link" href="#toc">toc</a></a></div></td><td class="codes" /></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(ns experiment.infra.services
  (:refer-clojure :exclude [get set])
  (:require [cheshire.core :as json]
            [experiment.infra.models :as models]))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defonce services (atom nil))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(def reserved-properties #{:name :schema :fields :options :oauth})</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn reserved-property? [property]
  (reserved-properties (keyword property)))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn strip-service-properties [record]
  (apply dissoc record reserved-properties))</pre></td></tr><tr><td class="docs"><p>Register services with user-configured fields</p>
</td><td class="codes"></td></tr><tr><td class="docs"><p>Internal method to update service list</p>
</td><td class="codes"><pre class="brush: clojure">(defn- add!
  [tag service]
  (swap! services (fn [old] (merge old {tag service}))))</pre></td></tr><tr><td class="docs"><p>Stylized interface for registring a service description</p>
</td><td class="codes"><pre class="brush: clojure">(defn register
  [tag [name &amp; {:as options}] &amp; args]
  (assert (and name (&gt; (count args) 1)))
  (let [schema (apply sorted-map args)
        fields (keys schema)]
    (add! tag
          (merge {:name name :options options}
                 {:schema schema}
                 {:fields fields}))))</pre></td></tr><tr><td class="docs"><p>Register an oauth service. No schema, instead oauth URL</p>
</td><td class="codes"><pre class="brush: clojure">(defn register-oauth
  [tag [name &amp; {:as options}]
   &amp; {:keys [title url] :as config}]
  (add! tag (merge {:name name :options options :oauth true}
                   config)))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn get-config [tag]
  &quot;Retrieve the service description for a service by tag&quot;
  (if (keyword? tag)
    (tag @services)
    (@services tag)))</pre></td></tr><tr><td class="docs"><p>Render a JSON script tag with all service descriptions embedded in an object prefixed
   by their tag type</p>
</td><td class="codes"><pre class="brush: clojure">(defn render-registry
  []
  [:script {:type &quot;text/x-json&quot; :id &quot;services-registry&quot;}
   (json/generate-string
    @services)])</pre></td></tr><tr><td class="docs"><p>Update user object service entry (e.g. oauth creds)</p>
</td><td class="codes"></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn get [user tag property]
  (get-in user [:services (keyword tag) (keyword property)]))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn set [user tag property value]
  (assert (not (reserved-property? property)))
  (assoc-in user [:services (keyword tag) (keyword property)] value))</pre></td></tr><tr><td class="docs"><p>Modify MongoDB directly (convenience)</p>
</td><td class="codes"><pre class="brush: clojure">(defn set-model!
  [user tag map]
  (models/modify-model!
   user
   {:$set {:services {tag map}}}))</pre></td></tr><tr><td class="docs"><p>Special case Oauth</p>
</td><td class="codes"><pre class="brush: clojure">(defn get-oauth [user tag]
  (get-in user [:services tag :oauth]))</pre></td></tr><tr><td class="docs"><p>Set oauth properties</p>
</td><td class="codes"><pre class="brush: clojure">(defn set-oauth!
  [user tag properties]
  (models/modify-model!
   user
   {:$set {:services {tag {:oauth properties}}}}))</pre></td></tr><tr><td class="docs"><p>Service Models</p>
</td><td class="codes"></td></tr><tr><td class="docs"><p>Don't expose oauth data to network!</p>
</td><td class="codes"><pre class="brush: clojure">(defmethod models/public-keys :service [svc]
  (keys (dissoc svc :oauth)))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defmethod models/import-keys :service [svc]
  (keys svc))</pre></td></tr><tr><td class="spacer docs">&nbsp;</td><td class="codes" /></tr><tr><td class="docs"><div class="docs-header"><a class="anchor" href="#experiment.infra.session" name="experiment.infra.session"><h1 class="project-name">experiment.infra.session</h1><a class="toc-link" href="#toc">toc</a></a></div></td><td class="codes" /></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(ns experiment.infra.session
  (:use ring.middleware.session.store
	somnium.congomongo)
  (:refer-clojure :exclude [get])
  (:require
   [experiment.infra.middleware :as mid]
   [somnium.congomongo.coerce :as coerce]
   [noir.session :as session]
   [noir.util.crypt :as crypt])
  (:import java.util.UUID))</pre></td></tr><tr><td class="docs"><p>Use Mongo for our Session Store</p>
</td><td class="codes"></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(deftype MongoSessionStore [coll]
  SessionStore
  (read-session [_ key]
    (binding [coerce/*keywordize* false]
      (dissoc (fetch-one coll :where {:*session-key* key})
	      &quot;*session-key*&quot; &quot;_id&quot;)))
  (write-session [_ key data]
    (let [key (or key (str (UUID/randomUUID)))]
      (fetch-and-modify coll {:*session-key* key} (assoc data :*session-key* key)
			:upsert? true)
      key))
  (delete-session [_ key]
    (destroy! coll {:*session-key* key})
    nil))</pre></td></tr><tr><td class="docs"><p>Creates a mongo-backed session storage engine.</p>
</td><td class="codes"><pre class="brush: clojure">(defn mongo-session-store
  ([] (mongo-session-store :sessions))
  ([coll] (MongoSessionStore. coll)))</pre></td></tr><tr><td class="docs"><p>Session event counters</p>
</td><td class="codes"></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn inc! [key &amp; [num]]
  (let [old (session/get key)
	new (+ old (or num 1))]
    (session/put! key new)
    new))</pre></td></tr><tr><td class="docs"><p>Proxy session commands</p>
</td><td class="codes"></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(def put! session/put!)
(def get session/get)
(def remove! session/remove!)
(def clear! session/clear!)
(def flash-put! session/flash-put!)
(def flash-get session/flash-get)</pre></td></tr><tr><td class="docs"><p>The session user and logged-in status for page logic</p>
</td><td class="codes"></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn active? []
  (not (= (type (noir.request/ring-request)) clojure.lang.Var$Unbound)))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn current-user []
  (try 
    (if (active?)
      (and (get :logged-in?)
           mid/*current-user*)
      (when mid/user-fetcher (mid/user-fetcher :username &quot;eslick&quot;)))
    (catch java.lang.Throwable e
      (clojure.tools.logging/error &quot;Get User from Session Error: &quot; e)
      nil)))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn logged-in? []
  (when (current-user) true))</pre></td></tr><tr><td class="spacer docs">&nbsp;</td><td class="codes" /></tr><tr><td class="docs"><div class="docs-header"><a class="anchor" href="#experiment.models.article" name="experiment.models.article"><h1 class="project-name">experiment.models.article</h1><a class="toc-link" href="#toc">toc</a></a></div></td><td class="codes" /></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(ns experiment.models.article
  (:use experiment.infra.models)
  (:require [clodown.core :as md]))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn get-article [name]
  (fetch-model :article {:name name}))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn create-article! [name title body]
  (let [new {:type &quot;article&quot;
             :name (str name)
             :title title
             :body body
             :html (md/mdp body)}]
    (if-let [old (fetch-model :article {:name name})]
      (update-model! (merge old new))
      (create-model! (assoc new :type &quot;article&quot;)))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defmethod update-model-hook :article [model]
  (assoc model :html (md/mdp (:body model))))</pre></td></tr><tr><td class="spacer docs">&nbsp;</td><td class="codes" /></tr><tr><td class="docs"><div class="docs-header"><a class="anchor" href="#experiment.models.comment" name="experiment.models.comment"><h1 class="project-name">experiment.models.comment</h1><a class="toc-link" href="#toc">toc</a></a></div></td><td class="codes" /></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(ns experiment.models.comment
  (:use experiment.infra.models
        clodown.core)
  (:require
   [clojure.tools.logging :as log]
   [noir.validation :as vali]
   [experiment.libs.datetime :as dt]
   [experiment.libs.mail :as mail]
   [experiment.infra.session :as session]
   [experiment.models.user :as user]))</pre></td></tr><tr><td class="docs"><h2>Reddit style discussion forum machinery</h2>

<p>TODO:
-  Add support for ranking/sorting (quora like)
-  Add support for collapsing long chains</p>
</td><td class="codes"></td></tr><tr><td class="docs"><h2>Utilities</h2>
</td><td class="codes"></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn parent-ref [id]
  (cond (and (string? id) (&gt; (count id) 0)) (as-oid id)
        (objectid? id) id
        (or (nil? id) (= (count id) 0)) nil
        true (assert false)))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn- parent-model [comment]
  (when-let [parent (:parent comment)]
    (safe-resolve-dbref :comments parent)))</pre></td></tr><tr><td class="docs"><p>Sort maps by :date (assume integer) field</p>
</td><td class="codes"><pre class="brush: clojure">(defn order-by-date
  [entries]
  (reverse (sort-by :date entries)))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn all-comments [scope]
  (fetch-models :comment {:scope scope}))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn assemble-topology [child-map obj]
  (if-let [children (child-map (:_id obj))]
    (assoc obj :children
           (order-by-date
            (map (partial assemble-topology child-map) children)))
    obj))</pre></td></tr><tr><td class="docs"><p>Assemble tree from acyclic set of objects with :parent links via :_id</p>
</td><td class="codes"><pre class="brush: clojure">(defn topological-sort
  [objects]
  (let [child-map (group-by :parent objects)
        roots (child-map nil)]
    (map (partial assemble-topology child-map) roots)))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn thread-root [comment]
  (if-let [parent (parent-model comment)]
    (thread-root parent)
    comment))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn flatten-tree [children-key tree]
  (reduce concat (list tree)
          (map (partial flatten-tree children-key)
               (children-key tree))))</pre></td></tr><tr><td class="docs"><p>NOTE: This is more expensive than it needs be, but is simple to
   reason about</p>
</td><td class="codes"><pre class="brush: clojure">(defn thread-tree
  [root-comment]
  (let [models (all-comments (:scope root-comment))
        topo (topological-sort models)]
    (first (filter #(= (:_id root-comment) (:_id %)) topo))))</pre></td></tr><tr><td class="docs"><p>Get all posters to a thread of which this comment is a part,
   exclude the author of the comment.</p>
</td><td class="codes"><pre class="brush: clojure">(defn thread-users
  [comment]
  (-&gt;&gt; (thread-root comment)
       thread-tree 
       (flatten-tree :children)
       (map (comp user/get-user :owner))))</pre></td></tr><tr><td class="docs"><p>Most significant 5 chars of a random hash should be unique
   with high probability (this is a git hack used to name patches)</p>
</td><td class="codes"><pre class="brush: clojure">(defn comment-id
  [comment]
  (.substring (str (:_id comment)) 0 5))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn comment-url [comment]
  (case (:scope comment)
    &quot;study1&quot; (str &quot;http://personalexperiment.org/study1/discuss#&quot; (comment-id comment))
    &quot;help&quot; (str &quot;http://personalexperiments.org/help#&quot; (comment-id comment))))</pre></td></tr><tr><td class="docs"><h2>Notifications</h2>
</td><td class="codes"></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn comment-notification-subject [comment]
  (str
   &quot;New Comment on Personal Experiments&quot;))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn comment-notification-body [comment]
  (let [{:keys [owner parent text]} comment
        root (thread-root comment)
        url (comment-url comment)]
    (str
     &quot;User '&quot; owner &quot;' posted a new response&quot;
     &quot; on Personal Experiments:\n&quot;
     &quot;\n---------------------------------------\n&quot;
     (:text comment)
     &quot;\n---------------------------------------\n&quot;
     &quot;\nto the original question:\n&quot;
     &quot;\n---------------------------------------\n&quot;
     (:text root)     
     &quot;\n---------------------------------------\n&quot;
     &quot;\nView the comment thread here: &quot; url
     &quot;\n\nYou have received this comment because you are a registered user of Personal Experiments and have posted a question or response on the site.&quot;)))</pre></td></tr><tr><td class="docs"><p>Send notifications to the site owner and all posters in the
   specific thread</p>
</td><td class="codes"><pre class="brush: clojure">(defn send-comment-notifications
  [comment]
  (try
    (let [message {:subject (comment-notification-subject comment)
                   :body (comment-notification-body comment)}
          emails (distinct (map :email (thread-users comment)))]
      (mail/send-message-to-group
       (concat &quot;ianeslick@gmail.com&quot; emails)
       message))
    (catch java.lang.Throwable e
      (log/error e &quot;Error sending notifications&quot;)
      nil)))</pre></td></tr><tr><td class="docs"><p>API</p>
</td><td class="codes"></td></tr><tr><td class="docs"><p>Get a topologically organized comment tree of nested
   comments with the given discussion scope</p>
</td><td class="codes"><pre class="brush: clojure">(defn all-discussions
  [scope]
  (-&gt; (all-comments scope)
      topological-sort
      order-by-date))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn valid? [text]
  (vali/rule (vali/min-length? text 8)
             [:text &quot;Comment is too short&quot;]))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn comment! [scope parent text]
  (let [username (:username (session/current-user))
        comment {:type :comment
                 :scope scope
                 :text text
                 :html (md text)
                 :owner username
                 :date (dt/as-utc (dt/now))
                 :parent (parent-ref parent)}
        result (create-model! comment)]
    (send-comment-notifications comment)
    result))</pre></td></tr><tr><td class="spacer docs">&nbsp;</td><td class="codes" /></tr><tr><td class="docs"><div class="docs-header"><a class="anchor" href="#experiment.models.core" name="experiment.models.core"><h1 class="project-name">experiment.models.core</h1><a class="toc-link" href="#toc">toc</a></a></div></td><td class="codes" /></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(ns experiment.models.core
  (:use experiment.infra.models
        experiment.models.user)
  (:require
   [experiment.libs.datetime :as dt]
   [experiment.infra.session :as session]))</pre></td></tr><tr><td class="docs"><h2>VARIABLE/SYMPTOM [name ref]</h2>

<ul>
<li>has name</li>
<li>contains Comments</li>
</ul>
</td><td class="codes"></td></tr><tr><td class="docs"><h2>TREATMENT [name ref]</h2>

<ul>
<li>has name</li>
<li>has tags[]</li>
<li>has averageRating</li>
<li>server ratings{user: value}</li>
<li>contains Comments
<ul><li>op: tag</li>
<li>op: comment</li>
<li>op: rate (send to server, update average)</li></ul></li>
</ul>
</td><td class="codes"></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defmethod valid-model? :treatment [treat]
  (let [{:keys [tags comments warnings]} treat]
    (and (every? (set (keys treat)) [:name :description])
	 (every? #(or (nil? %1) (sequential? %1)) [comments warnings tags]))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defmethod server-&gt;client-hook :treatment [treat]
  (-&gt; treat
      (markdown-convert :description)
      (owner-as-bool :owner :admins (site-admins))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defmethod client-&gt;server-hook :treatment [treat]
  (assoc treat
    :owner (as-dbref (session/current-user))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defmethod public-keys :treatment [treat]
  [:name :description :description-html :owner
   :help :reminder
   :tags :comments
   :dynamics :votes :warnings])</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defmethod import-keys :treatment [treat]
  [:name :description
   :help :reminder :dynamics
   :tags])</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defmethod index-keys :treatment [treat]
  [:name :description :tags])</pre></td></tr><tr><td class="docs"><h2>INSTRUMENT [type ref]</h2>

<ul>
<li>has type = 'instrument'</li>
<li>has variable</li>
<li>has service ('device/vendor name')</li>
<li>has src ('channel name')</li>
<li>has update-interval [optional] (polling frequency for service/device)</li>
<li>has min-domain, max-domain (for fixed axis time series)</li>
<li>has numeric? (determines whether values are numeric)</li>
<li>contains Comments</li>
</ul>
</td><td class="codes"></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defmethod public-keys :instrument [treat]
  [:variable :description :description-html
   :service :src :tracked :event
   :tags :comments :owner])</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defmethod import-keys :instrument [treat]
  [:variable :description :tags])</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defmethod index-keys :instrument [treat]
  [:variable :description :tags :service])</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn has-tracker-for-inst [user inst]
  (&gt; (count
      (filter #(and (dbref? %) (= (:_id inst) (.getId %)))
              (map :instrument
                   (vals (:trackers user)))))
     0))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defmethod server-&gt;client-hook :instrument [inst]
  (-&gt; inst
      (markdown-convert :description)
      (owner-as-bool :owner :admins (site-admin-refs))
      (assoc :tracked (has-tracker-for-inst (session/current-user) inst))))</pre></td></tr><tr><td class="docs"><h2>EXPERIMENT</h2>

<ul>
<li>ref Treatment</li>
<li>ref Instruments[]</li>
<li>has title</li>
<li>has instructions</li>
<li>has tags[]</li>
<li>submodel Schedule</li>
<li>submodel Ratings{}</li>
<li>submodels Comments[]</li>
</ul>
</td><td class="codes"></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defmethod db-reference-params :experiment [model]
  [:treatment :outcome :covariates])</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defmethod index-keys :experiment [treat]
  [:title :instructions :tags])</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defmethod public-keys :experiment [treat]
  [:title :schedule 
   :treatment :outcome :covariates 
   :comments :editors])</pre></td></tr><tr><td class="docs"><p>Returns a list of dbrefs to instruments used in this experiment</p>
</td><td class="codes"><pre class="brush: clojure">(defn instruments
  [experiment]
  (vec (concat (:outcome experiment) (:covariates experiment))))</pre></td></tr><tr><td class="docs"><h2>TRACKER</h2>

<ul>
<li>refs User</li>
<li>refs Instrument</li>
<li>has state</li>
</ul>
</td><td class="codes"></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defmethod db-reference-params :tracker [model]
  [:user :instrument])</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defmethod public-keys :tracker [model]
  [:user :instrument :schedule :state])</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defmethod import-keys :tracker [model]
  [:user :instrument :schedule :state])</pre></td></tr><tr><td class="docs"><h2>JOURNAL (embedded)</h2>

<ul>
<li>date</li>
<li>date-str</li>
<li>content</li>
<li>sharing</li>
</ul>
</td><td class="codes"></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defmethod db-reference-params :journal [model]
  [:user])</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defmethod public-keys :journal [model]
  [:date :date-str :sharing :short :content :annotation])</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defmethod import-keys :journal [treat]
  [:date :sharing :short :content :annotation])</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defmethod server-&gt;client-hook :journal [model]
  (assoc model
    :date-str (dt/as-blog-date (:date model))))</pre></td></tr><tr><td class="docs"><h2>COMMENT (embedded)</h2>

<ul>
<li>has upVotes</li>
<li>has downVotes</li>
<li>has title</li>
<li>has content</li>
</ul>
</td><td class="codes"></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defmethod public-keys :comment [treat]
  [:date :content])</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defmethod import-keys :comment [treat]
  [:date :content])</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defmethod server-&gt;client-hook :comment [model]
  (assoc model
    :date-str (dt/as-blog-date (:date model))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defmethod make-annotation :comment [{:keys [text]}]
  (when (&gt; (count text) 5)
    (let [date (dt/now)]
      {:content text
       :username (:username (session/current-user))
       :date (dt/as-utc date)
       :date-str (dt/as-short-string date)})))</pre></td></tr><tr><td class="docs"><h2>USER Prefs</h2>
</td><td class="codes"></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defmethod public-keys :userprefs [prefs]
  (keys prefs))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defmethod import-keys :userprefs [prefs]
  (keys prefs))</pre></td></tr><tr><td class="spacer docs">&nbsp;</td><td class="codes" /></tr><tr><td class="docs"><div class="docs-header"><a class="anchor" href="#experiment.models.eventlog" name="experiment.models.eventlog"><h1 class="project-name">experiment.models.eventlog</h1><a class="toc-link" href="#toc">toc</a></a></div></td><td class="codes" /></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(ns experiment.models.eventlog
  (:use
   experiment.infra.models
   experiment.infra.api)
  (:require
   [clojure.tools.logging :as log]
   [clj-time.core :as time]
   [experiment.libs.datetime :as dt]
   [noir.response :as resp]
   [experiment.infra.session :as session]
   [experiment.models.user :as user]
   [experiment.models.events :as events]
   [experiment.models.schedule :as schedule]
   [experiment.models.trackers :as trackers]
   [experiment.models.trial :as trial]
   [experiment.models.instruments :as inst]))</pre></td></tr><tr><td class="docs"><h2>Event Timeline</h2>
</td><td class="codes"></td></tr><tr><td class="docs"><h2>Events</h2>
</td><td class="codes"></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn event-timeline [user start end]
  (let [existing (events/get-events :user user :start start :end end)
        last-dt (:start (last existing))]
    (if (time/after? end last-dt)
      (let [interval (if (time/before? start last-dt)
                       (time/interval last-dt end)
                       (time/interval start end))]
        (concat existing
                (events/remove-scheduled
                 (trackers/all-tracker-events user interval))
                (trial/all-reminder-events user interval)))
      existing)))</pre></td></tr><tr><td class="docs"><p>Utilities</p>
</td><td class="codes"></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn sort-events [[date events]]
  [date (sort-by (comp dt/as-utc :start) events)])</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn group-by-start-day [events]
  (-&gt;&gt; events
       (group-by (fn [event]
                   (schedule/decimate :day (:start event))))
       (map sort-events)))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn group-events-by-day [events]
  (-&gt;&gt; events
       group-by-start-day
       (sort-by :first)))</pre></td></tr><tr><td class="docs"><h2>REST API For Events</h2>

<p>Given session user, start and end
returns past events and future events for the period</p>

<p>Returns: [ {events: [], date: "", period: ""}, ... ]</p>
</td><td class="codes"></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn make-event-group [[start events]]
  {:date (dt/as-iso start)
   :events (vec (map #(server-&gt;client % true) events))})</pre></td></tr><tr><td class="docs"><p>TODO: User's trackers and trials -> track events &amp; reminders
(for future time horizons)</p>
</td><td class="codes"><pre class="brush: clojure">(defapi fetch-events [:get &quot;/api/events/fetch&quot;]
  {:keys [start end] :as options}
  (let [start (or (dt/from-iso start) (time/minus (dt/now) (time/days 7)))
        end (or (time/plus (dt/from-iso end) (time/days 1))
                (time/plus (dt/now) (time/days 6)))
        min (time/minus (dt/now) (time/days 90))
        max (time/plus (dt/now) (time/days 90))
        start (if (time/before? start min) min start)
        end (if (time/after? end max) max end)
        user (session/current-user)
        result     (vec
                    (map make-event-group 
                         (group-events-by-day
                          (event-timeline user start end))))]
    result))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defapi submit-event [:post &quot;/api/events/submit&quot;]
  {:keys [userid instid date text] :as options}
  (let [user (fetch-model :user {:_id (deserialize-id userid)})
        inst (fetch-model :instance {:_id (deserialize-id instid)})
        dt (dt/from-iso date)
        events (events/get-events :user user :inst inst
                                  :start dt :end dt)]
    (if (not (empty? events))
      (server-&gt;client
       (trackers/associate-message-with-events user events (dt/now) text))
      nil)))</pre></td></tr><tr><td class="spacer docs">&nbsp;</td><td class="codes" /></tr><tr><td class="docs"><div class="docs-header"><a class="anchor" href="#experiment.models.events" name="experiment.models.events"><h1 class="project-name">experiment.models.events</h1><a class="toc-link" href="#toc">toc</a></a></div></td><td class="codes" /></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(ns experiment.models.events
  (:use experiment.infra.models)
  (:require
   [clojure.tools.logging :as log]
   [noir.response :as resp]
   [clj-time.core :as time]
   [experiment.libs.datetime :as dt]
   [experiment.infra.session :as session]
   [experiment.infra.api :as api]
   [experiment.libs.sms :as sms]
   [experiment.models.user :as user]
   [experiment.models.instruments :as inst]))</pre></td></tr><tr><td class="docs"><h2>Legacy Hooks (to be removed)</h2>
</td><td class="codes"><pre class="brush: clojure">(defn trial-reminders [trial]
  (:reminders trial))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn future-reminder? [start reminder]
  (assert (= (type start) java.lang.Long))
  (&gt;= (:date reminder) start))</pre></td></tr><tr><td class="docs"><h2>Event Handling</h2>

<p>Events are intended to support actions to be taken (automatically, or via
reminders over some channel) and are stores persistently in a database.</p>

<h2>EVENT MODEL</h2>

<h3>Status</h3>

<ul>
<li>pending :: schedule but not fired</li>
<li>active :: fired but not done (e.g. sms sent)</li>
<li>done :: event is fully satisfied</li>
</ul>

<h3>Required keys</h3>

<ul>
<li>:type "event"</li>
<li>:etype <event type></li>
<li>:user (user ref associated with the event)</li>
<li>:inst (instrument ref associated with the event)</li>
</ul>

<h3>Other keys</h3>

<ul>
<li>:start - target start of event</li>
<li>:wait - whether to remain active waiting for a response</li>
<li>:result - was the event satisfied (e.g. delivered, responded, etc)</li>
<li>:timeout - how long to wait before failing when response is needed</li>
</ul>
</td><td class="codes"></td></tr><tr><td class="docs"><h2>Event primitives</h2>
</td><td class="codes"></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(def required-event-keys [:type :etype :user :instrument :start])</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn make-event [type user instrument &amp; {:as options}]
  (merge {:type &quot;event&quot;
          :etype type
          :user (as-dbref user)
          :instrument (when instrument (as-dbref instrument))}
         options))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn make-sms-tracker-event [u i message value-type prefix]
  (make-event
   &quot;sms&quot; u i
   :sms-value-type value-type
   :sms-prefix prefix
   :message message
   :wait true))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn make-sms-reminder-event [u message]                              
  (make-event
   &quot;sms&quot; u nil
   :message message
   :wait false))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn valid-event? [event]
  (and (= (count (select-keys event required-event-keys))
          (count required-event-keys))
       (#{&quot;pending&quot; &quot;active&quot; &quot;done&quot;} (:status event))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn active? [event]
  (or (nil? (:status event))
      (#{&quot;pending&quot; &quot;active&quot;} (:status event))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn success? [event]
  (and (= (:status event) &quot;done&quot;)
       (= (:result event) &quot;success&quot;)))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn fail? [event]
  (and (= (:status event) &quot;done&quot;)
       (not= (:result event) &quot;success&quot;)))</pre></td></tr><tr><td class="docs"><p>If 't' is within 24 hours of 'ref'</p>
</td><td class="codes"><pre class="brush: clojure">(defn within-24-hours-of?
  [t ref]
  (time/within?
   (time/interval
    (time/minus ref (time/hours 24))
    (time/plus ref (time/hours 24)))
   t))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn editable? [event]
  (when-let [start (:start event)]
    (and (= (:status event) &quot;active&quot;)
         (:wait event)
         (= (:etype event) &quot;sms&quot;)
         (within-24-hours-of? (dt/now) start))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn requires-reply? [event]
  (:wait event))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defmacro modify-if
  ([map key value]
     `(let [themap# ~map]
        (assert (map? themap#))
        (if (contains? themap# ~key)
          (assoc themap# ~key ~value)
          themap#)))
  ([map key new-key value]
     `(let [themap# ~map
            theval# ~value]
        (assert (map? themap#))
        (if (contains? themap# ~key)
          (dissoc
           (if (map? theval#)
             (assoc themap# ~new-key (merge (themap# ~new-key) theval#))
             (assoc themap# ~new-key theval#))
             ~key)
          themap#))))</pre></td></tr><tr><td class="docs"><h2>Event Model Protocol</h2>
</td><td class="codes"></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defmethod public-keys :event [event]
  [:status :start :local-time :instrument :user :message
   :sms-prefix :sms-value-type :result-ts :result-val
   :result-time :success :fail :editable])</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defmethod import-keys :event [event]
  [:status])</pre></td></tr><tr><td class="docs"><p>Only convert instantiated events</p>
</td><td class="codes"><pre class="brush: clojure">(defmethod server-&gt;client-hook :event [event]
  (if (valid-event? event)
    (let [start (dt/in-session-tz (:start event))
          ltime (dt/wall-time start)
          ts (when-let [res (:result-ts event)]
               (dt/in-session-tz res))
          tstime (dt/wall-time ts)]
      (-&gt; event
          (update-in [:start] (fn [old] (dt/as-iso start)))
          (update-in [:result-ts] (fn [old] (dt/as-iso ts)))
          (assoc :success (success? event))
          (assoc :fail (fail? event))
          (assoc :editable (editable? event))
          (assoc :local-time ltime)
          (assoc :result-time tstime)))
    (log/spy event)))</pre></td></tr><tr><td class="docs"><h2>Event storage and manipulation</h2>
</td><td class="codes"></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn- event-query [query]
  (let [user (:user query)
        inst (:instrument query)]
    (-&gt; query
        (modify-if :user (if (dbref? user) user (as-dbref user)))
        (modify-if :instrument (if (dbref? inst) inst (as-dbref inst)))
        (modify-if :type :etype (:type query))
        (modify-if :start {:$gte (dt/as-date (:start query))})
        (modify-if :end :start {:$lte (dt/as-date (:end query))}))))</pre></td></tr><tr><td class="docs"><p>Return the events for the user associated with this incoming message</p>
</td><td class="codes"><pre class="brush: clojure">(defn get-events 
  [&amp; {:keys [user status type start end] :as query}]
  (fetch-models :event (event-query query) :sort {:start 1}))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn matching-events [event]
  (get-events :user (:user event)
              :instrument (:instrument event)
              :start (time/minus (:start event)
                                 (time/minutes (or (:jitter event) 0)))
              :end (time/plus (:start event)
                              (time/minutes (or (:jitter event) 0)))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn event-scheduled? [event]
  (not (empty? (matching-events event))))</pre></td></tr><tr><td class="docs"><p>Ensure that the list of events do not match
   any scheduled ('active') events</p>
</td><td class="codes"><pre class="brush: clojure">(defn remove-scheduled
  [events]
  (assert (every? :start events))
  (let [outer (time/plus (dt/now) (time/hours 30))
        [near far] (split-with #(time/before? (:start %) outer) events)]
    (concat (filter #(not (event-scheduled? %)) near) far)))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn register-event [event]
  (when (empty? (matching-events event))
    (create-model!
     (assoc event
       :type &quot;event&quot;
       :status &quot;active&quot;))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn set-status [event status]
  (modify-model! event {:$set {:status status}}))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn complete [event ts data]
  (modify-model! event {:$set {:status &quot;done&quot;
                               :result &quot;success&quot;
                               :result-ts ts
                               :result-val data}}))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn cancel [event &amp; [reason]]
  (modify-model! event {:$set {:status &quot;done&quot;
                               :result (or reason &quot;fail&quot;)
                               :result-ts (dt/now)}}))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn event-user [event]
  (assert (and (= (:type event) &quot;event&quot;) (:user event)))
  (resolve-dbref (:user event)))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn event-inst [event]
  (assert (and (= (:type event) &quot;event&quot;) (:inst event)))
  (resolve-dbref (:inst event)))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn link-event [user inst event]
  (-&gt; event
      (assoc :user (as-dbref user))
      (assoc :inst (as-dbref inst))))</pre></td></tr><tr><td class="docs"><h2>Event Action Protocol</h2>
</td><td class="codes"></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defmulti fire-event (comp keyword :etype))</pre></td></tr><tr><td class="docs"><p>By default do nothing</p>
</td><td class="codes"><pre class="brush: clojure">(defmethod fire-event :default [event]
  nil)</pre></td></tr><tr><td class="docs"><p>Example action event that writes to a log</p>
</td><td class="codes"><pre class="brush: clojure">(defmethod fire-event :log [event]
  (println &quot;Log event firing&quot;)
  (log/spy event))</pre></td></tr><tr><td class="spacer docs">&nbsp;</td><td class="codes" /></tr><tr><td class="docs"><div class="docs-header"><a class="anchor" href="#experiment.models.harness" name="experiment.models.harness"><h1 class="project-name">experiment.models.harness</h1><a class="toc-link" href="#toc">toc</a></a></div></td><td class="codes" /></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(ns experiment.models.harness
  (:use experiment.infra.models
	experiment.models.core
	experiment.models.user
	clj-time.core)
  (:require
   [experiment.infra.session :as session]
   [experiment.infra.auth :as auth]
   [somnium.congomongo :as mongo]
   [clj-time.coerce :as coerce]))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(def model-types
  [:symptom
   :instrument
   :treatment
   :trial])</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn create-user []
  (create-model!
   (auth/set-user-password
    {:type :user
     :username &quot;eslick&quot;
     :salt &quot;foobar&quot;
     :name &quot;Ian Eslick&quot;
     :bio &quot;Entrepreneur, site developer&quot;
     :city &quot;San Francisco&quot;
     :state &quot;California&quot;
     :country &quot;USA&quot;
     ;; Tracking info
     :experiments 1} &quot;apple&quot;)))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn clear-models []
  (map mongo/drop-coll! model-types))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn clear-all-models []
  (map mongo/drop-coll! (concat model-types [:user])))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn create-models []
;;  (create-user)
  (dorun
   (map create-model!
	[{:type :instrument
	  :variable &quot;Sleep duration&quot;
	  :nicknames [&quot;Amount of sleep&quot; &quot;sleep&quot;]
	  :src :zeo
	  :comments []
	  :description &quot;Nightly sleep duration as measured by the Zeo&quot;}
	 {:type :instrument
	  :variable &quot;Sleep quality&quot;
	  :nicknames [&quot;ZQ&quot; &quot;sleep&quot;]
	  :src :zeo
	  :comments []
	  :description &quot;Tracks sleep quality as a function of total sleep, amount of deep sleep and REM sleep and nightly wakenings to estimate the overall quality of sleep&quot;}
	 {:type :instrument
	  :variable &quot;Nighly wakings&quot;
	  :nicknames [&quot;Wakings&quot; &quot;times getting up at night&quot; &quot;nightime waking&quot;]
	  :src :zeo
	  :comments []
	  :description &quot;The Zeo can track the number of nightly wakenings&quot;}
	 {:type :instrument
	  :variable &quot;Adherence&quot;
	  :nicknames [&quot;taking treatment&quot; &quot;adherence&quot; &quot;compliance&quot;]
	  :src :manual
	  :comments []
	  :description &quot;A simple estimate of how well you stuck to a treatment.&quot;}
	 {:type :instrument
	  :variable &quot;Fatigue&quot;
	  :nicknames [&quot;Simple fatigue&quot; &quot;single question&quot; &quot;fatigue&quot; &quot;tiredness&quot;]
	  :src :manual
	  :comments []
	  :questions [{:prompt &quot;Rate your physical fatigue from 0 - none to 7 - debilitating&quot;
		       :type :integer
		       :validator [&quot;integer-range&quot; 0 7]}
		      {:prompt &quot;Rate your mental fatigue from 0 - none to 7 - debilitating&quot;
		       :type :integer
		       :validator [&quot;integer-range&quot; 0 7]}]}
	 {:type :treatment
	  :name &quot;No fructose, low-sugar diet&quot;
	  :tags [&quot;psoriasis&quot; &quot;auto-immune&quot; &quot;inflammation&quot; &quot;GI&quot; &quot;fructose malabsorbtion&quot;]
	  :editors [&quot;eslick&quot;]
	  :description &quot;Minimize foods containing fructose and sugar in general; no processed sugar.  Avoid fructans.&quot;
	  :dynamics {:initial-onset [&quot;weeks&quot; 3]
		     :repeat-onset [&quot;days&quot; 3]
		     :offset [&quot;days&quot; 3]}
	  :help [{:text &quot;Apples and pears have lots of fructose and sorbitol.&quot;}
		 {:url &quot;http://foo.bar&quot;}]
	  :reminder &quot;Reminder: no sugar today!&quot;
	  :votes [2 1]
	  :warnings []
	  :comments [{:user &quot;eslick&quot;
		      :content &quot;This has worked wonders for me, but you have to stick to it for 2-3 weeks to really see the effect.  The diet is tough because lots of food like eggplant and tomatoes have fructose.  Makes sense if you might have fructose malabsorbtion.&quot;
		      :votes [1 0]}]}
	 {:type :treatment
	  :editors [&quot;eslick&quot;]
	  :name &quot;Slippery Elm Treatment&quot;
	  :description
	  &quot;5 Slippery Elm caps emptied into water, allowed to sit 5 mins then consumed.  Gluten limited.  Avoiding processed foods.  Limiting fats except flax, fish, and primrose oil.  Blue berries mixed with 2% cottage cheese every morning and flax seed oil directly behind it.  Taking a probiotic suppliment. Soaking in salt water 1-2 times a week. Left salt on my body 12 hours.&quot;
	  :dynamics {:initial-onset [&quot;weeks&quot; 3]
		     :repeat-onset [&quot;days&quot; 3]
		     :offset [&quot;days&quot; 3]}
	  :votes [2 1]
	  :warnings []
	  :comments []}]))
  (dorun
   (map create-model! 
	[{:type :experiment
	  :editors [&quot;eslick&quot;]
	  :title &quot;Does diet rapidly improve fatigue if I control for sleep?&quot;
	  :outcome [(as-dbref (fetch-model :instrument {:variable &quot;Fatigue&quot; :src :manual}))]
	  :instruments [(as-dbref (fetch-model :instrument {:variable &quot;Sleep quality&quot; :src :zeo}))
			(as-dbref (fetch-model :instrument {:variable &quot;Adherence&quot; :src :manual}))
			(as-dbref (fetch-model :instrument {:variable &quot;Psoriasis activity&quot; :src :manual}))]
	  :measurements [{:type :schedule
			  :interval-unit &quot;day&quot;
			  :interval 1}]
	  :treatment {:type :schedule
		      :interval-unit &quot;days&quot;
		      :schedule [:off 14 :on 21 :off 7 :on 7 :off 7]}}]))
   (dorun
    (map create-model!
	 [{:type :trial
	   :user &quot;eslick&quot;
	   :experiment (mongo/db-ref :experiment (:_id (fetch-model :experiment {:title &quot;Does diet rapidly improve fatigue if I control for sleep?&quot;})))
	   :sms? true
	   :active? true
	   :start &quot;date&quot;
	   :end &quot;date&quot;}])))</pre></td></tr><tr><td class="docs"><p>  (let [user (fetch-model :user {:username "eslick"})]
    ))
   (create-model! (assoc user  </p>
</td><td class="codes"></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn create-dataset []
  (let [user (as-dbref (fetch-model :user {:username &quot;eslick&quot;}))
	instrument (as-dbref (fetch-model :instrument {:variable &quot;Fatigue&quot; :src :manual}))
	now (now)
	data (reverse
	      (map (fn [offset value]
		     [(coerce/to-long (minus now (days offset))) value])
		   (range 0 10) (repeatedly (partial rand-int 7))))
	start (first (first data))
	end (first (last data))]
    (map create-model!
	 [{:type &quot;event&quot;
	   :user user
	   :instrument instrument
	   :start start
	   :end end
	   :data data}])))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn create-articles []
  (map #(create-model! :article (assoc %1 :type :article))
       {:name :terms
	:title &quot;Terms of Use&quot;
	:body &quot;TBD&quot;}
       {:name :privacy
	:title &quot;Privacy Policy&quot;
	:body &quot;TBD&quot;}
       {:type :article
	:title &quot;About this site&quot;
	:body &quot;TBD&quot;}))</pre></td></tr><tr><td class="spacer docs">&nbsp;</td><td class="codes" /></tr><tr><td class="docs"><div class="docs-header"><a class="anchor" href="#experiment.models.instruments" name="experiment.models.instruments"><h1 class="project-name">experiment.models.instruments</h1><a class="toc-link" href="#toc">toc</a></a></div></td><td class="codes" /></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(ns experiment.models.instruments
  (:use experiment.infra.models
        experiment.models.samples
        clojure.math.numeric-tower)
  (:require [clj-time.core :as time]
            [clojure.tools.logging :as log]
            [experiment.models.user :as user]
            [experiment.infra.services :as services]
            [experiment.libs.datetime :as dt]
            [experiment.libs.zeo :as zeo]
            [experiment.libs.withings :as wi]
            [experiment.libs.strava :as strava]
            [experiment.libs.twitter :as twitter]
            [experiment.libs.fitbit :as fit]
            [experiment.libs.rescuetime :as rt]))</pre></td></tr><tr><td class="docs"><p>Big ol file of instruments</p>

<p>Connect 3rd party libraries to a mongo log and sql-based sample
set and provide an api to query instruments</p>
</td><td class="codes"></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(def do-refresh-p false)</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defmacro safe-body [&amp; body]
  `(try
     (do ~@body)
     (catch java.lang.Throwable error#
      (log/spy error#)
      nil)))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn get-instruments []
  (fetch-models :instrument))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn get-instrument [ref]
  (or (fetch-model &quot;instrument&quot; {:_id ref})
      (fetch-model &quot;instrument&quot; {:src ref})
      (fetch-model &quot;instrument&quot; {:name ref})))</pre></td></tr><tr><td class="docs"><p>Instrument Protocol
- last-update-received
- time-series (start, end, filter?)
- number-of-missed-records (start, end)
- refresh (pull from upstream server service)
- recompute (update time series DB, any derived measures)
- update (add new data - for manual instruments)
- reset (delete all data and fetch up to 1 month back)</p>
</td><td class="codes"></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(def ih (make-hierarchy))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defmulti configured? (fn [i u] (keyword (:src i))) :hierarchy #'ih)
(defmulti last-update (fn [i u] (keyword (:src i))) :hierarchy #'ih)
(defmulti refresh (fn [i u &amp; args] (keyword (:src i))) :hierarchy #'ih)
(defmulti reset (fn [i u] (keyword (:src i))) :hierarchy #'ih)
(defmulti time-series (fn [i u &amp; args] (keyword (:src i))) :hierarchy #'ih)
(defmulti update (fn [i u d] (keyword (:src i))) :hierarchy #'ih)</pre></td></tr><tr><td class="docs"><p>Utils</p>
</td><td class="codes"></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn- sample-interval [inst]
  (if-let [mins (get-in inst [:sampling :period])]
    (time/minutes mins)
    (time/days 1)))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn- sample-&gt;pair [sample]
  [(:ts sample) (:v sample)])</pre></td></tr><tr><td class="docs"><p>Data hasn't been feched, or hasn't been updated after
   a certain time ago, 1 hour by default</p>
</td><td class="codes"><pre class="brush: clojure">(defn- stale?
  [inst user]
  (let [lu (last-update inst user)]
    (or (not lu)
        (time/after?
         (time/minus (dt/now) (sample-interval inst))
         lu))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn min-plot [inst]
  (if-let [min (:min-domain inst)]
    min nil))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn max-plot [inst]
  (if-let [max (:max-domain inst)]
    max nil))</pre></td></tr><tr><td class="docs"><p>Defaults</p>
</td><td class="codes"></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defmethod last-update :default [instrument user]
  (last-updated-time user instrument))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defmethod time-series :default [inst user &amp; [start end convert?]]
  (when do-refresh-p
    (safe-body
     (refresh inst user)))
  (doall
   (get-samples user inst
                :start (or start (dt/a-month-ago))
                :end (or end (dt/now)))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defmethod time-series :categorical [inst user &amp; [start end convert?]]
  [])</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defmethod time-series :opentext [inst user &amp; [start end convert?]]
  [])</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defmethod refresh :default [inst user &amp; [force?]]
  nil)</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defmethod reset :default [inst user]
  (rem-samples user inst))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defmethod update :default [inst user data]
  (cond (map? data)
        (add-samples user inst [data])
        (sequential? data)
        (add-samples user inst data)))</pre></td></tr><tr><td class="docs"><hr />

<h2>Rescuetime-based Instruments</h2>
</td><td class="codes"></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defmethod configured? :rt [inst user]
  (and (services/get user :rt :apikey)
       (services/get user :rt :user)))</pre></td></tr><tr><td class="docs"><p>Social Media Usage on Rescuetime (value in seconds)</p>
</td><td class="codes"></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defmacro rt-update [inst user force? [var] &amp; body]
  `(let [i# ~inst
         u# ~user]
     (when (or ~force? (stale? i# u#))
       (rt/with-key (services/get u# :rt :apikey)
         (let [~var (or (last-update i# u#) ~force? (dt/a-month-ago))]
           ~@body))
       true)))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn seconds-to-hours [seconds]
  (assert (number? seconds))
  (/ (round (* (/ seconds 3600) 100)) 100.0))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn- socmed-&gt;series [[dt time people cat]]
  {:ts (dt/from-iso-8601 dt) :v (seconds-to-hours time) :secs time})</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(alter-var-root #'ih derive :rt-socmed-usage :rt)
(defmethod refresh :rt-socmed-usage
  [inst user &amp; [force?]]
  (rt-update inst user force? [start]
     (let [data (rt/social-media &quot;day&quot; start (dt/now))]
       (update inst user (map socmed-&gt;series (:rows data))))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn- efficiency-&gt;total [[dt total people eff]]
  {:ts (dt/from-iso-8601 dt) :v (seconds-to-hours total) :secs total})</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn- efficiency-&gt;eff [[dt total people eff]]
  {:ts (dt/from-iso-8601 dt) :v eff})</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(alter-var-root #'ih derive :rt-efficiency :rt)
(defmethod refresh :rt-efficiency
  [inst user &amp; [force?]]
  (rt-update inst user force? [start]
     (let [data (rt/efficiency &quot;day&quot; start (dt/now))]
       (update inst user (map efficiency-&gt;eff (:rows data)))
       (update (get-instrument &quot;rt-total&quot;) user
               (map efficiency-&gt;total (:rows data))))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(alter-var-root #'ih derive :rt-total :rt)
(defmethod refresh :rt-total
  [inst user &amp; [force?]]
  (refresh (get-instrument &quot;rt-efficiency&quot;) user force?))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defmacro ensure-instrument [[svc type] &amp; body]
  (assert (keyword type))
  `(when (not (get-instrument ~type))
     (create-model!
      (merge
       {:type :instrument
        :src ~type
        :svc ~svc
        :comments []}
       ~@body))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn ensure-rt-instruments []
  (ensure-instrument [:rescuetime :rt-socmed-usage]
    {:variable &quot;Social Media Usage&quot;
     :nicknames [&quot;social media&quot; &quot;usage&quot;]
     :sampling {:period (* 60 12) ;; 12 hours
                :chunksize :month}
     :description &quot;Your social media usage as measured by rescuetime&quot;})
  (ensure-instrument [:rescuetime :rt-efficiency]
    {:variable &quot;Computer Work Efficiency&quot;
     :nicknames [&quot;online efficiency&quot; &quot;work efficiency&quot;]
     :sampling {:period (* 60 12) ;; 12 hours
                :chunksize :month}
     :description &quot;Your computer-based work efficiency as measured by rescuetime&quot;})
  (ensure-instrument [:rescuetime :rt-total]
    {:variable &quot;Total time on computers&quot;
     :nicknames [&quot;computer time&quot;]
     :sampling {:period (* 60 12) ;; 12 hours
                :chunksize :month}
     :description &quot;Total time on a rescutime enabled computer&quot;})
  true)</pre></td></tr><tr><td class="docs"><hr />

<h2>Withings Instruments (scale only)</h2>
</td><td class="codes"></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defmethod configured? :wt [inst user]
  (and (wi/get-access-token user)
       (wi/get-access-secret user)
       (wi/get-userid user)))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn wi-inst-by-type [type]
  (fetch-model :instrument {:src-type type}))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn wi-sample [sample]
  (let [{:keys [date type value]} sample]
    (if date
      {:ts (dt/from-epoch date) :v value}
      (println sample))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn add-wi-group [user [type samples]]
  (update (wi-inst-by-type type) user 
          (keep wi-sample samples)))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defmethod refresh :wi
  [inst user &amp; [force?]]
  (when (or force? (stale? inst user))
    (doall
     (map (partial add-wi-group user)
          (group-by
           :type
           (second
            (if force?
              (wi/user-measures user)
              (wi/user-measures user (or (last-update inst user) (time/epoch))))))))
    true))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(def wi-instruments
  [:wi-weight :wi-height :wi-lbm :wi-fat-ratio :wi-fat-mass])</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(dorun
  (map (fn [iname]
         (alter-var-root #'ih derive iname :wi))
       wi-instruments))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn ensure-wi-instruments []
  (ensure-instrument [:withings :wi-weight]
    {:variable &quot;Weight&quot;
     :src-type :weight
     :nicknames [&quot;withing weight&quot; &quot;scale weight&quot;]
     :description &quot;Weight as measured by the withings scale&quot;})
  (ensure-instrument [:withings :wi-height]
    {:variable &quot;Height&quot;
     :src-type :height
     :nicknames [&quot;height&quot;]
     :description })
  (ensure-instrument [:withings :wi-lbm]
    {:variable &quot;LBM&quot;
     :src-type :lbm
     :nicknames [&quot;lean body mass&quot; &quot;lbm&quot;]
     :description &quot;Lean Body Mass according to Withings&quot;})
  (ensure-instrument [:withings :wi-fat-ratio]
    {:variable &quot;Fat Ratio&quot;
     :src-type :fat-ratio
     :nicknames [&quot;fat %&quot; &quot;fat ratio&quot;]
     :description })
  (ensure-instrument [:withings :wi-fat-mass]
    {:variable &quot;Fat Mass&quot;
     :src-type :fat-mass
     :nicknames [&quot;fat mass&quot; &quot;fat&quot;]
     :description &quot;Fat Mass according to Withings Scale&quot;})
  true)</pre></td></tr><tr><td class="docs"><hr />

<h2>FitBit-derived Instruments</h2>
</td><td class="codes"></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(def fitbit-fake-inst
  {:_id &quot;FITBIT&quot; :type &quot;instrument&quot; :sampling {:chunksize :week}})</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defmethod configured? :fit [inst user]
  (fit/get-user-id user))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defmethod last-update :fit [instrument user]
  (last-updated-time user fitbit-fake-inst))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn add-fit-sample [user date]
  (let [data (fit/summary user date)
        summary (:summary data)]
    (if (and data (&gt; (:steps summary) 0))
      (do (update fitbit-fake-inst user
                  [(merge {:ts date
                           :v (:activeScore summary)}
                          summary)])
          true)
      false)))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn- days-ago-to-date [days]
  (time/minus (dt/now) (time/days days)))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn add-fit-samples [inst user]
  (let [days (time/in-days
              (time/interval
               (or (last-update inst user) (dt/a-month-ago))
               (time/now)))]
    (doall
     (map (partial add-fit-sample user)
          (map days-ago-to-date (range (dec days)))))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(alter-var-root #'ih derive :fit-steps :fit)
(defmethod refresh :fit [inst user &amp; [force?]]
  (when (or force? (stale? inst user))
    (add-fit-samples inst user)))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defmethod reset :fit [inst user]
  (rem-samples user fitbit-fake-inst))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defmethod time-series :fit-steps [inst user &amp; [start end convert?]]
  (get-samples user fitbit-fake-inst
               :start (or start (dt/a-month-ago))
               :end (or end (dt/now))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn ensure-fit-instruments []
  (ensure-instrument [:fitbit :fit-steps]
    {:variable &quot;Steps Taken&quot;
     :src-type :steps
     :sampling {:period (* 60 12) ;; 12 hours
                :chunksize :week}
     :nicknames [&quot;steps&quot; &quot;walking&quot; &quot;steps taken&quot; &quot;number of steps&quot;]
     :description &quot;Number of steps in a day according to fitbit&quot;}))</pre></td></tr><tr><td class="docs"><p>Handle Fitbit subscription notifications</p>
</td><td class="codes"></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defonce fitbit (agent [0 0]))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn fetch-fitbit-sample [[success fail] user date]
  (try
    (do (add-fit-sample user date)
        [(inc success) fail])
    (catch java.lang.Throwable e
      (clojure.tools.logging/error e &quot;Fitbit fetch error&quot;)
      [success (inc fail)])))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn fitbit-handler-fn [updates]
  (for [update updates]
    (let [{:keys [collectionType date ownerId subscriptionId]} update]
      (when-let [user (and (= collectionType &quot;activities&quot;) (fit/id-&gt;user ownerId))]
        (send fitbit fetch-fitbit-sample user (dt/from-iso-8601 date))))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(fit/set-notification-handler 'fitbit-handler-fn)</pre></td></tr><tr><td class="docs"><hr />

<h2>Bootstrapping</h2>
</td><td class="codes"></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn ensure-instruments []
  (ensure-rt-instruments)
  (ensure-wi-instruments)
  (ensure-fit-instruments))</pre></td></tr><tr><td class="spacer docs">&nbsp;</td><td class="codes" /></tr><tr><td class="docs"><div class="docs-header"><a class="anchor" href="#experiment.models.omh" name="experiment.models.omh"><h1 class="project-name">experiment.models.omh</h1><a class="toc-link" href="#toc">toc</a></a></div></td><td class="codes" /></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(ns experiment.models.omh
  (:use
   experiment.infra.models
   experiment.infra.api
   experiment.models.samples)
  (:require
   [clj-time.core :as time]
   [clojure.string :as str]
   [experiment.models.user :as user]
   [experiment.infra.auth :as auth]
   [experiment.libs.datetime :as dt]))</pre></td></tr><tr><td class="docs"><h2>SERVER</h2>
</td><td class="codes"></td></tr><tr><td class="docs"><h2>Authentication</h2>
</td><td class="codes"></td></tr><tr><td class="docs"><p>Expiration</p>
</td><td class="codes"><pre class="brush: clojure">(def server_timeout 30) ;; in days</pre></td></tr><tr><td class="docs"><p>in days</p>
</td><td class="codes"><pre class="brush: clojure">(defn expiration []
  (dt/as-iso-8601 (time/plus (dt/now) (time/days server_timeout))))</pre></td></tr><tr><td class="docs"><p>Authentication tokens</p>
</td><td class="codes"><pre class="brush: clojure">(defonce tokens (atom {}))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn find-token [spec]
  (first (first (filter (fn [[k v]] (= v spec)) @tokens))))</pre></td></tr><tr><td class="docs"><p>Given the requestor and username, generate a unique token</p>
</td><td class="codes"><pre class="brush: clojure">(defn generate-token
  [req username]
  (let [table @tokens
        spec [req username]]
    (if-let [token (find-token spec)]
      token
      (let [token (str (java.util.UUID/randomUUID))]
        (swap! tokens assoc token [req username])
        token))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn token-&gt;user [token]
  (when-let [username (second (@tokens token))]
    (fetch-model :user {:username (second (@tokens token))})))</pre></td></tr><tr><td class="docs"><p>Authenticate</p>
</td><td class="codes"><pre class="brush: clojure">(defn authenticate-user [requester userref password]
  (let [user (auth/lookup-user-for-auth userref)]
    (cond (not user)
          (with-meta {:error_msg &quot;User or password not recognized&quot;}
            {:code 401})
          (auth/valid-password? user password)
          {:auth_token (generate-token requester (:username user))
           :expires (expiration)})))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn authenticated-user [token]
  (token-&gt;user token))</pre></td></tr><tr><td class="docs"><p>Authenticate API Request</p>
</td><td class="codes"><pre class="brush: clojure">(defapi omh-authenticate [:get &quot;/omh/v1.0/authenticate&quot;]
  {:keys [username password requester] :as options}
  (authenticate-user requester username password))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defapi omh-auth-get [:get &quot;/omh/v1.0/authenticate&quot;]
  {:keys [username password requester] :as options}
  (authenticate-user requester username password))</pre></td></tr><tr><td class="docs"><h2>Server STATUS</h2>
</td><td class="codes"></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defapi omh-status [:get &quot;/omh/v1.0/status&quot;]
  {:as options}
  {:status &quot;alive&quot;
   :foo &quot;bar&quot;})</pre></td></tr><tr><td class="docs"><h2>Server READ</h2>
</td><td class="codes"></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defmacro with-user [[sym token] &amp; body]
  `(if-let [~sym (authenticated-user ~token)]
     ~@body
     (with-meta {:errors [&quot;Invalid or expired auth_token&quot;]}
      {:code 401})))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn read-response [user]
  {:time_start (dt/as-iso-8601 (time/minus (dt/now) (time/days 30)))
   :time_end (dt/as-iso-8601 (dt/now))
   :time_next nil 
   :time_final nil
   :local_time_valid true
   :column_names [&quot;time&quot; &quot;value&quot; &quot;location&quot;]
   :column_definitions 
   :pe_username (:username user)
   {:time {:payload_id &quot;urn:omh:measure:time:iso8601&quot;}
    :temp {:payload_id &quot;urn:omh:measure:temperature&quot;
           :units &quot;farenheight&quot;}}
   :data
   [[(time/minus (dt/now) (time/days 1)) 86.8 {:lat 38.8 :lon -77.0}]
    [(dt/now) 87.4 {:lat 38.8 :lon -77.0}]]})</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defapi omh-read [:get &quot;/omh/v1.0/read&quot;]
  {:keys [auth_token source_name
          time_start time_end column_names]}
  (with-user [user auth_token]
    (read-response user)))</pre></td></tr><tr><td class="docs"><h2># LINT</h2>
</td><td class="codes"></td></tr><tr><td class="docs"><p>/omh/v1.0/lint</p>
</td><td class="codes"><pre class="brush: clojure">(defapi omh-lint  {:as options}
  {:success false
   :messages [&quot;Lint Not Supported&quot;]})</pre></td></tr><tr><td class="docs"><h2># CATALOG</h2>
</td><td class="codes"></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn parse-source [source]
  (str/split source))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn source-name [instrument]
  (str (:variable instrument) &quot;:&quot; (:src instrument)))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn catalog-entry [tracker]
  (let [instrument (resolve-dbref (:instrument tracker))]
    [(source-name instrument)
     {:source_class {:name (:src instrument) :columns []}}]))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn catalog
  ([user] 
     (into {} (map catalog-entry (user/trackers user))))
  ([user source]
     (let [[var src] (parse-source source)]
       (map catalog-entry
            (filter (fn [tracker]
                      (let [inst (resolve-dbref (:instrument tracker))]
                        (and (= (:variable inst) var)
                             (= (:src inst) src))))
                    (user/trackers user))))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defapi omh-catalog [:get &quot;/omh/v1.0/catalog&quot;]
  {:keys [source_name auth_token]}
  (with-user [user auth_token]
    (vec (if source_name
           (catalog user source_name)
           (catalog user)))))</pre></td></tr><tr><td class="spacer docs">&nbsp;</td><td class="codes" /></tr><tr><td class="docs"><div class="docs-header"><a class="anchor" href="#experiment.model.omh-client" name="experiment.model.omh-client"><h1 class="project-name">experiment.model.omh-client</h1><a class="toc-link" href="#toc">toc</a></a></div></td><td class="codes" /></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(ns experiment.model.omh-client
  (:use
   experiment.models.samples)
  (:require
   [clj-time.core :as time]
   [experiment.models.user :as user]
   [experiment.libs.datetime :as dt]
   [clj-json.core :as json]
   [clj-http.client :as http]))</pre></td></tr><tr><td class="docs"><h2>CLIENT</h2>
</td><td class="codes"></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(def requester &quot;PersonalExperiments.org&quot;)</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(def default-endpoint
  {:root &quot;http://localhost:8080/omh&quot;
   :ver &quot;v1.0&quot;
   :token &quot;32fe7db5-6b67-473b-ae99-801f8ec8fab2&quot;})</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn set-default-endpoint [default]
  (alter-var-root #'default-endpoint (fn [old] default)))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn- gen-url [endpoint cmd]
  (str (:root endpoint) &quot;/&quot; (:ver endpoint) cmd))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn- do-get [endpoint cmd &amp; {:as params}]
  (http/get (gen-url endpoint cmd)
            {:query-params
             (assoc params
               :auth_token (:token endpoint))}))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn- do-post [endpoint cmd &amp; {:as params}]
  (http/post (gen-url endpoint cmd)
             {:query-params
              (assoc params
                :auth_token (:token endpoint))}))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn- parse-response [response]
  (if (= (:status response) 200)
    (json/parse-string (:body response) true)
    (throw (java.lang.Error. (:status response)))))</pre></td></tr><tr><td class="docs"><p>Authenticate</p>
</td><td class="codes"><pre class="brush: clojure">(defn- do-authenticate-request [endpoint user password]
  (do-post endpoint &quot;/authenticate&quot;
          :username user
          :password password
          :requester requester))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn authenticate
  ([endpoint user password]
     (let [response (do-authenticate-request endpoint user password)]
       (parse-response (json/parse-string (:body response) true))))
  ([user password]
     (authenticate default-endpoint user password)))</pre></td></tr><tr><td class="docs"><p>Status</p>
</td><td class="codes"><pre class="brush: clojure">(defn status
  ([endpoint]
     (parse-response (do-get endpoint &quot;/status&quot;)))
  ([]
     (status default-endpoint)))</pre></td></tr><tr><td class="docs"><h2>Testing</h2>
</td><td class="codes"></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn test-error []
  (do-get default-endpoint &quot;/status2&quot;))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn test-auth-error []
  (authenticate default-endpoint &quot;eslick2&quot; &quot;foo&quot;))</pre></td></tr><tr><td class="spacer docs">&nbsp;</td><td class="codes" /></tr><tr><td class="docs"><div class="docs-header"><a class="anchor" href="#experiment.models.profile" name="experiment.models.profile"><h1 class="project-name">experiment.models.profile</h1><a class="toc-link" href="#toc">toc</a></a></div></td><td class="codes" /></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(ns experiment.models.profile
  (:use experiment.infra.models
        noir.core
        hiccup.core
        hiccup.page-helpers
	hiccup.form-helpers
	handlebars.templates)
  (:require [experiment.libs.datetime :as dt]
            [experiment.infra.session :as session]))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn timezone-list []
  [[&quot;AST -4&quot; &quot;ast&quot;]
   [&quot;PST -5&quot; &quot;pst&quot;]
   [&quot;MST -6&quot; &quot;mst&quot;]
   [&quot;CST -7&quot; &quot;cst&quot;]
   [&quot;EST -8&quot; &quot;est&quot;]])</pre></td></tr><tr><td class="docs"><p>Internal accessors</p>
</td><td class="codes"></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn get-user-profile [user]
  (:profile user))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn set-user-profile!
  ([user profile]
     (set-submodel! user :profile profile)))</pre></td></tr><tr><td class="spacer docs">&nbsp;</td><td class="codes" /></tr><tr><td class="docs"><div class="docs-header"><a class="anchor" href="#experiment.models.samples" name="experiment.models.samples"><h1 class="project-name">experiment.models.samples</h1><a class="toc-link" href="#toc">toc</a></a></div></td><td class="codes" /></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(ns experiment.models.samples
  (:use experiment.infra.models
        clojure.math.numeric-tower)
  (:require [somnium.congomongo :as mongo]
            [experiment.models.schedule :as schedule]
            [clj-time.core :as time]
            [experiment.libs.datetime :as dt]))</pre></td></tr><tr><td class="docs"><h2>User:</h2>

<ul>
<li>ID</li>
</ul>
</td><td class="codes"></td></tr><tr><td class="docs"><h2>Instrument:</h2>

<ul>
<li>ID</li>
<li>sampling
<ul><li>interval (chunk interval)</li>
<li>poll-freq (how often to check for new data - daily, hourly, weekly)</li></ul></li>
</ul>
</td><td class="codes"></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn chunk-interval [inst]
  (get-in inst [:sampling :chunksize] :month))</pre></td></tr><tr><td class="docs"><h2>Sample:</h2>

<p>- :ts
- :v <default or time-series value>
- <can have arbitrary extra data, but has cost impact on queries></p>
</td><td class="codes"></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn valid-sample? [sample]
  (and (:ts sample)
       (= (type (:ts sample)) org.joda.time.DateTime)
       (:v sample)
       true))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn valid-samples? [samples]
  (and (or (list? samples) (vector? samples))
       (every? valid-sample? samples)))</pre></td></tr><tr><td class="docs"><p>Convert Joda Time objects to Java Date objects</p>
</td><td class="codes"><pre class="brush: clojure">(defn- as-chunk-sample
  [sample]
  (update-in sample [:ts] dt/as-date))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn- as-native-sample
  [sample]
  (update-in sample [:ts] dt/from-date))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn- merge-sample [old new]
  (assert (= (:start old) (:start new)))
  (merge old new))</pre></td></tr><tr><td class="docs"><p>Identity is determined by :ts date object;
   new values trump old values according to merge policy
   all non-conflicting values are included</p>
</td><td class="codes"><pre class="brush: clojure">(defn- merge-samples
  [old new]
  (vals
   (merge-with
    merge-sample
    (zipmap (map :ts old) old)
    (zipmap (map :ts new) new))))</pre></td></tr><tr><td class="docs"><h2>Chunk:</h2>

<ul>
<li>ID</li>
<li>user</li>
<li>inst</li>
<li>start <date></li>
<li>samples []
<ul><li>ts</li>
<li>v</li>
<li><domain-specific></li></ul></li>
<li>stats
<ul><li>sum (v)</li>
<li>count (v)</li></ul></li>
</ul>
</td><td class="codes"></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn- get-chunk [u i base &amp; [restrict?]]
  (mongo/fetch-one
   :chunks
   :where {:user (:_id u)
           :inst (:_id i)
           :start (dt/as-date base)}))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn- update-chunk [u i base old-chunk samples]
  (let [select {:user (:_id u)
                :inst (:_id i)
                :start (dt/as-date base)}
        update {:$set {:updated (dt/as-date (dt/now))
                       :samples samples
                       :stats.count (count samples)
                       :stats.sum (when (number? (:v (first samples)))
                                    (apply + (map :v samples)))
                       }}]
    (mongo/update!
     :chunks
     (if old-chunk
       (assoc select
         :stats.count (get-in old-chunk [:stats :count])
         :stats.sum (get-in old-chunk [:stats :sum]))
       select)
     update
     :upsert (not old-chunk))))</pre></td></tr><tr><td class="docs"><p>Given a user and interval, return a function
   that will update the state of a chunk for a given
   base date and set of samples</p>
</td><td class="codes"><pre class="brush: clojure">(defn- chunk-update-fn
  [u i]
  (assert (and (= (:type u) &quot;user&quot;) (= (:type i) &quot;instrument&quot;)
               (:_id u) (:_id i)))
  (fn [[base-date samples]]
    (let [old-chunk    (get-chunk u i base-date)
          old-samples  (:samples old-chunk)
          new-samples  (merge-samples old-samples
                                      (map as-chunk-sample samples))
          result       (update-chunk u i base-date
                                     old-chunk new-samples)]
      true)))</pre></td></tr><tr><td class="docs"><p>Return a canonical date given the chunksize period</p>
</td><td class="codes"><pre class="brush: clojure">(defn- date-decimator-fn
  [chunksize key-fn]
  (comp (schedule/decimate-fn chunksize) key-fn))</pre></td></tr><tr><td class="docs"><p>Return samples as groups defined by date decimator</p>
</td><td class="codes"><pre class="brush: clojure">(defn sample-groups
  [inst samples]
  (assert (valid-samples? samples))
  (group-by (date-decimator-fn (chunk-interval inst) :ts)
            samples))</pre></td></tr><tr><td class="docs"><p>Return a where clause for mongo lookups to get the target chunks</p>
</td><td class="codes"><pre class="brush: clojure">(defn- chunk-select
  ([u i]
     {:inst (:_id i) :user (:_id u)})
  ([u i options]
     (let [{:keys [start end]} options]
       (merge (chunk-select u i)
              (when start
                {:start {:$gte (dt/as-date start)}})
              (when end
                {:start {:$lt (dt/as-date end)}})))))</pre></td></tr><tr><td class="docs"><p>Return a filter function to select only those samples
   meeting the criterion outlined in the option set</p>
</td><td class="codes"><pre class="brush: clojure">(defn- sample-filter-fn
  ([options]
     (let [{:keys [start end]} options]
       (fn [sample]
         (and sample
              (or (not start)
                  (time/after? (:ts sample) start))
              (or (not end)
                  (time/before? (:ts sample) end)))))))</pre></td></tr><tr><td class="docs"><p>If more than one point exists for decimation level, remove the
   earlier one.</p>
</td><td class="codes"><pre class="brush: clojure">(defn- batch-remove-overlapping-samples
  [instrument samples]
  (let [dfn (date-decimator-fn (keyword (or (:pointscale instrument) &quot;day&quot;)) :ts)]
    (map (fn [samples]
           (if (&gt; (count samples) 1)
             (first (reverse (sort-by :ts samples)))
             (first samples)))
         (map second
              (group-by (fn [sample]
                          (dfn sample))
                        samples)))))</pre></td></tr><tr><td class="docs"><p>If more than one point exists for decimation level, remove the
   earlier one.  Input must be sorted.</p>
</td><td class="codes"><pre class="brush: clojure">(defn- remove-overlapping-samples
  [instrument samples]
  (let [dfn (date-decimator-fn (keyword (or (:pointscale instrument) &quot;day&quot;)) :ts)]
    (loop [last nil
           results '()
           samples samples]
      (if (empty? samples)
        (reverse (cons last results))
        (if (and last (= (compare (dfn last) (dfn (first samples))) 0))
          (recur (first samples) results (next samples))
          (recur (first samples) (if last (cons last results) results) (next samples)))))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn- update-all-samples [fn &amp; [inhibit]]
  (doseq [chunk (doall (mongo/fetch :chunks))]
    (let [samples (doall (map fn (:samples chunk)))]
      (when (and (not inhibit)
                 (= (count samples) (count (:samples chunk)))
                 (not (= samples (:samples chunk))))
        (update-model!
         (assoc chunk :samples samples))))))</pre></td></tr><tr><td class="docs"><p>API</p>
</td><td class="codes"></td></tr><tr><td class="docs"><p>Insert new samples into array</p>
</td><td class="codes"><pre class="brush: clojure">(defn add-samples
  [u i data]
  (doall
   (map (chunk-update-fn u i)
        (sample-groups i data))))</pre></td></tr><tr><td class="docs"><p>Remove samples</p>
</td><td class="codes"><pre class="brush: clojure">(defn rem-samples
  [u i &amp; {:keys [start end] :as options}]
  (mongo/destroy! :chunks
                  :where (chunk-select u i options)))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(def mytest (atom nil))</pre></td></tr><tr><td class="docs"><p>Get a sequence of samples {:ts <date> :v <any> ...}</p>
</td><td class="codes"><pre class="brush: clojure">(defn get-samples
  [u i &amp; {:keys [start end] :as options}]
  (-&gt;&gt; (mongo/fetch :chunks
                    :where (chunk-select u i options)
                    :only [:samples])
       (mapcat :samples)
       (map as-native-sample)
       (sort-by :ts)
       (remove-overlapping-samples i)
       (filter (sample-filter-fn options))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn last-sample [u i]
  (-&gt;&gt; (mongo/fetch :chunks
                    :where (chunk-select u i)
                    :only [:samples]
                    :limit 1
                    :sort {:start -1})
       first
       :samples
       (sort-by :ts)
       first
       as-native-sample))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn last-sample-time [u i]
  (:ts (last-sample u i)))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn last-updated-time [u i]
  (when-let [updated
             (-&gt;&gt; (mongo/fetch :chunks
                               :where (chunk-select u i)
                               :only [:updated]
                               :limit 1
                               :sort {:start -1})
                  first
                  :updated)]
    (dt/from-date updated)))</pre></td></tr><tr><td class="spacer docs">&nbsp;</td><td class="codes" /></tr><tr><td class="docs"><div class="docs-header"><a class="anchor" href="#experiment.models.schedule" name="experiment.models.schedule"><h1 class="project-name">experiment.models.schedule</h1><a class="toc-link" href="#toc">toc</a></a></div></td><td class="codes" /></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(ns experiment.models.schedule
  (:use
   experiment.infra.models
   [clj-time.core :as time :exclude [extend]])
  (:require
   [experiment.models.user :as user]
   [experiment.libs.datetime :as dt]))</pre></td></tr><tr><td class="docs"><h2>Scheduling</h2>

<p>Methods to convert a scheduling object associated with a tracker or trial
into a set of events dictated by the schedule's event template</p>

<p>Exports: (events <schedule> <interval>)
         (periods <schedule>)</p>

<p>Schedule Object:
{
 :type "schedule"
 :stype [ "daily" | "weekly | "periodic" ]
 :times <seconds>
 :event {...}
}</p>
</td><td class="codes"></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defmethod public-keys :schedule [sched]
  (keys sched))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defmethod import-keys :schedule [sched]
  (keys sched))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn- valid-type? [type]
  (#{&quot;daily&quot;, &quot;weekly&quot;, &quot;periodic&quot;} type))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn make-schedule [type event &amp; {:as options}]
  (assert (valid-type? type))
  (merge {:type &quot;schedule&quot;
          :stype type
          :event event}
         options))</pre></td></tr><tr><td class="docs"><h2>Scheduler utilities</h2>
</td><td class="codes"></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn decimate-fn [chunksize]
  (case (keyword chunksize)
    :year #(from-time-zone (date-time (year %)) (.getZone %))
    :month #(from-time-zone (date-time (year %) (month %)) (.getZone %))
    :week #(let [date (from-time-zone (date-time (year %) (month %) (day %)) (.getZone %))]
             (.roundFloorCopy (.weekOfWeekyear date)))
    :day #(from-time-zone (date-time (year %) (month %) (day %)) (.getZone %))
    :hour #(from-time-zone (date-time (year %) (month %) (day %) (hour %)) (.getZone %))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn decimate [chunksize dt]
  ((decimate-fn chunksize) dt))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn local-now []
  (to-time-zone (now) (time-zone-for-offset -8)))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn random-minutes [range]
  (minutes (int (- (rand range) (/ range 2)))))</pre></td></tr><tr><td class="docs"><p>Given an event with a :jitter value, apply the jitter computation
   to change the :start instant of the event to +/- (int (/ jitter 2))</p>
</td><td class="codes"><pre class="brush: clojure">(defn jitter-event
  ([event]
     (if-let [jitter (:jitter event)]
       (assoc event
         :start (plus (:start event) (random-minutes jitter)))
       event)))</pre></td></tr><tr><td class="docs"><p>Given an interval of time, return a sequence of date-time
   objects representing the starting instant of the days
   that lie within the interval in the same timezone</p>
</td><td class="codes"><pre class="brush: clojure">(defn interval-&gt;days
  ([i]
     (assert (= (type i) org.joda.time.Interval))
     (lazy-seq
      (let [start (decimate :day (dt/in-session-tz (start i)))
            newstart (plus start (days 1))]
        (if (before? newstart (end i))
          (cons start (interval-&gt;days (interval newstart (end i))))
          (cons start nil))))))</pre></td></tr><tr><td class="docs"><p>Given an interval of time, return a sequence of date-time
   objects representing the starting instant of the weeks
   in the same timezone that lie within the interval</p>
</td><td class="codes"><pre class="brush: clojure">(defn interval-&gt;weeks
  ([i]
     (assert (= (type i) org.joda.time.Interval))
     (lazy-seq
      (let [start (decimate :week (start i))
            newstart (plus start (weeks 1))]
        (if (before? newstart (end i))
          (cons start (interval-&gt;days (interval newstart (end i))))
          (cons start nil))))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn events-within [interval events]
  (filter (comp (partial within? interval) :start) events))</pre></td></tr><tr><td class="docs"><h2>Basic interface, relies on embedded event template and dispatch</h2>
</td><td class="codes"></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn schedule-dispatcher
  ([schedule &amp; rest]
     (assert (= (:type schedule) &quot;schedule&quot;))
     (keyword (:stype schedule))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defmulti events schedule-dispatcher)</pre></td></tr><tr><td class="docs"><h2>Scheduler types</h2>
</td><td class="codes"></td></tr><tr><td class="docs"><p>Daily
Every day, one or more fixed times
:times - [{:hour :min}, ...] event times
:jitter +/- jitter minutes for each time spec</p>
</td><td class="codes"></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn daily-events [schedule day-dt]
  (assert (= (:stype schedule) &quot;daily&quot;))
  (let [day-dt (dt/to-session-tz day-dt)]
    (for [{:keys [hour min] :or {min 0}} (:times schedule)]
      (assoc (:event schedule)
        :status &quot;pending&quot;
        :start (dt/in-server-tz (plus day-dt (hours hour) (minutes min)))
        :jitter (:jitter schedule)))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defmethod events :daily [schedule &amp; [interval]]
  (assert (:times schedule))
  (-&gt;&gt; (interval-&gt;days interval)
       (mapcat (partial daily-events schedule))
       (events-within interval)
       (map jitter-event)))</pre></td></tr><tr><td class="docs"><p>Weekly
Events for one or more days a week
:times - [{:day :hour :min}, ...] event times
:jitter - +/- jitter minutes for each time</p>
</td><td class="codes"></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn weekly-events [schedule week-dt]
  (for [{:keys [day hour min]} (:times schedule)]
    (let [week-dt (dt/to-session-tz week-dt)
          day-dt (.withDayOfWeek (plus week-dt (hours hour) (minutes min)) day)]
      (assoc (:event schedule)
        :status &quot;pending&quot;
        :start (dt/in-server-tz day-dt)
        :jitter (:jitter schedule)))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defmethod events :weekly [schedule interval]
  (assert (:times schedule))
  (-&gt;&gt; (interval-&gt;weeks interval)
       (mapcat (partial weekly-events schedule))
       (events-within interval)
       (map jitter-event)))</pre></td></tr><tr><td class="docs"><p>Periodic
Support periods schedules within a set of periods
:periods - list of intervals {:start dt :end dt}
:schedule - schedule to maintain during those intervals</p>
</td><td class="codes"></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn- periodic-interval [label start duration]
  (let [end (time/plus start (time/days duration))
        interval (interval start end)]
    {:label label :interval interval}))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn- periodic-record-intervals
  ([rec]
     (periodic-record-intervals (or (:start rec) (dt/now)) rec))
  ([start rec]
     (update-in rec [:periods]
                (fn [orig]
                  (-&gt; (reduce (fn [[accum st] [label duration]]
                                (let [rec (periodic-interval label st duration)]
                                  [(cons rec accum) (.getEnd (:interval rec))]))
                              ['() start]
                              orig)
                      first
                      reverse)))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn- period-overlaps? [inter period]
  (overlaps? inter (:interval period)))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn- select-subevent-periods [schedule periods]
  (if-let [types (set (:event-periods schedule))]
    (filter (comp types :label) periods)
    periods))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn periods-overlapping [schedule interval periods]
  (filter (partial period-overlaps? interval)
          (if schedule
            (select-subevent-periods schedule periods)
            periods)))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defmethod events :periodic [schedule interval]
  (assert (:periods schedule))
  (-&gt;&gt; (:periods (periodic-record-intervals schedule))
       (periods-overlapping schedule interval)
       (mapcat (fn [period]
                 (println period)
                 (events (:event-schedule schedule)
                         (.overlap interval (:interval period)))))))</pre></td></tr><tr><td class="docs"><p>Period scheduler</p>
</td><td class="codes"></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn periods [schedule]
  (:periods (periodic-record-intervals schedule)))</pre></td></tr><tr><td class="spacer docs">&nbsp;</td><td class="codes" /></tr><tr><td class="docs"><div class="docs-header"><a class="anchor" href="#experiment.models.suggestions" name="experiment.models.suggestions"><h1 class="project-name">experiment.models.suggestions</h1><a class="toc-link" href="#toc">toc</a></a></div></td><td class="codes" /></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(ns experiment.models.suggestions
  (:use
   noir.core
   experiment.infra.models 
   experiment.infra.api
   [experiment.models.core]
   [experiment.models.user])
  (:import [org.bson.types ObjectId])
  (:require
   [somnium.congomongo :as mongo]
   [noir.response :as response]
   [noir.request :as request]
   [clojure.string :as str]
   [cheshire.core :as json]
   [experiment.libs.fulltext :as ft]))</pre></td></tr><tr><td class="docs"><p>This file generates a dictionary of autoSuggest objects which
are used to generate a list of conditions for searching the
system's objects.  Right now we're doing this client side, but
we can easily move this to the server later and use mongo
to do the search rather than programmatically on the client.</p>
</td><td class="codes"></td></tr><tr><td class="docs"><p>Types</p>
</td><td class="codes"><pre class="brush: clojure">(defn- gen-types []
  [{:trigger &quot;show&quot;
    :value &quot;show experiment&quot;
    :title &quot;Experiments&quot;}
   {:trigger &quot;show&quot;
    :value &quot;show treatment&quot;
    :title &quot;Treatments&quot;}
   {:trigger &quot;show&quot;
    :value &quot;show instrument&quot;
    :title &quot;Instruments&quot;}
   {:trigger &quot;show&quot;
    :value &quot;show all&quot;
    :title &quot;All&quot;}])</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn- symptom-suggestion [tag]
  {:trigger &quot;for&quot;
   :value (str &quot;for &quot; tag)
   :title tag})</pre></td></tr><tr><td class="docs"><p>All tags from treatments</p>

<p>Symptoms and Conditions</p>
</td><td class="codes"><pre class="brush: clojure">(defn- gen-symptoms+conditions
  []
  (map symptom-suggestion
   (reduce clojure.set/union
	   (map #(set (concat (:tags %) (:nicknames %)))
		(fetch-models :treatment :only [:tags :nicknames])))))</pre></td></tr><tr><td class="docs"><p>Instrument</p>
</td><td class="codes"><pre class="brush: clojure">(defn- instrument-suggestion [inst]
  {:trigger &quot;use&quot;
   :title (:variable inst)
   :value (str &quot;use &quot; (serialize-id (:_id inst)))
   :search (str (:nicknames inst) &quot; &quot; (:src inst))
   })</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn- gen-instruments []
  (map instrument-suggestion
       (fetch-models :instrument :only [:variable :nicknames :src])))</pre></td></tr><tr><td class="docs"><p>Treatment</p>
</td><td class="codes"><pre class="brush: clojure">(defn- treatment-suggestion [treat]
  {:trigger &quot;with&quot;
   :value (str &quot;with &quot; (serialize-id (:_id treat)))
   :title (:name treat)
   :search (:description treat)})</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn- gen-treatments []
  (map treatment-suggestion
       (fetch-models :treatment :only [:name :description])))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn compute-suggestions []
  (concat
   (gen-types)
   (gen-treatments)
   (gen-symptoms+conditions)
   (gen-instruments)))</pre></td></tr><tr><td class="docs"><p>API for taking filter conditions and returning a list of model references</p>
</td><td class="codes"></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn- model-&gt;client-ref [model]
  (if (and (:type model) (:_id model))
    [(:type model) (serialize-id (:_id model))]
    []))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn- model-&gt;db-id [model]
  (assert (= (type (:_id model)) ObjectId))
  (:_id model))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn- id-&gt;db-id [id]
  (mongo/object-id id))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn- strip-filters [type filters]
  (map #(.substring % (+ 1 (count type)))
       (filter #(re-find (re-pattern (str &quot;^&quot; type &quot; &quot;)) %) filters)))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn- show? [type filters]
  (let [types (set (strip-filters &quot;show&quot; filters))]
    (or (empty? types)
	(types &quot;all&quot;)
	(types type))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn- fulltext-regex [filters]
  (str/join &quot;|&quot;
   (filter #(not (re-find #&quot;^(show|with|for|use)&quot; %)) filters)))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn- treatment-filter [filters]
  (let [fors (strip-filters &quot;for&quot; filters)
	ids (strip-filters &quot;with&quot; filters)
	fulltext (fulltext-regex filters)]
    (merge (when (not (empty? fors))
	     {:tags {:$in fors}})
	   (when (not (empty? ids))
	     {:_id {:$in ids}})
	   (when (&gt; (count fulltext) 0)
	     {:description {:$regex fulltext :$options &quot;i&quot;}}))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn- filter-treatments [filters]
  (if (some #(re-find #&quot;^use&quot; %) filters)
    []
    (fetch-models :treatment (treatment-filter filters))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn- instrument-filter [filters]
  (let [fulltext (fulltext-regex filters)
	fors (strip-filters &quot;for&quot; filters)]
    (merge
     (when (&gt; (count fulltext) 0)
       {:description {:$regex fulltext :$options &quot;i&quot;}})
     (when (not (empty? fors))
       {:tags {:$all fors}}))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn- filter-instruments [filters]
  (if (some #(re-find #&quot;^use|^with&quot; %) filters)
    []
    (fetch-models :instrument  (instrument-filter filters))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn- experiment-filter [treatments filters]
  (let [fulltext (fulltext-regex filters)
	with-refs (map id-&gt;db-id (strip-filters &quot;with&quot; filters))
	treatment-refs (map model-&gt;db-id treatments)
	treatment-ids (concat with-refs treatment-refs)
	instrument-ids (map id-&gt;db-id (strip-filters &quot;use&quot; filters))]
    (merge (when (not (empty? fulltext))
	     {}) ;; NOTE: fulltext search of comments?
	   (when (not (empty? treatment-ids))
	     {:treatment.$id {:$in treatment-ids}})
	   (when (not (empty? instrument-ids))
	     {:instruments.$id {:$in instrument-ids}}))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn- filter-experiments [treatments filters]
  (fetch-models :experiment (experiment-filter treatments filters)))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn filter-models [filters]
  (let [treatments (filter-treatments filters)
        instruments (filter-instruments filters)
        experiments (filter-experiments treatments filters)]
    (concat (when (show? &quot;experiment&quot; filters) experiments)
	    (when (show? &quot;treatment&quot; filters) treatments)
	    (when (show? &quot;instrument&quot; filters) instruments))))</pre></td></tr><tr><td class="docs"><p>/api/fsearch</p>
</td><td class="codes"><pre class="brush: clojure">(defpage filtered-search  {:keys [query limit]}
  (let [filters (str/split query #&quot;,&quot;)]
    (response/json
     (vec
      (map model-&gt;client-ref
	   (filter-models filters))))))</pre></td></tr><tr><td class="docs"><h2>New Style Search</h2>
</td><td class="codes"></td></tr><tr><td class="docs"><h2>Special constraints on search</h2>
</td><td class="codes"></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn trim-plural [string]
  (if (= (last string) \s)
    (.substring string 0 (- (count string) 1))
    string))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(def constraint-exprs
  [[:type &quot;show&quot; trim-plural]
   [:tags &quot;for&quot;]
   [:treatment &quot;with&quot;]
   [:service &quot;using&quot;]])</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn- match-prefix [term arg]
  (some (fn [[field prefix pfn]]
          (when (= term prefix)
            {field ((or pfn identity) arg)}))
        constraint-exprs))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn- parse-query-map [query]
  (if (= query &quot;*&quot;)
    {:type &quot;treatment&quot;}
    (loop [terms (str/split query #&quot; &quot;)
           cmap {}
           default-query ]
      (if (&lt; (count terms) 2)
        (assoc cmap
          :default (str/trim (str/join &quot; &quot; (cons default-query terms))))
        (if-let [constraint (match-prefix (first terms) (second terms))]
          (recur (drop 2 terms) (merge cmap constraint) default-query)
          (recur (drop 1 terms) cmap (str/join &quot; &quot; [(first terms) default-query])))))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn search-response [result-map]
  (response/json
   (dissoc
    (update-in result-map [:models] (comp vec server-&gt;client))
    :results)))</pre></td></tr><tr><td class="docs"><p>/api/search/query/:q/:n/:skip</p>
</td><td class="codes"><pre class="brush: clojure">(defpage query-srch  {:keys [q n skip]}
  (let [n (Integer/parseInt (or n &quot;10&quot;))
        skip (Integer/parseInt (or skip &quot;0&quot;))]
    (search-response
     (ft/search (parse-query-map q) :size n :skip skip))))</pre></td></tr><tr><td class="docs"><p>/api/search/tag/:q/:n/:skip</p>
</td><td class="codes"><pre class="brush: clojure">(defpage tag-srch  {:keys [q n skip]}
  (let [n (Integer/parseInt (or n &quot;10&quot;))
        skip (Integer/parseInt (or skip &quot;0&quot;))]
    (search-response
     (ft/search {:tags q} :size n :skip skip))))</pre></td></tr><tr><td class="docs"><p>RELATED OBJECTS (Treatment->Experiments, Outcomes)</p>
</td><td class="codes"></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn fetch-related [type dbref]
  (case type
    &quot;treatment&quot;
    (fetch-models :experiment {:treatment dbref})
    &quot;experiment&quot;
    (let [model (resolve-dbref dbref)]
      (remove #(= % model)
              (fetch-models :experiment
                            {:$or [{:treatment (:treatment model)}
                                   {:instruments {:$in (:instruments model)}}]})))
    &quot;instrument&quot;
    (let [inst (resolve-dbref dbref)]
      (concat (fetch-models :experiment {:instruments dbref})
              (remove #(= % inst)
                      (fetch-models :instrument {:service (:service inst)}))))))</pre></td></tr><tr><td class="docs"><p>/api/search/related/:type/:id</p>
</td><td class="codes"><pre class="brush: clojure">(defpage related  {:keys [type id]}
  (let [oid (deserialize-id id)
        ref (as-dbref type oid)]
    (let [results (fetch-related type ref)]
      (search-response
       {:models results
        :hits (count results)}))))</pre></td></tr><tr><td class="spacer docs">&nbsp;</td><td class="codes" /></tr><tr><td class="docs"><div class="docs-header"><a class="anchor" href="#experiment.models.trackers" name="experiment.models.trackers"><h1 class="project-name">experiment.models.trackers</h1><a class="toc-link" href="#toc">toc</a></a></div></td><td class="codes" /></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(ns experiment.models.trackers
  (:use experiment.infra.models
        experiment.models.user
        experiment.models.instruments)
  (:require [clj-time.core :as time]
            [clojure.tools.logging :as log]
	    [experiment.libs.datetime :as dt]
            [experiment.libs.sms :as sms]
	    [experiment.models.samples :as samples]
	    [experiment.models.schedule :as schedule]
	    [experiment.models.events :as event]))</pre></td></tr><tr><td class="docs"><h2>Instrument Trackers</h2>

<p>Trackers are associated with active trials or can be standalone
if a user decides to track specific parameters.  The instrument
template determines the parameters of the tracker.  The tracker
in turn dictates the specific tracking events (when appropriate)</p>
</td><td class="codes"></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn tracker-events [tracker interval]
  (when-let [schedule (:schedule tracker)]
    (when (:stype schedule)
      (let [refs (select-keys tracker [:user :instrument])]
        (map #(merge % refs) (schedule/events schedule interval))))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn all-tracker-events [user interval]
  (mapcat #(tracker-events % interval) (trackers user)))</pre></td></tr><tr><td class="docs"><h2>Service-based Trackers</h2>

<p>Download for service-based trackers are done automatically, no
explicit event generation is provided at present.</p>
</td><td class="codes"></td></tr><tr><td class="docs"><h2>SMS-based Tracker Protocol</h2>

<p>We allow the web to satisfy a future or past (ignored) SMS event
as a hack to support manual tracking via a web interface</p>
</td><td class="codes"></td></tr><tr><td class="docs"><h2>Fire an SMS Event</h2>
</td><td class="codes"></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn- sms-prefix-message [event]
  (if-let [prefix (:sms-prefix event)]
    (str (:message event) &quot; (respond by texting '&quot; prefix &quot; &lt;answer&gt;')&quot;)))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defmethod event/fire-event :sms [event]
  (let [number (get-pref (event/event-user event) :cell)
        message (sms-prefix-message event)]
    (sms/send-sms number message)
    (let [status (if (event/requires-reply? event) &quot;active&quot; &quot;done&quot;)]
      (event/set-status event status))))</pre></td></tr><tr><td class="docs"><h2>Complete SMS Events on SMS reply</h2>
</td><td class="codes"></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn complete-event-with-sample [user sample]
  (let [{:keys [event ts v]} sample
        {:keys [instrument]} event
        inst (resolve-dbref instrument)]
    (samples/add-samples user inst (list (dissoc sample :event)))
    (event/complete event ts v)
    (fetch-model :event {:_id (:_id event)})))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn cancel-event [user sample]
  (let [{:keys [event ts]} sample]
    (event/cancel event ts)))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn associate-message-with-events [user events ts text]
  (let [samples (keep (partial sms/parse-sms text ts) events)]
    (cond (empty? samples)
          (do (log/info
               (str &quot;Failed to parse response from &quot; (:username user)
                    &quot;: '&quot; text &quot;'&quot;))
              nil)
          (= (count samples) 1)
          (complete-event-with-sample user (first samples))
          true
          (do (log/warn &quot;Multiple matching samples for &quot; (:username user)
                        &quot;: '&quot; text &quot;' -- removing old and associating with latest&quot;)
              (doall (map (partial cancel-event user) (butlast samples)))
              (complete-event-with-sample user (last samples))))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn associate-message-with-user [user ts text]
  (let [events (event/get-events :user user :type &quot;sms&quot; :status &quot;active&quot;)]
    (associate-message-with-events user events ts text)))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn associate-message-with-tracker [user ts text]
  ;; TODO: Lookup trackers that can parse unsolicited sms messages?
  (:trackers user)
  false)</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn- user-for-cell-number [num]
  (fetch-model :user {:profile.cell num}))</pre></td></tr><tr><td class="docs"><p>Main handler for SMS replies from our texting service.
   Given a number and message, parse it, associate it with
   an event and submit the resulting data as a sample if
   appropriate.  (TODO) Send failure messages if no parser
   matches or on a failure to parse</p>
</td><td class="codes"><pre class="brush: clojure">(defn sms-reply-handler
  [ts number text]
  (let [user (user-for-cell-number number)]
    (or (associate-message-with-events user ts text)
        (associate-message-with-tracker user ts text))))</pre></td></tr><tr><td class="docs"><h2>Example</h2>
</td><td class="codes"></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(comment
  (defn make-tracker [user instrument params]
    {:type &quot;tracker&quot;
     :user (as-dbref user)
     :instrument (as-dbref instrument)
     :schedule {:type &quot;schedule&quot;
                :stype &quot;daily&quot;
                :times [{:hour 10 :min 0} {:hour 21 :min 0}]
                :jitter 5
                :wait true
                :event {:type &quot;event&quot;
                        :etype &quot;sms&quot;
                        :message &quot;What is your energy today? Reply 'e [0-10]' where 0 is lowest and 10 is manic&quot;
                        :sms-prefix &quot;e&quot;
                        :sms-value-type &quot;int&quot;}}}))</pre></td></tr><tr><td class="spacer docs">&nbsp;</td><td class="codes" /></tr><tr><td class="docs"><div class="docs-header"><a class="anchor" href="#experiment.models.trial" name="experiment.models.trial"><h1 class="project-name">experiment.models.trial</h1><a class="toc-link" href="#toc">toc</a></a></div></td><td class="codes" /></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(ns experiment.models.trial
  (:use
   experiment.infra.models
   experiment.models.core
   experiment.models.user)
  (:require
   [clj-time.core :as time]
   [experiment.infra.session :as session]
   [experiment.libs.datetime :as dt]
   [experiment.models.schedule :as schedule]))</pre></td></tr><tr><td class="docs"><p>===========================================================
TRIAL
 refs User
 refs Experiment
 has outcome #[notstart, abandon, success, fail, uncertain]
 log [action ...] #[start, pause, unpause, end]
 schedule []</p>
</td><td class="codes"></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defmethod db-reference-params :trial [model]
  [:experiment])</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defmethod public-keys :trial [model]
  [:user :experiment
   :schedule :status :status_str
   :donep :pausedp :end_str :start :start_str :stats])</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defmethod import-keys :trial [model]
  [:user :experiment :schedule :status :start :stats])</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn human-status [trial]
  ({:active &quot;Active&quot;
    :paused &quot;Paused&quot;
    :abandoned &quot;Abandoned&quot;
    :completed &quot;Completed&quot;
    nil &quot;Unknown&quot;}
   (keyword (:status trial))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn trial-done? [trial]
  (when (#{&quot;abandoned&quot; &quot;completed&quot;} (:status trial)) true))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn trial-paused? [trial]
  (if (#{&quot;paused&quot;} (:status trial)) true false))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defmethod server-&gt;client-hook :trial [trial]
  (assoc trial
    :status_str (human-status trial)
    :stats {:elapsed 21
            :remaining 7
            :intervals 1}
    :start (dt/as-iso (:start trial))
    :start_str (dt/as-short-date (:start trial))
    :donep (trial-done? trial)
    :pausedp (trial-paused? trial)
    :end_str (when-let [end (:end trial)] (dt/as-short-string (dt/from-date end)))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defmethod client-&gt;server-hook :trial [trial]
  (assoc trial
    :start (dt/from-iso (:start trial) time/utc)))</pre></td></tr><tr><td class="docs"><p>Get trial from the user or session user if model is a string submodel id</p>
</td><td class="codes"><pre class="brush: clojure">(defn lookup-trial
  [id]
  (get-trial (session/current-user) (keyword id)))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn trial-user [trial]
  (resolve-dbref (:user trial)))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn trial-experiment [trial]
  (resolve-dbref (:experiment trial)))</pre></td></tr><tr><td class="docs"><p>Trial -> Instrument (outcome instrument for trial)</p>
</td><td class="codes"><pre class="brush: clojure">(defn trial-outcome
  [trial]
  (resolve-dbref (first (:outcome (trial-experiment trial)))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn trial-trackers [trial]
  (let [instruments (instruments (trial-experiment trial))
        in-instruments? (fn [elt] (some #(= elt %) instruments))]
    (filter (comp in-instruments? :instrument)
            (trackers (trial-user trial)))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn trial-schedule [trial]
  (let [exp (trial-experiment trial)]
    (merge (:schedule exp)
           (select-keys trial [:start]))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn trial-periods
  ([trial]
     (schedule/periods
      (trial-schedule trial)))
  ([trial interval]
     (schedule/periods-overlapping
      nil interval (trial-periods trial))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn baseline-period? [period] (= (:label period) &quot;base&quot;))
(defn treatment-period? [period] (not (baseline-period? period)))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn treatment-periods 
  ([periods]
     (filter treatment-period? periods))
  ([periods interval]
     (treatment-periods 
      (schedule/periods-overlapping
       nil interval periods))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn baseline-periods 
  ([periods]
     (filter baseline-period? periods))
  ([periods interval]
     (baseline-periods 
      (schedule/periods-overlapping
       nil interval periods))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn reminder-events [trial interval]
  (schedule/events (trial-schedule trial) interval))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn all-reminder-events [user interval]
  (mapcat #(reminder-events % interval) (trials user)))</pre></td></tr><tr><td class="spacer docs">&nbsp;</td><td class="codes" /></tr><tr><td class="docs"><div class="docs-header"><a class="anchor" href="#experiment.models.user" name="experiment.models.user"><h1 class="project-name">experiment.models.user</h1><a class="toc-link" href="#toc">toc</a></a></div></td><td class="codes" /></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(ns experiment.models.user
  (:use
   noir.core
   experiment.infra.models)
  (:require
   [experiment.infra.session :as session]
   [experiment.infra.middleware :as mid]
   [experiment.infra.auth :as auth]))</pre></td></tr><tr><td class="docs"><h2>USER</h2>

<p> :username (client, :public)
 :name "Full Name" (client, :owns|:friend)
 :email "Account email" (client, :owns)
 :password (server)
 :avatar <image> (client, :public)</p>

<p> Demographics (:demog, client, :owns)
   :age
   :gender
   :country
   :state
   :weight
   :height</p>

<p> Profile (:profile, client, :owns)
   :bio
   :units
   :default_privacy
   :cell</p>

<p> Permissions (:perm, server)
   ...</p>

<p> :trackers []
 :trials []
 :past_trials []</p>
</td><td class="codes"></td></tr><tr><td class="docs"><h2>Convenience methods</h2>
</td><td class="codes"></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defmethod valid-model? :user [user]
  (and (:username user)
       (:email user)
       (:type user)))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn create-user! [username password email name]
  (create-model!
   (auth/set-user-password
    {:type :user
     :username username
     :uname (.toLowerCase username)
     :name name
     :email email}
    password)))</pre></td></tr><tr><td class="docs"><p>Model for reference</p>
</td><td class="codes"><pre class="brush: clojure">(defn get-user
  [reference]
  (cond (string? reference)
	(or (fetch-model :user {:uname (.toLowerCase reference)})
        (fetch-model :user {:email reference}))
	true
	(resolve-dbref reference)))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(mid/set-user-fetcher
 (fn [&amp; {:keys [id username email]}]
   (cond id (fetch-model :user {:_id id})
         username (get-user username)
         email (get-user email))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn get-user-dbref [reference]
  (cond (and (map? reference) (= (name (:type reference)) &quot;user&quot;))
	(as-dbref reference)
	true
	(as-dbref (get-user reference))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defmethod public-keys :user [user]
  (if (= (:_id user) (:_id (session/current-user)))
    (keys (apply dissoc user
                 [:updates :permissions :password :salt :dataid :state]))
    [:username :bio :name]))</pre></td></tr><tr><td class="docs"><h2>Trials</h2>
</td><td class="codes"></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn attach-user [user submodel]
  (assoc submodel :user (as-dbref user)))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn trials [user]
  (map (partial attach-user user) (vals (:trials user))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn get-trial [user id]
  (attach-user user ((:trials user) (keyword id))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn has-trials? [user]
  (if (not (empty? (:trials user))) true false))</pre></td></tr><tr><td class="docs"><h2>Trackers</h2>
</td><td class="codes"></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn add-tracker! [user instrument schedule]
  (let [inst (if (model? instrument)
               instrument
               (fetch-model :instrument {:src instrument}))
        submod {:type &quot;tracker&quot;
                :state &quot;active&quot;
                :user (as-dbref user)
                :instrument (as-dbref inst)
                :schedule schedule}]
    (create-submodel! user &quot;trackers&quot; submod)))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn trackers [user]
  (vals (:trackers user)))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn has-trackers? [user]
  (if (not (empty? (trackers user))) true false))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn remove-tracker! [user tracker]
  (delete-submodel! user [:trackers (:id tracker)]))</pre></td></tr><tr><td class="docs"><h2>Services</h2>
</td><td class="codes"></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn set-service [user service record]
  (assert (model? user))
  (modify-model! user {:$set {:services {service record}}}))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn set-service-param [user service param value]
  (assert (model? user))
  (modify-model! user {:$set {:services {param value}}}))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn get-service-param [user service entry]
  (assert (model? user))
  (get-in user [:services service entry]))</pre></td></tr><tr><td class="docs"><h2>User Properties</h2>
</td><td class="codes"></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn get-pref
  ([user property]
     (get-in user [:preferences property]))
  ([property]
     (get-pref (session/current-user) property)))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn set-pref!
  ([user property value]
     (modify-model! user {:$set {:preferences {property value}}}))
  ([property value]
     (set-pref! (session/current-user) property value)))</pre></td></tr><tr><td class="docs"><h2>User Permissions</h2>
</td><td class="codes"></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn has-permission? [perm]
  ((set (:permissions (session/current-user))) perm))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn is-admin? []
  (has-permission? &quot;admin&quot;))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn site-admins []
  (list (get-user &quot;eslick&quot;)))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn site-admin-refs []
  (map as-dbref (site-admins)))</pre></td></tr><tr><td class="docs"><h2>Generate Test Users</h2>
</td><td class="codes"></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn gen-first [] (rand-nth [&quot;Joe&quot; &quot;Larry&quot; &quot;Curly&quot; &quot;Mo&quot;]))
(defn gen-last [] (rand-nth [&quot;Smith&quot; &quot;Carvey&quot; &quot;Kolluri&quot; &quot;Kramlich&quot;]))
(defn gen-gender [] (rand-nth [&quot;M&quot; &quot;F&quot;]))
(defn gen-weight [] (+ 100 (rand-int 150)))
(defn gen-yob [] (+ 1940 (rand-int 54)))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn gen-user []
  {:type :user
   :name (str (gen-first) &quot; &quot; (gen-last))
   :bio &quot;I have no bio, I am a computer generated character&quot;
   :gender (gen-gender)
   :country &quot;USA&quot;
   :state &quot;CA&quot;
   :weight (gen-weight)
   :yob (gen-yob)})</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn gen-users [count]
  (dotimes [i count]
    (create-model! (gen-user))))</pre></td></tr><tr><td class="spacer docs">&nbsp;</td><td class="codes" /></tr><tr><td class="docs"><div class="docs-header"><a class="anchor" href="#experiment.libs.datetime" name="experiment.libs.datetime"><h1 class="project-name">experiment.libs.datetime</h1><a class="toc-link" href="#toc">toc</a></a></div></td><td class="codes" /></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(ns experiment.libs.datetime
  (:require [clj-time.core :as time]
	    [clj-time.coerce :as coerce]
	    [clj-time.format :as fmt]
        [experiment.infra.middleware :as mid])
  (:import
   [org.joda.time.format DateTimeFormatterBuilder DateTimeFormatter]))</pre></td></tr><tr><td class="docs"><p>I Hate Dates and Times in ALL LANGUAGES</p>
</td><td class="codes"></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(def ^{:private true} short-today-fmt
  (.toFormatter
   (doto (DateTimeFormatterBuilder.)
     (.appendClockhourOfHalfday 1)
     (.appendLiteral &quot;:&quot;)
     (.appendMinuteOfHour 2)
     (.appendHalfdayOfDayText)
     (.appendLiteral &quot; Today &quot;)
     (.appendTimeZoneShortName))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(def ^{:private true} short-week-fmt
  (.toFormatter
   (doto (DateTimeFormatterBuilder.)
     (.appendClockhourOfHalfday 1)
     (.appendLiteral &quot;:&quot;)
     (.appendMinuteOfHour 2)
     (.appendHalfdayOfDayText)
     (.appendLiteral &quot; &quot;)
     (.appendDayOfWeekShortText)
     (.appendLiteral &quot; &quot;)
     (.appendTimeZoneShortName))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(def ^{:private true} short-year-fmt
  (.toFormatter
   (doto (DateTimeFormatterBuilder.)
     (.appendClockhourOfHalfday 1)
     (.appendLiteral &quot;:&quot;)
     (.appendMinuteOfHour 2)
     (.appendHalfdayOfDayText)
     (.appendLiteral &quot; &quot;)
     (.appendMonthOfYearShortText)
     (.appendLiteral &quot; &quot;)
     (.appendDayOfMonth 1)
     (.appendLiteral &quot; &quot;)
     (.appendTimeZoneShortName))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(def ^{:private true} blog-fmt
  (.toFormatter
   (doto (DateTimeFormatterBuilder.)
     (.appendMonthOfYearShortText)
     (.appendLiteral &quot; &quot;)
     (.appendDayOfMonth 1)
     (.appendLiteral &quot;, &quot;)
     (.appendYear 4 4)
     (.appendLiteral &quot; at &quot;)
     (.appendClockhourOfHalfday 1)
     (.appendLiteral &quot;:&quot;)
     (.appendMinuteOfHour 2)
     (.appendLiteral &quot; &quot;)
     (.appendHalfdayOfDayText))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(def ^{:private true} short-fmt
  (.toFormatter
   (doto (DateTimeFormatterBuilder.)
     (.appendClockhourOfHalfday 1)
     (.appendLiteral &quot;:&quot;)
     (.appendMinuteOfHour 2)
     (.appendLiteral &quot; &quot;)
     (.appendHalfdayOfDayText)
     (.appendLiteral &quot; &quot;)
     (.appendMonthOfYearShortText)
     (.appendLiteral &quot; &quot;)
     (.appendDayOfMonth 1)
     (.appendLiteral &quot;, &quot;)
     (.appendYear 4 4)
     (.appendLiteral &quot; &quot;)
     (.appendTimeZoneShortName))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(def ^{:private true} short-date
  (.toFormatter
   (doto (DateTimeFormatterBuilder.)
     (.appendDayOfWeekShortText)
     (.appendLiteral &quot; &quot;)
     (.appendMonthOfYearShortText)
     (.appendLiteral &quot; &quot;)
     (.appendDayOfMonth 1)
     (.appendLiteral &quot;, &quot;)
     (.appendYear 4 4)
     (.appendLiteral &quot; &quot;)
     (.appendTimeZoneShortName))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(def ^{:private true} iso-8601-date
  (.toFormatter
   (doto (DateTimeFormatterBuilder.)
     (.appendYear 4 4)
     (.appendLiteral &quot;-&quot;)
     (.appendMonthOfYear 2)
     (.appendLiteral &quot;-&quot;)
     (.appendDayOfMonth 2))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(def ^{:private true} iso-format
  (.toFormatter
   (doto (DateTimeFormatterBuilder.)
     (.appendYear 4 4)
     (.appendLiteral &quot;-&quot;)
     (.appendMonthOfYear 2)
     (.appendLiteral &quot;-&quot;)
     (.appendDayOfMonth 2)
     (.appendLiteral &quot;T&quot;)
     (.appendHourOfDay 2)
     (.appendLiteral &quot;:&quot;)
     (.appendMinuteOfHour 2)
     (.appendLiteral &quot;:&quot;)
     (.appendSecondOfMinute 2)
     (.appendLiteral &quot;.&quot;)
     (.appendMillisOfSecond 3)
     (.appendTimeZoneOffset &quot;Z&quot; true 2 2))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(def ^{:private true} iso-8601
  (org.joda.time.format.ISODateTimeFormat/basicDateTime))</pre></td></tr><tr><td class="docs"><p>(.toFormatter
 (doto (DateTimeFormatterBuilder.)
   (.appendYear 4 4)
   (.appendLiteral "-")
   (.appendMonthOfYear 2)
   (.appendLiteral "-")
   (.appendDayOfMonth 2)
   (.appendLiteral "T")
   (.appendHourOfDay 2)
   (.appendLiteral ":")
   (.appendMinuteOfHour 2)
   (.appendLiteral ":")
   (.appendSecondOfMinute 2)
   (.appendLiteral </p>
</td><td class="codes"></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(def ^{:private true} time-fmt (fmt/formatter &quot;h:mma&quot; (time/default-time-zone)))
(def ^{:private true} date-fmt (fmt/formatter &quot;MM/dd/yy&quot; (time/default-time-zone)))</pre></td></tr><tr><td class="docs"><p>Returns a date-time</p>
</td><td class="codes"><pre class="brush: clojure">(defn now
  []
  (time/to-time-zone (time/now) (mid/server-timezone)))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(def ^{:private true} short-fmt-intervals
  [[(time/days 1) short-today-fmt]
   [(time/weeks 1) short-week-fmt]
   [(time/years 1) short-year-fmt]
   [(time/years 1000) short-fmt]])</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defprotocol DateTime
  (date? [dt])
  (timezone [dt])
  (as-joda [dt])
  (as-java [dt]))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn- within-period-ago? [dt current period]
  (time/within? (time/interval (time/minus current period) current) dt))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn- short-formatter [dt]
  (let [cur (now)]
    (second
     (first
      (filter (fn [[period fmt]]
		(within-period-ago? dt cur period))
	      short-fmt-intervals)))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn a-month-ago []
  (time/minus (time/now) (time/months 1)))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defmacro with-server-timezone
  [&amp; body]
  `(binding [mid/*timezone* (mid/server-timezone)]
     ~@body))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defmacro with-user-timezone
  [[user] &amp; body]
  `(binding [experiment.infra.middleware/*current-user* ~user]
     (binding [mid/*timezone*
               (or (mid/user-timezone)
                   (mid/server-timezone))]
       ~@body)))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn from-utc
  ([utc] (from-utc utc (mid/session-timezone)))
  ([utc tz] (when utc (time/to-time-zone (from-utc utc) tz))))</pre></td></tr><tr><td class="docs"><p>Simplified ISO formatted date/times</p>
</td><td class="codes"><pre class="brush: clojure">(defn from-iso
  ([string]
     (from-iso string (mid/session-timezone)))
  ([string tz]
     (when (and string tz)
       (time/from-time-zone
        (.parseDateTime iso-format string)
        tz))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn from-iso-8601
  ([string]
     (from-iso-8601 string (mid/session-timezone)))
  ([string tz]
     (when (and string tz)
       (time/from-time-zone 
        (.parseDateTime iso-8601 string)
        tz))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn from-epoch
  ([epoch]
     (from-epoch epoch (mid/session-timezone)))
  ([epoch tz]
     (when (and (number? epoch) tz)
       (time/to-time-zone (time/plus (time/epoch) (time/secs epoch)) tz))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn from-date
  ([date]
     (from-date date (mid/session-timezone)))
  ([date tz]
     (coerce/from-date date)))</pre></td></tr><tr><td class="docs"><p>Export formats</p>
</td><td class="codes"></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn as-utc [dt]
  (cond
   (date? dt)
   (coerce/to-long (as-joda dt))
   (= (type dt) java.lang.Long)
   dt
   true nil))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn as-date [dt]
  (cond
   (date? dt)
   (as-java dt)
   (= (type dt) java.lang.Long)
   (java.util.Date. dt)))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn as-short-relative-string [dt]
  (.print (short-formatter dt) dt))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn as-short-string [dt]
  (when dt
    (.print (second (last short-fmt-intervals)) dt)))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn as-short-date [dt]
  (when dt
    (.print short-date dt)))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn as-iso-8601-date [dt]
  (when dt
    (.print iso-8601-date dt)))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn as-iso-8601 [dt]
  (when dt
    (.print iso-8601 dt)))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn as-iso [dt]
  (when dt
    (.print iso-format dt)))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn as-blog-date [dt]
  (when dt
    (.print blog-fmt dt)))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn in-server-tz [dt]
  (time/to-time-zone dt (time/default-time-zone)))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn in-default-tz [dt]
  (in-server-tz dt))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn in-session-tz [dt]
  (time/to-time-zone dt (mid/session-timezone)))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn to-session-tz [dt]
  (time/from-time-zone dt (mid/session-timezone)))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn wall-time [dt]
  (when dt (.toString (.toLocalTime dt) &quot;KK:mm aa&quot;)))</pre></td></tr><tr><td class="docs"><p>Canonical Time Interface</p>
</td><td class="codes"></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(extend-protocol DateTime 
  java.util.Date
  (:date? [dt] true)
  (:as-joda [dt] (org.joda.time.DateTime. dt))
  (:as-java [dt] dt)
  (:timezone [dt] (timezone (as-joda dt)))
  org.joda.time.DateTime
  (:date? [dt] true)
  (:as-joda [dt] dt)
  (:as-java [dt] (.toDate dt))
  (:timezone [dt] (.getZone (.getChronology dt)))
  Object
  (:date? [dt] false)
  (:as-joda [dt] (throw (java.lang.UnsupportedOperationException. &quot;Not a date object&quot;)))
  (:as-java [dt] (throw (java.lang.UnsupportedOperationException. &quot;Not a date object&quot;)))
  (:timezone [dt] (throw (java.lang.UnsupportedOperationException. &quot;Not a date object&quot;)))
  nil
  (:date? [dt] false)
  (:as-joda [dt] (throw (java.lang.UnsupportedOperationException. &quot;Not a date object&quot;)))
  (:as-java [dt] (throw (java.lang.UnsupportedOperationException. &quot;Not a date object&quot;)))
  (:timezone [dt] (throw (java.lang.UnsupportedOperationException. &quot;Not a date object&quot;))))</pre></td></tr><tr><td class="spacer docs">&nbsp;</td><td class="codes" /></tr><tr><td class="docs"><div class="docs-header"><a class="anchor" href="#experiment.libs.fitbit" name="experiment.libs.fitbit"><h1 class="project-name">experiment.libs.fitbit</h1><a class="toc-link" href="#toc">toc</a></a></div></td><td class="codes" /></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(ns experiment.libs.fitbit
  (:use noir.core
        hiccup.core
        experiment.infra.models)
  (:require [clojure.math.numeric-tower :as math]
            [cheshire.core :as json]
            [clj-http.client :as http]
            [clj-time.core :as time]
            [oauth.client :as oauth]
            [oauth.signature :as sig]
            [experiment.libs.datetime :as dt]
            [noir.response :as resp]
            [experiment.libs.properties :as props]
            [experiment.infra.session :as session]
            [experiment.infra.services :as services]
            [experiment.models.user :as user]))</pre></td></tr><tr><td class="docs"><p>Service configuration</p>
</td><td class="codes"><pre class="brush: clojure">(services/register-oauth
 :fitbit 
 [&quot;Fitbit&quot;
  :description &quot;Connect to your FitBit tracking data&quot;]
 :title &quot;Fitbit&quot;
 :url &quot;http://personalexperiments.org/api/svc/fitbit/authorize&quot;)</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(def fitbit :fit)</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(def consumer
  (oauth/make-consumer (props/get :fitbit.key)
                       (props/get :fitbit.secret)
                       &quot;http://api.fitbit.com/oauth/request_token&quot;
                       &quot;http://api.fitbit.com/oauth/access_token&quot;
                       &quot;http://api.fitbit.com/oauth/authorize&quot;
                       :hmac-sha1))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(assert (:key consumer))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn- save-req-tokens [request]
  (when (session/active?)
    (session/put! &quot;fitbit_oauth_token&quot; (:oauth_token request))
    (session/put! &quot;fitbit_oauth_secret&quot; (:oauth_token_secret request))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn- get-req-token []
  (session/get &quot;fitbit_oauth_token&quot;))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn- get-req-secret []
  (session/get &quot;fitbit_oauth_secret&quot;))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn- save-access-tokens [response]
  (user/set-service (session/current-user) fitbit
                    {:token (:oauth_token response)
                     :secret (:oauth_token_secret response)}))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn get-user-id [user]
  (user/get-service-param user fitbit :encoded_user_id))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn id-&gt;user [id]
  (fetch-model :user :where {&quot;services.fit.encoded_user_id&quot; id}))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn get-user-uid [user]
  (if-let [uid (user/get-service-param user fitbit :unique-id)]
    uid
    (let [uid (rand-int 1000000)]
      (user/set-service-param user fitbit :unique-id uid)
      uid)))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn uid-&gt;user [uid]
  (fetch-model :user :where {&quot;services.fit.unique-id&quot; uid}))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn- get-access-token [user]
  (user/get-service-param user fitbit :token))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn- get-access-secret [user]
  (user/get-service-param user fitbit :secret))</pre></td></tr><tr><td class="docs"><p>GET TOKENS AND SEND USER TO AUTHORIZE PAGE</p>
</td><td class="codes"></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn- build-authorize-uri [target]
  (str (:authorize-uri consumer)
       &quot;?&quot;
       (http/generate-query-string 
        (assoc (sig/oauth-params consumer (get-req-token))
          :oauth_signature (sig/sign consumer
                                     (:authorize-uri consumer)
                                     (get-req-secret))
          :oauth_callback target))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn- oauth-link [name target]
  (save-req-tokens
   (oauth/request-token consumer target))
  [:a {:class &quot;oauth&quot;
       :href (build-authorize-uri target)}
   name])</pre></td></tr><tr><td class="docs"><p>Manual Oauth Link</p>
</td><td class="codes"><pre class="brush: clojure">(defpage [:get &quot;/api/svc/fitbit/oauth&quot;] {:as request}
  (html
   (oauth-link &quot;Oauth Fitbit&quot;
               &quot;http://personalexperiments.org/api/svc/fitbit/authorize&quot;)))</pre></td></tr><tr><td class="docs"><p>AFTER AUTHORIZATION, USE REQUEST TOKENS TO GET ACCESS TOKENS</p>
</td><td class="codes"></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn- signing-uri [params]
  (sig/base-string &quot;POST&quot; (:access-uri consumer) params))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn- access-params [verifier]
  (let [params (sig/oauth-params consumer (get-req-token))
        params (assoc params
                 :oauth_verifier verifier)]
    (assoc params
      :oauth_signature (sig/sign consumer
                                 (signing-uri params)
                                 (get-req-secret)))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn- fetch-access-token [verifier]
  (let [params (access-params verifier)]
    (oauth/form-decode
     (:body
      (http/post (:access-uri consumer)
                 {:query-params params
                  :headers {&quot;Authorization&quot; (oauth/authorization-header (sort params))}})))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(declare subscribe)</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defpage [:get &quot;/api/svc/fitbit/authorize&quot;] {:keys [oauth_token oauth_verifier] :as request}
  (assert (= (get-req-token) oauth_token))
  (save-access-tokens (fetch-access-token oauth_verifier))
  (subscribe (experiment.models.user/get-user {:username (session/current-user)}))
  (resp/redirect &quot;/account/services&quot;))</pre></td></tr><tr><td class="docs"><p>Make Fitbit Requests</p>
</td><td class="codes"></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn request
  ([op user cmd]
     (assert (:key consumer))
     (let [uri (str &quot;http://api.fitbit.com/1/user/-/&quot; cmd)
           creds (oauth/credentials
                  consumer
                  (get-access-token user)
                  (get-access-secret user)
                  op
                  uri)]
       (json/parse-string
        (:body (http/request
                {:method op
                 :url uri
                 :headers {&quot;Authorization&quot; (oauth/authorization-header creds)}}))
        true)))
  ([user cmd]
     (request :get user cmd)))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn summary [user date]
  (request user (format &quot;activities/date/%s.json&quot; (dt/as-iso-8601-date date))))</pre></td></tr><tr><td class="docs"><p>Subscriptions</p>
</td><td class="codes"></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defonce notification-handler (atom nil))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn set-notification-handler [f]
  (swap! notification-handler (fn [old] f)))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn subscribed? [user]
  (get-in user [:fit-cred :subscribed]))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn subscribe [user]
  (request :post user (str &quot;apiSubscriptions/&quot; (get-user-uid user) &quot;.json&quot;))
  (modify-model! user {:$set {&quot;fit-cred.subscribed&quot; true}}))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn unsubscribe [user]
  (request :delete user (str &quot;apiSubscriptions/&quot; (get-user-uid user) &quot;.json&quot;))
  (modify-model! user {:$unset {&quot;fit-cred.subscribed&quot; true}}))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn list-subscriptions [user]
  (request :get user &quot;apiSubscriptions.json&quot;))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defpage fitbit-updates [:post &quot;/api/svc/fitbit/updates&quot;] {:as params}
  (clojure.tools.logging/spy noir.request/*request*)
  (clojure.tools.logging/spy params)
  (try
    (when-let [fn @notification-handler]
      (map fn (:updates params)))
    (catch java.lang.Throwable e
      (clojure.tools.logging/spy &quot;Error in fitbit-update&quot;)
      (clojure.tools.logging/spy e)))
  {:status 204 :body })</pre></td></tr><tr><td class="spacer docs">&nbsp;</td><td class="codes" /></tr><tr><td class="docs"><div class="docs-header"><a class="anchor" href="#experiment.libs.fulltext" name="experiment.libs.fulltext"><h1 class="project-name">experiment.libs.fulltext</h1><a class="toc-link" href="#toc">toc</a></a></div></td><td class="codes" /></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(ns experiment.libs.fulltext
  (:use experiment.infra.models)
  (:require [clucy.core :as clucy]
            [clojure.tools.logging :as log]))</pre></td></tr><tr><td class="docs"><h1>Setup</h1>
</td><td class="codes"></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(def index-filename &quot;db/fulltext&quot;)
(defonce db nil)</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn start [&amp; [filename]]
  (if db
    (clojure.tools.logging/warn &quot;Fulltext index already open, ignoring start&quot;)
    (do
      (when filename
        (alter-var-root #'index-filename (fn [old] filename)))
      (alter-var-root #'db (fn [old] (clucy/disk-index index-filename))))))</pre></td></tr><tr><td class="docs"><h1>Indexing Models</h1>
</td><td class="codes"></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn- index-model [model]
  (try
    (when-let [keys (index-keys model)]
      (select-keys model (conj keys :_id :type)))
    (catch java.lang.IllegalArgumentException e
      (clojure.tools.logging/warnf &quot;Model type %s does not have index-keys defined&quot; (:type model))
      nil)))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn index [model &amp; {:as extras}]
  (assert (and db (map? model) (:type model)))
  (let [mod (merge (index-model model) extras)]
    (if (not (empty? mod))
      (do
        (clucy/search-and-delete db (str &quot;_id:&quot; (:_id mod)))
        (clucy/add
         db
         (with-meta mod
           (assoc {}
             ;; (into {} (map (fn [[field val]]lt
             ;;         {field {:stored false}})
             ;;       mod))
             :_id {:tokenized false}
             :type {:tokenized false}))))
      (log/infof &quot;Cannot index model type: %s&quot; (:type model)))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn delete [model]
  (clucy/search-and-delete db (str &quot;_id:&quot; (:_id model))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn index-all [&amp; [collections]]
  (let [colls (or collections [&quot;instrument&quot; &quot;treatment&quot; &quot;experiment&quot;])]
    (doseq [coll colls]
      (doall (map index (fetch-models coll))))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn reindex-all [collections]
  (doseq [coll collections]
    (clucy/search-and-delete db (str &quot;type:&quot; (name coll))))
  (index-all collections))</pre></td></tr><tr><td class="docs"><h1>Query for Models</h1>
</td><td class="codes"></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn- as-query-string [qmap]
  (let [dq (:default qmap)]
    (apply str (cons
                (if (and dq (&gt; (count dq) 0))
                  (str &quot;+( &quot; dq &quot; ) &quot;))
                (map (fn [[field string]]
                       (str &quot;+&quot; (name field) &quot;:( &quot; string  &quot; ) &quot;))
                     (dissoc qmap :default))))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn resolve-group [[type refs]]
  (fetch-models (model-collection type)
                {:_id {:$in (vec (map (comp as-oid :_id) refs))}}))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn resolve-refs [refs]
  (-&gt;&gt; refs
       (group-by :type)
       (mapcat resolve-group)))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn search [query-map &amp; {:keys [max-results size skip]}]
  (let [query (as-query-string query-map)
;;        _ (println query)
        results (clucy/search db query
                              (or max-results (and (not skip) size) 200))
        {:keys [_total-hits]} (meta results)]
    {:hits _total-hits
;;     :results results
     :models (resolve-refs
              (if (and size skip)
                (take size (drop skip results))
                results))}))</pre></td></tr><tr><td class="spacer docs">&nbsp;</td><td class="codes" /></tr><tr><td class="docs"><div class="docs-header"><a class="anchor" href="#experiment.libs.highcharts" name="experiment.libs.highcharts"><h1 class="project-name">experiment.libs.highcharts</h1><a class="toc-link" href="#toc">toc</a></a></div></td><td class="codes" /></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(ns experiment.libs.highcharts
  (:use noir.core
        hiccup.core
	handlebars.templates)
  (:require [cheshire.core :as json]))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn default-config [id title type series]
  {:chart {:type type
           :renderTo id}
   :plotOptions {:series {:animation false
			  :marker {:enabled false}}}
   :title {:text title}
   :credits {:enabled false}
   :labels {:items [{:html &quot;&lt;div&gt;&lt;p&gt;&lt;b&gt;Start&lt;/b&gt;&lt;/p&gt;&lt;/div&gt;&quot; :style {:left &quot;100px&quot; :top &quot;100px&quot;}}]}
   :series series})</pre></td></tr><tr><td class="spacer docs">&nbsp;</td><td class="codes" /></tr><tr><td class="docs"><div class="docs-header"><a class="anchor" href="#experiment.libs.mail" name="experiment.libs.mail"><h1 class="project-name">experiment.libs.mail</h1><a class="toc-link" href="#toc">toc</a></a></div></td><td class="codes" /></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(ns experiment.libs.mail
  (:require [postal.core :as post]
            [experiment.libs.properties :as props]))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(def mailer (agent [0 0]))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(def admin-address* (or (props/get :admin-address true)
                        &quot;admin@personalexperiments.org&quot;))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn send-message [[count errors] message]
  (try
    (do (post/send-message
         #^{:host (props/get :mail.host)
            :user (props/get :mail.user)
            :pass (props/get :mail.pass) 
            :ssl (&gt; (count (props/get :mail.ssl)) 0)}
         message)
        [(inc count) errors])
    (catch java.lang.Throwable e
      [count (inc errors)])))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn send-message-to [email message]
  (assert (every? #(get message %) [:subject :body]))
  (send mailer send-message (merge {:to email
                                    :from admin-address*}
                                   message)))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn send-message-to-group [group message]
  (assert (and (every? #(get message %) [:subject :body])
               (sequential? group)))
  (send mailer send-message (merge {:to admin-address*
                                    :bcc group
                                    :from admin-address*}
                                   message)))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn send-site-message [message]
  (assert (every? #(get message %) [:subject :body]))
  (send mailer send-message (merge {:to &quot;ianeslick@gmail.com&quot;
                                    :from &quot;admin@personalexperiments.org&quot;}
                                   message)))</pre></td></tr><tr><td class="spacer docs">&nbsp;</td><td class="codes" /></tr><tr><td class="docs"><div class="docs-header"><a class="anchor" href="#experiment.libs.properties" name="experiment.libs.properties"><h1 class="project-name">experiment.libs.properties</h1><a class="toc-link" href="#toc">toc</a></a></div></td><td class="codes" /></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(ns experiment.libs.properties
  (:refer-clojure :exclude [get])
  (:require clojure.java.io))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn read-properties [filename]
  (with-open [^java.io.Reader reader (clojure.java.io/reader filename)]
    (let [props (java.util.Properties.)]
      (.load props reader)
      (into {} (for [[k v] props] [(keyword k) (read-string v)])))))</pre></td></tr><tr><td class="docs"><p>Site properties</p>
</td><td class="codes"></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defonce site-properties {})</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn load-site-properties [&amp; [filename]]
  (alter-var-root #'site-properties #(read-properties %2)
                  (or filename &quot;site.properties&quot;)))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn- as-keyword [key]
  (cond (string? key) (keyword key)
        (keyword? key) key
        true (throw (java.lang.Error. &quot;Keyword type not recognized&quot;))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn get [property &amp; [safe?]]
  (when (empty? site-properties)
    (load-site-properties))
  (if-let [result (clojure.core/get site-properties (as-keyword property))]
    result
    (when-not safe?
      (throw (java.lang.Error. (format &quot;No property '%s' found&quot; property))))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn put [property value]
  (alter-var-root #'site-properties assoc property value))</pre></td></tr><tr><td class="spacer docs">&nbsp;</td><td class="codes" /></tr><tr><td class="docs"><div class="docs-header"><a class="anchor" href="#experiment.libs.rescuetime" name="experiment.libs.rescuetime"><h1 class="project-name">experiment.libs.rescuetime</h1><a class="toc-link" href="#toc">toc</a></a></div></td><td class="codes" /></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(ns experiment.libs.rescuetime
  (:require
   [clj-http.client :as http]
   [clojure.tools.logging :as log]
   [experiment.infra.services :as services]
   [experiment.libs.datetime :as dt]
   [experiment.libs.properties :as props]
   [cheshire.core :as json]))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(def ^{:dynamic true} *api-key* nil)
(def api-base &quot;https://www.rescuetime.com/anapi/data&quot;)</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn api-request [params]
  (let [response
        (http/get api-base
                  {:query-params
                   (merge
                    params
                    {:key *api-key*
                     :format &quot;json&quot;})
                   :content-type :json
                   :accept :json})]
    (log/spy response)
    (json/parse-string
     (:body response))
   true))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(services/register :rt [&quot;RescueTime&quot;]
   :user {:title &quot;Account Email&quot;}
   :apikey {:title &quot;API Key&quot;})</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defmacro with-key [value &amp; body]
  `(binding [*api-key* (or ~value (props/get :rescuetime.api-key))]
     ~@body))</pre></td></tr><tr><td class="docs"><p>Return the index, appropriate for assoc and nth, of a vector
   where the function provided returns true</p>
</td><td class="codes"><pre class="brush: clojure">(defn index-at
  ([pred sequence]
     (loop [i 0
	    s sequence]
       (cond (empty? s) nil
	     (pred (first s)) i
	     true (recur (inc i) (rest s))))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn column-index [results column]
  (index-at #(= % column) (results :row_headers)))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn- seconds-to-hours [column row]
  (assoc row column (float (/ (nth row column) 3600))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn results-as-hours [results]
  (let [pos (column-index results &quot;Time Spent (seconds)&quot;)
	results (update-in results [:row_headers] #(assoc % pos &quot;Time Spent (hours)&quot;))]
    (update-in results [:rows]
	       #(map (partial seconds-to-hours pos) %))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn- matching-row-p [column pattern row]
  (re-find pattern (nth row column)))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn filter-rows-by-name
  ([name type results]
     (let [pos (column-index results type)
           pattern (re-pattern name)]
       (update-in results [:rows]
                  #(filter (partial matching-row-p pos pattern) %)))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defonce ^{:dynamic true} *test* nil)</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn aggregate-rows
  [group]
  [(first group)
   (apply + (map second (second group)))])</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn aggregate-results
  ([results]
     (alter-var-root #'*test* (fn [a] (:rows results)))
     (assoc results
       :row_headers (take 2 (:row_headers results))
       :rows (map aggregate-rows
                  (group-by first (:rows results))))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn efficiency
  ([interval start end]
     (assert (#{&quot;week&quot; &quot;day&quot; &quot;month&quot;} interval))
     (api-request
      {:restrict_kind &quot;efficiency&quot;
       :restrict_begin (dt/as-iso-8601-date start)
       :restrict_end (dt/as-iso-8601-date end)
       :perspective &quot;interval&quot;
       :resolution_time interval})))</pre></td></tr><tr><td class="docs"><p>(defn- parse-productivity [result]
 (assoc result :rows
        (map (fn [[ts score </p>
</td><td class="codes"></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn productivity
  ([interval start end]
     (assert (#{&quot;week&quot; &quot;day&quot; &quot;month&quot;} interval))
;;     (parse-productivity
      (api-request
       {:restrict_kind &quot;productivity&quot;
        :restrict_begin (dt/as-iso-8601-date start)
        :restrict_end (dt/as-iso-8601-date end)
        :perspective &quot;interval&quot;
        :resolution_time interval})))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn categories
  ([interval start end]
     (assert (#{&quot;week&quot; &quot;day&quot; &quot;month&quot;} interval))
     (api-request
      {:restrict_kind &quot;category&quot;
       :restrict_begin (dt/as-iso-8601-date start)
       :restrict_end (dt/as-iso-8601-date end)
       :perspective &quot;interval&quot;
       :resolution_time interval}))
  ([interval start end name]
     (filter-rows-by-name name &quot;Category&quot; (categories interval start end))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn activities
  ([interval start end]
     (assert (#{&quot;week&quot; &quot;day&quot; &quot;month&quot;} interval))
     (api-request
      {:restrict_kind &quot;activity&quot;
       :restrict_begin (dt/as-iso-8601-date start)
       :restrict_end (dt/as-iso-8601-date end)
       :perspective &quot;interval&quot;
       :resolution_time interval}))
  ([interval start end name]
     (assert (#{&quot;week&quot; &quot;day&quot; &quot;month&quot;} interval))
     (api-request
      {:restrict_kind &quot;activity&quot;
       :restrict_begin (dt/as-iso-8601-date start)
       :restrict_end (dt/as-iso-8601-date end)
       :perspective &quot;interval&quot;
       :restrict_thing name
       :resolution_time interval})))</pre></td></tr><tr><td class="docs"><p>Specific interfaces</p>
</td><td class="codes"></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn facebook
  ([interval start end]
     (aggregate-results
      (activities interval start end &quot;facebook.com&quot;))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn social-media
  ([interval start end]
     (categories interval start end &quot;General Social Networking&quot;)))</pre></td></tr><tr><td class="spacer docs">&nbsp;</td><td class="codes" /></tr><tr><td class="docs"><div class="docs-header"><a class="anchor" href="#experiment.libs.sms" name="experiment.libs.sms"><h1 class="project-name">experiment.libs.sms</h1><a class="toc-link" href="#toc">toc</a></a></div></td><td class="codes" /></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(ns experiment.libs.sms
  (:use
   noir.core
   experiment.infra.models)
  (:require
   [clojure.contrib.string :as string]
   [clojure.tools.logging :as log]
   [clj-http.client :as http]
   [cheshire.core :as json]
   [clj-time.core :as time]
   [experiment.libs.datetime :as dt]
   [somnium.congomongo :as mongo]
   [noir.response :as response]
   [noir.request :as request]))</pre></td></tr><tr><td class="docs"><h2>A simple SMS gateway based on grouptexting API</h2>
</td><td class="codes"></td></tr><tr><td class="docs"><h2>Manage GroupTexting Credentials</h2>
</td><td class="codes"></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defonce ^{:dynamic true}
  *credentials* nil)</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn set-credentials [credentials]
  (assert (and (:user credentials) (:pw credentials)))
  (alter-var-root #'*credentials* (fn [a b] b) credentials))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn- inject-perms [map]
  (let [{user :user pw :pw} *credentials*]
    (assert (and user pw))
    (merge map {:user user :pass pw})))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defmacro with-credentials [[creds] &amp; body]
  `(binding [*credentials* (or ~creds *credentials*)]
     ~@body))</pre></td></tr><tr><td class="docs"><h2>Make a request to the grouptexting API</h2>
</td><td class="codes"></td></tr><tr><td class="docs"><p>Compose a map of args as key-value pairs on the base URL</p>
</td><td class="codes"><pre class="brush: clojure">(defn- compose-request-url
  [base argmap]
  (log/spy
   (apply str base
	  &quot;?&quot;
	  (http/generate-query-string
	   (inject-perms argmap)))))</pre></td></tr><tr><td class="docs"><h2>Log all the messages we get</h2>

<p>Log all the messages we get to Mongo for forensic purposes</p>
</td><td class="codes"></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn log-message! [message]
  (assert (and (:from message) (:message message)))
  (mongo/insert! :sms (assoc message
                        :date (dt/as-date (dt/now))
                        :type :sms)))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn get-messages
  ([from]
     (mongo/fetch :sms :where {:from from}))
  ([start end]
     (mongo/fetch :sms :where {:date {:$gte (dt/as-date start) :$lte (dt/as-date end)}}
                  :sort {:date 1})))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn get-latest-message [from]
  (first
   (mongo/fetch :sms :where {:from from}
                :sort {:date -1}
                :limit 1)))</pre></td></tr><tr><td class="docs"><h2>SMS API</h2>
</td><td class="codes"></td></tr><tr><td class="docs"><h2>Send an SMS</h2>
</td><td class="codes"></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn- clean-phone-number [number]
  (string/replace-re #&quot;-&quot;  number))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn send-sms [number message &amp; [credentials]]
  (assert (&lt; (count message) 160))
  (assert (not (re-find #&quot;[']&quot; message)))
  (with-credentials [credentials]
    (http/get (compose-request-url
	       &quot;https://app.grouptexting.com/api/sending&quot;
	       {:phonenumber (clean-phone-number number)
            :message message}))))</pre></td></tr><tr><td class="docs"><h2>Account mgmt</h2>
</td><td class="codes"></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn account-balance [&amp; [credentials]]
  (with-credentials [credentials]
    (json/parse-string
     (:body
      (http/get (compose-request-url
                 &quot;https://app.grouptexting.com/api/credits/check/&quot;
                 {})))
     true)))</pre></td></tr><tr><td class="docs"><h2>SMS Inbox Handler</h2>
</td><td class="codes"></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn default-handler [from message]
  (log/spy [from message]))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defonce ^{:dynamic true} *handler* 'default-handler)</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn set-reply-handler [handler]
  (alter-var-root #'*handler* (fn [a b] b) handler))</pre></td></tr><tr><td class="docs"><p>Internal handler for any received SMS messages.
   Logs the message then calls the user handler if defined.
   from and message are strings</p>
</td><td class="codes"><pre class="brush: clojure">(defn- handle-reply
  [from message]
  (let [ts (dt/now)]
    (log-message! {:from message :message message :ts (dt/as-utc ts)})
    (when (or (fn? *handler*) (var? *handler*))
      (*handler* ts from message))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defpage inbox-url [:get &quot;/sms/receive&quot;]
  {:keys [from message]}
  (handle-reply from message)
  (response/empty))</pre></td></tr><tr><td class="docs"><h2>API: Parse SMS Content</h2>

<p>Parse and associate replies with events, submit data.
The idea is that we look at active events for a user,
and see if any of them are compatible with the data
we're seeing in the SMS message.</p>
</td><td class="codes"></td></tr><tr><td class="docs"><p>A multi-method that parses an SMS response according to
   the :sms-parser type specified in the event.  Override
   to do something other than the prefix default.  Timestamp
   returned is the receipt timestamp; events may need to
   adjust the reference timestamp to submit this as a valid
   sample object.</p>
</td><td class="codes"><pre class="brush: clojure">(defmulti parse-sms
  (fn [message ts event]
    (when-let [name (:sms-parser event)]
      (keyword name))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(def patterns (atom nil))</pre></td></tr><tr><td class="docs"><p>Return an RE pattern that recognized prefix + data type.
   Memoizes patterns; silly performance optimization...</p>
</td><td class="codes"><pre class="brush: clojure">(defn default-sms-parser-re
  [event]
  (let [{:keys [sms-prefix sms-value-type]} event
        lookup [sms-prefix sms-value-type]]
    (or (find @patterns lookup)
        (swap! patterns assoc lookup
               (re-pattern
                (str (or (str &quot;(?i:&quot; (:sms-prefix event) &quot;)&quot;) &quot;&quot;)
                     (case (:sms-value-type event)
                       &quot;string&quot; &quot;\\s*([^\\s]+)&quot;
                       &quot;float&quot; &quot;\\s*([\\d\\.]+)&quot;
                       &quot;\\s*(\\d*)&quot;)))))))</pre></td></tr><tr><td class="docs"><p>This is the default SMS parser, it supports simple
   SMS formats like 'mood good' or 'stool 4' or just 's 10'</p>

<ul>
<li>:sms-parser :default | nil</li>
<li>:sms-prefix '&lt;SMS prefix>'</li>
<li>:sms-value-type '<type of value after prefix>' | nil <int by default></li>
</ul>
</td><td class="codes"><pre class="brush: clojure">(defn default-sms-parser
  [message event]
  (when-let [value (second (re-matches (second (default-sms-parser-re event)) message))]
    (case (:sms-value-type event)
      &quot;string&quot; value
      &quot;float&quot; (Float/parseFloat value)
      (Integer/parseInt value))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defmethod parse-sms :default [message ts event]
  (when-let [val (and (:sms-prefix event)
                      (default-sms-parser message event))]
    {:ts ts :v val :raw message :event event}))</pre></td></tr><tr><td class="spacer docs">&nbsp;</td><td class="codes" /></tr><tr><td class="docs"><div class="docs-header"><a class="anchor" href="#experiment.libs.sparkline" name="experiment.libs.sparkline"><h1 class="project-name">experiment.libs.sparkline</h1><a class="toc-link" href="#toc">toc</a></a></div></td><td class="codes" /></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(ns experiment.libs.sparkline
  (:require [cheshire.core :as json]))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(def ^:private ids (atom 1))
(defn- sparkline-uid []
  (str &quot;spark-&quot; (swap! ids (partial + 1))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn render-sparkline [data &amp; [params]]
  (let [uid (sparkline-uid)]
    [:span [:span {:id uid}]
     [:script
      (format &quot;$.sparkline(%s, %s, %s)&quot;
	      (str &quot;#&quot; uid)
	      (json/generate-string (vec data))
	      (json/generate-string (or params {})))]]))</pre></td></tr><tr><td class="spacer docs">&nbsp;</td><td class="codes" /></tr><tr><td class="docs"><div class="docs-header"><a class="anchor" href="#experiment.libs.strava" name="experiment.libs.strava"><h1 class="project-name">experiment.libs.strava</h1><a class="toc-link" href="#toc">toc</a></a></div></td><td class="codes" /></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(ns experiment.libs.strava
  (:use experiment.infra.models)
  (:require
   [experiment.infra.services :as services]
   [clj-http.client :as http]
   [clj-time.core :as time]
   [clojure.string :as str]
   clj-time.format
   [cheshire.core :as json]
   [somnium.congomongo :as mongo]))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(services/register
 :strava
 [&quot;Strava&quot;
  :description &quot;Strava users have the ability to create an instrument to track their performance on a specific segment over time.  Just enter the segment name here and we'll pull the segment data from all the rides you do.&quot;]
 :email {:title &quot;Account Email&quot;}
 :password {:title &quot;Password&quot; :type &quot;Password&quot;}
 :segment1 {:title &quot;Segment Name (1)&quot;}
 :segment2 {:title &quot;Segment Name (2)&quot;})</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(def ^{:dynamic true} *strava-base* &quot;http://www.strava.com/api/v1/%s&quot;)
(def strava-base &quot;https://www.strava.com/api/v2/%s&quot;)</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn strava-url [command]
  (format strava-base command))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn strava-request [command params]
  (let [cmd (if (vector? command)
              (str/join &quot;/&quot; (map name command))
              command)]
    (json/parse-string
     (:body ((if (= (:method params) :post) http/post http/get)
             (strava-url command)
             {:query-params params}))
     true)))</pre></td></tr><tr><td class="docs"><p>Authenticate</p>
</td><td class="codes"></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn authenticate-strava [params]
  (let [result (strava-request [:authentication :login] params)]
    (if (= (:success result) &quot;success&quot;)
      (select-keys result [:token :athelete_id])
      nil)))</pre></td></tr><tr><td class="docs"><p>Segments</p>
</td><td class="codes"></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn search-segments [segment]
  (:segments (strava-request &quot;segments&quot; :name segment)));;(clj-http.util/url-encode segment)))</pre></td></tr><tr><td class="docs"><p>(clj-http.util/url-encode segment)))</p>
</td><td class="codes"></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defmacro cached-mongo-fetch-one [coll where selector cmd &amp; args]
  `(let [cached# (mongo/fetch-one ~coll :where ~where)]
     (if (empty? cached#)
       (let [segment# (~selector (apply strava-request ~cmd ~args))]
	 (mongo/insert! :segments segment#)
	 segment#)
       cached#)))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn segment [ref]
  (cond (number? ref)
	(cached-mongo-fetch-one :segments {:id ref} :segment (format &quot;segments/%d&quot; ref))
	(string? ref)
	(mongo/fetch-one :segments :where {:short ref})))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn find-segments [segment]
  nil)</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn segment-efforts [segment user]
  (:efforts
   (strava-request
    (format &quot;segments/%d/efforts&quot;
	   (if (number? segment) segment
	       (:id (first (find-segments segment)))))
    :athleteName user)))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn effort [id]
  (cached-mongo-fetch-one :efforts {:id id} :effort (format &quot;efforts/%d&quot; id)))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn parse-strava-date [date-string]
  (.getMillis
   (clj-time.format/parse
    (:date-time-no-ms clj-time.format/formatters)
    date-string)))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn as-date-time [millis]
  (org.joda.time.DateTime. millis))</pre></td></tr><tr><td class="spacer docs">&nbsp;</td><td class="codes" /></tr><tr><td class="docs"><div class="docs-header"><a class="anchor" href="#experiment.libs.twitter" name="experiment.libs.twitter"><h1 class="project-name">experiment.libs.twitter</h1><a class="toc-link" href="#toc">toc</a></a></div></td><td class="codes" /></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(ns experiment.libs.twitter
  (:use noir.core
        hiccup.core
        experiment.infra.models)
  (:require [oauth.client :as oauth]
            [noir.response :as resp]
            [experiment.infra.session :as session]
            [experiment.infra.services :as services]
            [experiment.libs.properties :as props]
            [oauth.signature :as sig]
            [clj-http.client :as http]))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(services/register-oauth
 :tw
 [&quot;Twitter&quot;
  :description &quot;Twitter connections will allow you to power instruments from your twitter stream by using microformats.  You will also be able to engage in social sharing of your experimental activities via Twitter (all this TBD)&quot;]
 :title &quot;Twitter&quot;
 :url &quot;http://personalexperiments.org/api/svc/twitter/authorize&quot;)</pre></td></tr><tr><td class="docs"><p>Configuration</p>
</td><td class="codes"></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(def consumer
  (oauth/make-consumer (props/get :twitter.key)
                       (props/get :twitter.secret)
                       &quot;https://api.twitter.com/oauth/request_token&quot;
                       &quot;https://api.twitter.com/oauth/access_token&quot;
                       &quot;https://api.twitter.com/oauth/authorize&quot;
                       :hmac-sha1))</pre></td></tr><tr><td class="docs"><p>3-Legged Bookkeeping &amp; debug support</p>
</td><td class="codes"></td></tr><tr><td class="docs"><p>Book keeping across phases</p>
</td><td class="codes"></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn save-req-tokens [request]
  (when (session/active?)
    (session/put! &quot;withings_oauth_token&quot; (:oauth_token request))
    (session/put! &quot;withings_oauth_secret&quot; (:oauth_token_secret request))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn get-req-token []
  (when (session/active?)
    (session/get &quot;withings_oauth_token&quot;)))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn get-req-secret []
  (when (session/active?)
    (session/get &quot;withings_oauth_secret&quot;)))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn save-access-tokens [response]
  (if (session/active?)
    (update-model!
     (assoc (session/current-user)
       :tw-cred response))
    (update-model!
     (assoc (fetch-model :user :where {:username &quot;eslick&quot;})
       :tw-cred response))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn get-access-token [user]
  (get-in user [:tw-cred :oauth_token]))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn get-access-secret [user]
  (get-in user [:tw-cred :oauth_token_secret]))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn get-user-id [user]
  (get-in user [:tw-cred :user_id]))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn get-user-screen-name [user]
  (get-in user [:tw-cred :screen_name]))</pre></td></tr><tr><td class="docs"><p>GET TOKENS AND SEND USER TO AUTHORIZE PAGE</p>
</td><td class="codes"></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn build-authorize-uri [target]
  (str (:authorize-uri consumer)
       &quot;?&quot;
       (http/generate-query-string 
        (assoc (sig/oauth-params consumer (get-req-token))
          :oauth_signature (sig/sign consumer
                                     (:authorize-uri consumer)
                                     (get-req-secret))
          :oauth_callback target))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn oauth-link [name target]
  (save-req-tokens
   (oauth/request-token consumer target))
  [:a {:class &quot;oauth&quot;
       :href (build-authorize-uri target)}
   name])</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defpage [:get &quot;/api/svc/twitter/oauth&quot;] {:as request}
  (html
   (oauth-link &quot;Oauth Twitter&quot;
               &quot;http://personalexperiments.org/api/svc/twitter/authorize&quot;)))</pre></td></tr><tr><td class="docs"><p>AFTER AUTHORIZATION, USE REQUEST TOKENS TO GET ACCESS TOKENS</p>
</td><td class="codes"></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn signing-uri [params]
  (sig/base-string &quot;POST&quot; (:access-uri consumer) params))</pre></td></tr><tr><td class="docs"><pre><code>  "?oauth_verifier=" verifier))
</code></pre>
</td><td class="codes"></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn access-params [verifier]
  (let [params (assoc (sig/oauth-params consumer (get-req-token))
                 :oauth_verifier verifier)]
    (assoc params
      :oauth_signature (sig/sign consumer
                                 (signing-uri params)
                                 (get-req-secret)))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn fetch-access-token [verifier]
  (let [params (access-params verifier)]
    (oauth/form-decode
     (:body
      (http/post (:access-uri consumer)
                 {:query-params params
                  :headers {&quot;Authorization&quot; (oauth/authorization-header (sort params))}})))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defpage [:get &quot;/api/svc/twitter/authorize&quot;] {:keys [oauth_token oauth_verifier] :as request}
  (clojure.tools.logging/spy [&quot;OAUTH approval uri&quot; request])
  (assert (= (get-req-token) oauth_token))
  (save-access-tokens (fetch-access-token oauth_verifier))
  (resp/redirect &quot;/account/services&quot;))</pre></td></tr><tr><td class="spacer docs">&nbsp;</td><td class="codes" /></tr><tr><td class="docs"><div class="docs-header"><a class="anchor" href="#experiment.libs.withings" name="experiment.libs.withings"><h1 class="project-name">experiment.libs.withings</h1><a class="toc-link" href="#toc">toc</a></a></div></td><td class="codes" /></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(ns experiment.libs.withings
  (:use noir.core
        hiccup.core
        experiment.infra.models)
  (:require [oauth.client :as oauth]
            [experiment.infra.services :as services]
            [clojure.math.numeric-tower :as math]
            [experiment.libs.datetime :as dt]
            [clj-time.core :as time]
            [noir.response :as resp]
            [experiment.infra.session :as session]
            [experiment.libs.properties :as props]
            [oauth.signature :as sig]
            [cheshire.core :as json]
            [clj-http.client :as http]))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(def consumer
  (oauth/make-consumer (props/get :withings.key)
                       (props/get :withings.secret)
                       &quot;https://oauth.withings.com/account/request_token&quot;
                       &quot;https://oauth.withings.com/account/access_token&quot;
                       &quot;https://oauth.withings.com/account/authorize&quot;
                       :hmac-sha1))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(services/register-oauth :rt [&quot;Withings&quot;]
    :title &quot;Fitbit Oauth&quot;
    :img nil
    :url &quot;http://personalexperiments.org/api/withings/authorize&quot;)</pre></td></tr><tr><td class="docs"><p>Book keeping across phases</p>
</td><td class="codes"></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn save-req-tokens [request]
  (when (session/active?)
    (session/put! &quot;withings_oauth_token&quot; (:oauth_token request))
    (session/put! &quot;withings_oauth_secret&quot; (:oauth_token_secret request))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn get-req-token []
  (session/get &quot;withings_oauth_token&quot;))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn get-req-secret []
  (session/get &quot;withings_oauth_secret&quot;))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn save-access-tokens [userid response]
  (services/set-model!
   (session/current-user)
   :wi
   {:userid userid
    :token (:oauth_token response)
    :secret (:oauth_secret response)}))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn get-userid [user]
  (services/get user :wi :userid))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn get-access-token [user]
  (services/get user :wi :token))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn get-access-secret [user]
  (services/get user :wi :secret))</pre></td></tr><tr><td class="docs"><p>GET TOKENS AND SEND USER TO AUTHORIZE PAGE</p>
</td><td class="codes"></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn build-authorize-uri [target]
  (str (:authorize-uri consumer)
       &quot;?&quot;
       (http/generate-query-string 
        (assoc (sig/oauth-params consumer (get-req-token))
          :oauth_signature (sig/sign consumer
                                     (:authorize-uri consumer)
                                     (get-req-secret))
          :oauth_callback target))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn oauth-link [name target]
  (save-req-tokens
   (oauth/request-token consumer target))
  [:a {:class &quot;oauth&quot;
       :href (build-authorize-uri target)}
   name])</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defpage [:get &quot;/api/withings/oauth&quot;] {:as request}
  (html
   (oauth-link &quot;Oauth Withings&quot;
               &quot;http://personalexperiments.org/api/withings/authorize&quot;)))</pre></td></tr><tr><td class="docs"><p>AFTER AUTHORIZATION, USE REQUEST TOKENS TO GET ACCESS TOKENS</p>
</td><td class="codes"></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn signing-uri [params]
  (sig/base-string &quot;POST&quot; (:access-uri consumer) params))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn access-params [verifier]
  (let [params (sig/oauth-params consumer (get-req-token))
        params (assoc params
                 :oauth_verifier verifier)]
    (assoc params
      :oauth_signature (sig/sign consumer
                                 (signing-uri params)
                                 (get-req-secret)))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn fetch-access-token [verifier]
  (let [params (access-params verifier)]
    (oauth/form-decode
     (:body
      (http/post (:access-uri consumer)
                 {:query-params params
                  :headers {&quot;Authorization&quot; (oauth/authorization-header (sort params))}})))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defpage [:get &quot;/api/withings/authorize&quot;] {:keys [oauth_token oauth_verifier] :as request}
  (assert (= (get-req-token) oauth_token))
  (save-access-tokens (fetch-access-token oauth_verifier))
  (resp/redirect &quot;/app/profile&quot;))</pre></td></tr><tr><td class="docs"><p>===================================================================</p>
</td><td class="codes"></td></tr><tr><td class="docs"><p>STANDARD QUERY OF PROTECTED RESOURCES</p>
</td><td class="codes"></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn action
  ([user service action params]
     (assert (map? params))
     (let [uri (format &quot;http://wbsapi.withings.net/%s&quot; service)
           params (merge {:action action
                          :userid (get-userid user)}
                         params)
           access-creds (oauth/credentials
                         consumer
                         (get-access-token user)
                         (get-access-secret user)
                         :GET
                         uri
                         params)]
       (json/parse-string
        (:body
         (http/get uri
                   {:query-params (merge access-creds params)}))
        true)))
  ([user service action]
     (action user service action {})))</pre></td></tr><tr><td class="docs"><p>=======================</p>

<h1>API</h1>
</td><td class="codes"></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(def type-table
  {1 :weight
   4 :height
   5 :lbm
   6 :fat-ratio
   8 :fat-mass
   9 :dbp
   10 :sbp
   11 :hr})</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn translate-type [rec]
  (get type-table (:type rec)))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(def convert-table
  {:weight (fn [value] (* value 2.2))})</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn convert-value [type measure]
  (let [fn (convert-table type)
        raw (* (:value measure) (math/expt 10 (:unit measure)))]
    (if fn (fn raw) (float raw))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn filter-record [rec]
  (when (= (:category rec) 1)
    (map (fn [measure]
           (let [type (translate-type measure)]
             {:date (:date rec)
              :type type
              :value (convert-value type measure)}))
         (:measures rec))))</pre></td></tr><tr><td class="docs"><p>Return a vector of the last updated time and an array of measures</p>
</td><td class="codes"><pre class="brush: clojure">(defn filter-records
  [response]
  (let [body (:body response)]
    [(:updatetime body)
     (mapcat filter-record (:measuregrps body))]))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn user-measures
  ([user startdate]
     (filter-records
      (action user &quot;measure&quot; &quot;getmeas&quot;
              {:startdate (dt/as-utc startdate) :devtype 1})))
  ([user]
     (filter-records
      (action user &quot;measure&quot; &quot;getmeas&quot;
              {:devtype 1}))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn user-info [user]
  (action user &quot;user&quot; &quot;getbyuserid&quot; {}))</pre></td></tr><tr><td class="spacer docs">&nbsp;</td><td class="codes" /></tr><tr><td class="docs"><div class="docs-header"><a class="anchor" href="#experiment.libs.zeo" name="experiment.libs.zeo"><h1 class="project-name">experiment.libs.zeo</h1><a class="toc-link" href="#toc">toc</a></a></div></td><td class="codes" /></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(ns experiment.libs.zeo
  (:use experiment.infra.models)
  (:require [clj-http.client :as http]
            [experiment.infra.services :as services]
            [experiment.libs.datetime :as dt]))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(services/register
 :zeo
 [&quot;Zeo&quot;
  :description &quot;Download data from the Zeo service&quot;]
 :email {:title &quot;Account Email&quot;}
 :password {:title &quot;Password&quot; :type &quot;Password&quot;})</pre></td></tr><tr><td class="docs"><p>"ACE41D854610E84DAF16419E087C2ADF" ;; mit.edu
"6B58F54966A8A9632A68EBBFF0192D4C" ;; media.mit.edu</p>
</td><td class="codes"></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(def ^{:dynamic true} *std-key* &quot;ACE41D854610E84DAF16419E087C2ADF&quot;)
(def ^{:dynamic true} *std-base* &quot;https://api.myzeo.com:8443/zeows/api/v1/json/sleeperService/%s&quot;)</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(def ^{:dynamic true} *staging-key* &quot;6B58F54966A8A9632A68EBBFF0192D4C&quot;)
(def ^{:dynamic true} *staging-base* &quot;https://staging.myzeo.com:8443/zeows/api/v1/json/sleeperService/%s&quot;)</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(def zeo-mode :standard)
(defonce ^{:dynamic true} *auth* nil)</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn- zeo-key []
  (if (= zeo-mode :staging)
    *staging-key*
    *std-key*))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn- zeo-base []
  (if (= zeo-mode :staging)
    *staging-base*
    *std-base*))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn- zeo-url [action]
  (format (zeo-base) action))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn- valid-auth? [auth]
  (and (sequential? auth)
       (= (count auth) 2)
       (every? string? auth)))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn set-default-auth [auth]
  (assert (valid-auth? auth))
  (alter-var-root #'*auth* (fn [orig] auth)))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn get-default-auth []
  *auth*)</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn- with-auth [auth &amp; body]
  `(let [*auth* auth]
     ~@body))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn zeo-request
  ([auth action params]
     (assert (valid-auth? auth))
     (assert (map? params))
     (http/get (zeo-url action)
               {:as :json
                :query-params (assoc params :key (zeo-key))
                :basic-auth auth
                :content-type :json
                :accept :json}))
  ([action params]
     (zeo-request *auth* action params))
  ([action]
     (zeo-request *auth* action {})))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn zeo-date [date]
  (cond org.joda.time.DateTime
        (dt/as-iso-8601-date date)
        (string? date)
        (do (assert (re-matches #&quot;(\d\d\d\d)-(\d\d)-(\d\d)&quot; date))
            date)))</pre></td></tr><tr><td class="docs"><p>These methods require default or dynamic <em>auth</em> setting</p>
</td><td class="codes"></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn average-zq []
  (zeo-request &quot;getOverallAverageZQScore&quot;))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn average-morning-feel []
  (zeo-request &quot;getOverallAverageMorningFeelScore&quot;))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn dates-with-sleep-data []
  (zeo-request &quot;getDatesWithSleepData&quot;))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn sleep-stats [date]
  (zeo-request &quot;getSleepStatsForDate&quot; {:date date}))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn prev-sleep-stats [date]
  (zeo-request &quot;getPreviousSleepStats&quot; {:date date}))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn next-sleep-stats [date]
  (zeo-request &quot;getNextSleepStats&quot; {:date date}))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn sleep-record [date]
  (zeo-request &quot;getSleepRecordForDate&quot; {:date date}))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn prev-sleep-record [date]
  (zeo-request &quot;getPreviousSleepRecord&quot; {:date date}))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn next-sleep-record [date]
  (zeo-request &quot;getPreviousSleepRecord&quot; {:date date}))</pre></td></tr><tr><td class="spacer docs">&nbsp;</td><td class="codes" /></tr><tr><td class="docs"><div class="docs-header"><a class="anchor" href="#experiment.views.admin" name="experiment.views.admin"><h1 class="project-name">experiment.views.admin</h1><a class="toc-link" href="#toc">toc</a></a></div></td><td class="codes" /></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(ns experiment.views.admin
  (:use noir.core
        hiccup.core
        hiccup.page-helpers
        hiccup.form-helpers)
  (:require
   [noir.validation :as vali]
   [noir.response :as resp]
   [clojure.string :as string]
   [experiment.models.user :as users]
   [experiment.infra.session :as sess]
   [experiment.views.common :as common]))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(pre-route
 &quot;/admin*&quot; {}
 (if (sess/current-user)
   (when-not (users/is-admin?)
     (resp/redirect &quot;/&quot;))
   (resp/redirect &quot;/actions/login&quot;)))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defpage &quot;/admin/hideme&quot; {}
  (html5
   (common/layout-header &quot;Personal Experiments: Admin&quot;)
   (:body {:onLoad &quot;javascript:pageTracker._setVar('dev_view');&quot;}
          [:h1 &quot;You are now hidden from Google Analytics&quot;])))</pre></td></tr><tr><td class="spacer docs">&nbsp;</td><td class="codes" /></tr><tr><td class="docs"><div class="docs-header"><a class="anchor" href="#experiment.views.article-page" name="experiment.views.article-page"><h1 class="project-name">experiment.views.article-page</h1><a class="toc-link" href="#toc">toc</a></a></div></td><td class="codes" /></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(ns experiment.views.article-page
  (:require
   [experiment.views.common :as common]
   [experiment.infra.session :as session]
   [clojure.tools.logging :as log]
   [clojure.string :as str]
   [somnium.congomongo :as mongo]
   [noir.response :as resp]
   [noir.util.crypt :as crypt])
  (:use noir.core
	experiment.infra.models
        experiment.models.article
        experiment.models.user
        hiccup.core
        hiccup.page-helpers
	hiccup.form-helpers))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defpartial edit-link [name]
  (when (is-admin?)
    [:a.admin-link {:href (format &quot;/article/edit/%s&quot; name)}
     &quot;Edit Article&quot;]))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defpage &quot;/article/:name&quot; {:keys [name] :as options}
  (println name)
  (let [article (get-article name)]
    (common/layout
     [(:title article)
      (common/default-nav name)]
     [:div.container
      (if article
        [:div.article.span8
         (edit-link name)
         [:div.page-header
          [:h1 (:title article)]]
         (:html article)
         (link-to (or (:target options) &quot;/&quot;) &quot;Return to Home Page...&quot;)]
        [:div.article.span8
         [:h1 &quot;No Article named '&quot; name &quot;' found&quot;]])])))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defpage &quot;/article/edit/:name&quot; {:keys [name] :as options}
  (let [article (or (get-article name) {:name &quot;&quot; :title &quot;&quot; :body &quot;&quot;})]
    (common/layout
     [(str &quot;Editing: &quot; (:title article))
      (common/default-nav (if (= name &quot;about&quot;) &quot;About&quot; &quot;&quot;))
      :deps [&quot;views/home&quot;]]
     [:div.container
      (form-to [:post &quot;/article/edit&quot;]
               [:fieldset
                [:div.control-group
                 (label {:class &quot;control-label&quot;} &quot;name&quot; &quot;Database Label&quot;)
                 [:div.controls
                  (text-field {:class &quot;input-xlarge&quot;} &quot;name&quot; (:name article))]]
                [:div.control-group
                 (label {:class &quot;control-label&quot;} &quot;title&quot; &quot;Article Title&quot;)
                 [:div.controls
                  (text-field {:class &quot;input-xlarge&quot;} &quot;title&quot; (:title article))]]
                [:div.control-group
                 (label {:class &quot;control-label&quot;} &quot;body&quot; &quot;Article Content&quot;)
                 [:div.controls
                  [:p.help-block
                   &quot;This box uses the &quot; [:a {:href &quot;http://daringfireball.net/projects/markdown/syntax&quot;} &quot;Markdown&quot;]
                   &quot; markup language.&quot;]
                  (text-area {:class &quot;input-xlarge&quot; :style &quot;width:40em&quot; :rows &quot;30&quot;}
                             &quot;body&quot; (:body article))
                  ]]
                [:div.form-actions
                 [:button.btn.btn-primary {:type &quot;submit&quot; :name &quot;submit&quot;} &quot;Save&quot;]
                 [:button.btn {:type &quot;submit&quot; :name &quot;cancel&quot;} &quot;Cancel&quot;]]])
      [:script &quot;$(document).ready(function () { $('#body').focus(); });&quot;]])))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defpage [:post &quot;/article/edit&quot;] {:as article}
  (when (and (not (:cancel article))
             (:name article) (:title article) (:body article))
    (create-article! (:name article) (:title article) (:body article)))
  (resp/redirect (format &quot;/article/%s&quot; (:name article))))</pre></td></tr><tr><td class="spacer docs">&nbsp;</td><td class="codes" /></tr><tr><td class="docs"><div class="docs-header"><a class="anchor" href="#experiment.views.authviews" name="experiment.views.authviews"><h1 class="project-name">experiment.views.authviews</h1><a class="toc-link" href="#toc">toc</a></a></div></td><td class="codes" /></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(ns experiment.views.authviews
  (:use
   noir.core
   hiccup.core
   hiccup.page-helpers
   experiment.views.common
   experiment.views.bootstrap
   [hiccup.form-helpers :exclude [form-to input]]
   handlebars.templates
   experiment.infra.api)
  (:require
   [experiment.infra.session :as session]
   [experiment.infra.auth :as auth]
   [experiment.infra.models :as models]
   [experiment.models.user :as user]
   [experiment.libs.mail :as mail]
   [noir.response :as resp]))</pre></td></tr><tr><td class="docs"><h2>Authentication</h2>

<p>Backend support for login, registration, forgotten passwords, etc.</p>
</td><td class="codes"></td></tr><tr><td class="docs"><h2>LOGIN Support</h2>

<p>The default login page re-uses the dialog logic</p>
</td><td class="codes"></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn login-with-redirect [target]
  (resp/redirect (str &quot;/action/login?target=&quot; target)))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defpage login [:get &quot;/action/login&quot;]
  {:keys [target] :as args}
  (layout
   [&quot;Login to Access Protected Area&quot;
    (default-nav)
    :deps [&quot;views/home&quot;]]
   [:div {:style &quot;height:400px&quot;}
    [:script &quot;define(['jquery', 'views/home'], function ($, Home) {
                $(document).ready(function () {
                   $('.login-button').click();
                });
              });&quot;]]))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defapi do-login [:post &quot;/action/login&quot;]
  {:as auth}
  (if-let [user (auth/login auth)]
    {:result &quot;success&quot;}
    {:result &quot;fail&quot;
     :message &quot;Username/E-mail not found or password was incorrect&quot;}))</pre></td></tr><tr><td class="docs"><p>/action/logout</p>
</td><td class="codes"><pre class="brush: clojure">(defpage do-logout  {:as options}
  (session/clear!)
  (resp/redirect (or (:target options) &quot;/&quot;)))</pre></td></tr><tr><td class="docs"><h2>Protect access to areas of the site</h2>
</td><td class="codes"></td></tr><tr><td class="docs"><p>NOTE: be sure to adjust this to open up dashboard soon</p>
</td><td class="codes"><pre class="brush: clojure">(defn handle-private-route []
  (let [uri (:uri (noir.request/ring-request))]
    (when-not (session/logged-in?)
      (login-with-redirect uri))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(pre-route &quot;/&quot; {}
           (when (session/logged-in?)
             (if (user/is-admin?)
               (resp/redirect &quot;/dashboard&quot;)
               (resp/redirect &quot;/study1&quot;))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(pre-route &quot;/dashboard*&quot; {}
           (handle-private-route))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(pre-route &quot;/explore*&quot; {}
           (handle-private-route))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(pre-route &quot;/account*&quot; {}
           (handle-private-route))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(pre-route &quot;/api/root/*&quot; {}
           (handle-private-route))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(pre-route &quot;/api/embed/*&quot; {}
           (handle-private-route))</pre></td></tr><tr><td class="docs"><p>Other protected routes
- /settings</p>
</td><td class="codes"></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(pre-route &quot;/admin*&quot; {}
	   (when-not (session/logged-in?)
	     (let [uri (:uri (noir.request/ring-request))]
	       (println &quot;Redirecting to login, not authorized for: &quot; uri)
	       (login-with-redirect uri))))</pre></td></tr><tr><td class="docs"><h2>REGISTRATION Support</h2>
</td><td class="codes"></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn valid-registration-rec? [{:keys [email username password password2]}]
  (cond (or (= (count email) 0) (not (re-find #&quot;@&quot; email)))
        [false &quot;We require a valid email address&quot;]
        (models/fetch-model :user {:email email})
        [false &quot;Email address is already registered&quot;]
        (models/fetch-model :user {:username username})
        [false (format &quot;Username '%s' is already registered&quot; username)]
        (not (&gt; (count username) 3))
        [false &quot;We require a valid username longer than 3 characters&quot;]
        (= (count password) 4)
        [false &quot;You must use a password longer than 4 characters&quot;]
        (not (= password password2))
        [false &quot;Passwords didn't match&quot;]
        true
        [true nil]))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(def reg-notice-body &quot;User '%s' (%s) just registered on personalexperiments.org&quot;)
(def reg-message-body &quot;Your username is: %s
  Please return to the site at http://www.personalexperiments.org/study1, click Login in the upper right corner of the screen, enter your username and password, and proceed with the study instructions.&quot;)</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn register-new-user [{:keys [username password email name] :as user}]
  (user/create-user! username password email name)
  (mail/send-site-message
   {:subject &quot;New registration&quot;
    :body (format reg-notice-body username name)})
  (mail/send-message-to email
   {:subject &quot;Thank you for registering at PersonalExperiments.org&quot;
    :body (format reg-message-body username)}))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defapi do-register [:post &quot;/action/register&quot;] {:as user}
  (let [[result message] (valid-registration-rec? user)]
    (if result
      (do
        (register-new-user user)
        {:result &quot;success&quot;})
      {:result &quot;fail&quot;
       :message message})))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defapi check-username [:get &quot;/action/check-username&quot;]
  {:keys [username] :as data}
  {:exists (if (models/fetch-model :user {:uname (.toLowerCase username)})
             &quot;true&quot;
             &quot;false&quot;)})</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defapi check-email [:get &quot;/action/check-email&quot;]
  {:keys [email] :as data}
  {:exists (if (models/fetch-model :user {:email email})
             &quot;true&quot; &quot;false&quot;)})</pre></td></tr><tr><td class="docs"><h2>FORGOTTEN Password</h2>
</td><td class="codes"></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(def passwords
  [&quot;bart simpson&quot;
   &quot;fred freelander&quot;
   &quot;whola hoola&quot;
   &quot;i.p.freely&quot;
   &quot;syndicate zero&quot;
   &quot;foo bar baz&quot;])</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn reset-user-password
  [user]
  (let [newpw (nth passwords (rand-int (- (count passwords) 1)))]
    (models/update-model!
     (auth/set-user-password user newpw))
    (println &quot;reset &quot; (:username user) &quot; to &quot; newpw)
    newpw))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(def reset-email
  &quot;The password for user '%s' was reset to: %s.  Please go to http://personalexperiments.org/settings to reset your password.&quot;)</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defapi do-forgot-password [:post &quot;/action/forgotpw&quot;] {:as options}
  (if-let [user (user/get-user (:userid options))]
    (try
      (let [newpw (reset-user-password user)]
        (mail/send-message-to (:email user)
                              {:subject &quot;PersonalExperiments.org: Password Reset&quot;
                               :body (format reset-email (:username user) newpw)})
        {:result &quot;success&quot;})
      (catch java.lang.Throwable e
        {:result &quot;fail&quot;
         :message (format &quot;Internal error: %s please write to eslick@media.mit.edu&quot; e)}))
    {:result &quot;fail&quot;
     :message &quot;Did not recognize your username or e-mail address&quot;}))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defapi do-change-password [:post &quot;/action/changepw&quot;] {:keys [oldPass newPass1] :as options}
  (clojure.tools.logging/spy options)
  (if-let [user (session/current-user)]
    (if (auth/valid-password? user oldPass)
      (let [newuser (auth/set-user-password user newPass1)]
        (do (models/modify-model! newuser
                                  {:$set {:password (:password newuser)}})
            {:result &quot;success&quot;}))
      {:result &quot;fail&quot;
       :message &quot;Old password is not valid&quot;})
    {:result &quot;fail&quot;
     :message &quot;You must be logged into to change your password&quot;}))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defapi touch-timezone [:get &quot;/action/timezone&quot;] {:keys [_timezone] :as options}
  (resp/empty))</pre></td></tr><tr><td class="spacer docs">&nbsp;</td><td class="codes" /></tr><tr><td class="docs"><div class="docs-header"><a class="anchor" href="#experiment.views.bootstrap" name="experiment.views.bootstrap"><h1 class="project-name">experiment.views.bootstrap</h1><a class="toc-link" href="#toc">toc</a></a></div></td><td class="codes" /></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(ns experiment.views.bootstrap
  (:use
   noir.core
   hiccup.core
   handlebars.templates)
  (:require
   [hiccup.form-helpers :as hf]
   [clojure.string :as str]))</pre></td></tr><tr><td class="docs"><h2>Twitter Bootstrap Widgets and Partials</h2>
</td><td class="codes"></td></tr><tr><td class="docs"><h2>Generates both client and server templates</h2>
</td><td class="codes"></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(deftemplate modal-dialog-template 
  [:div
;;   {:id (% id)
;;    :class &quot;modal hide fade&quot;
;;    :style &quot;display:none;&quot;}
   [:div.modal-header 
    [:a.close {:data-dismiss &quot;modal&quot;} &quot;x&quot;]
    (%code header)]
   [:div.modal-body
    (%code body)]
   [:div.modal-footer
    (%code footer)]])</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(deftemplate modal-form-dialog-template
  [:div
   [:div.modal-header 
    [:a.close {:data-dismiss &quot;modal&quot;} &quot;x&quot;]
    (%code header)]
   [:div.modal-body
    (%code body)]
   [:div.modal-footer
    (%code footer)]])</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn modal-dialog [id &amp; {:keys [header body footer] :as parts}]
  (modal-dialog-template (assoc parts :id id)))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn popover-link [text href pop-title pop-content]
  [:a {:class &quot;popover-link&quot;
       :href href
       :rel &quot;popover&quot;
       :data-original-title pop-title
       :data-content pop-content}
   text])</pre></td></tr><tr><td class="docs"><h2>FORMS</h2>
</td><td class="codes"></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn form-to [&amp; args]
  (apply hf/form-to args))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defelem ctrl-group [[name id] &amp; controls]
  [:div.control-group
   [:label.control-label {:for id} name]
   `[:div.controls
     ~@controls]])</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defelem input [type id value]
  [:input {:type type :id id :value value}])</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defelem textarea [id value]
  [:textarea {:id id :name id}
   value])</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defelem help-text [text]
  [:p.help-block text])</pre></td></tr><tr><td class="docs"><h2>Menus</h2>
</td><td class="codes"></td></tr><tr><td class="docs"><h2>Pagination</h2>
</td><td class="codes"></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn pagination [names active-offset]
  [:div.pagination
   [:ul
    (map-indexed (fn [name idx]
                   (if (= idx active-offset)
                     [:li {:class &quot;active&quot;}
                      [:a {:href &quot;#&quot;} name]]
                     [:li 
                      [:a {:href &quot;#&quot;} name]]))
                 names)]])</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn pager [left-name right-name &amp; [sides?]]
  [:ul.pager
   [:li {:class (if sides? &quot;previous&quot; )}
    [:a {:href &quot;#&quot;} left-name]]
   [:li {:class (if sides? &quot;next&quot; )}
    [:a {:href &quot;#&quot;} right-name]]])</pre></td></tr><tr><td class="docs"><h2>Render Nav Menus</h2>
</td><td class="codes"><pre class="brush: clojure">(defn- active-class [match current &amp; {:keys [base] :or {base }}]
  (if (and match (= match current)) (str &quot;active &quot; base) base))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn- merge-props [orig over]
  (if-let [new-class (:class over)]
    (merge orig (assoc over :class (str/join \space [(:class orig) new-class])))
    (merge orig over)))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(declare dropdown-submenu)</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn- menu-item [active {:keys [tag name href aprops lprops submenu] :as entry}]
  (if-not submenu
    [:li (merge-props {:class (active-class active tag)} lprops)
     (when name
       [:a (merge-props {:href href} aprops)
        name])]
    [:li (merge-props {:class (active-class active tag :base &quot;dropdown&quot;)}
                      lprops)
     [:a (merge-props {:class &quot;dropdown-toggle&quot;
                       :href href
                       :data-toggle &quot;dropdown&quot;}
                      aprops)
      name
      [:b.caret]]
     (dropdown-submenu nil submenu)]))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defelem dropdown-submenu [active submenu]
  [:ul.dropdown-menu
   (map (partial menu-item active)
        (filter #(not (nil? %)) submenu))])</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defelem nav-menu [menu active]
  [:ul.nav
   (map (partial menu-item active)
        (filter #(not (nil? %)) menu))])</pre></td></tr><tr><td class="docs"><h2>WIDGETS</h2>
</td><td class="codes"></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn carousel [id items &amp; [active-index]]
  [:div.carousel {:id id}
   [:div.carousel-inner
    (doall
     (map (fn [i item]
            [:div {:class (if (if active-index
                                (= i active-index)
                                (= i 1))
                            &quot;item active&quot; &quot;item&quot;)}
             item])
          (range 1 (+ (count items) 1))
          items))]
   [:a.carousel-control.left {:href (str &quot;#&quot; id) :data-slide &quot;prev&quot;} &quot;&amp;lsaquo;&quot;]
   [:a.carousel-control.right {:href (str &quot;#&quot; id) :data-slide &quot;next&quot;} &quot;&amp;rsaquo;&quot;]])</pre></td></tr><tr><td class="spacer docs">&nbsp;</td><td class="codes" /></tr><tr><td class="docs"><div class="docs-header"><a class="anchor" href="#experiment.views.calendar" name="experiment.views.calendar"><h1 class="project-name">experiment.views.calendar</h1><a class="toc-link" href="#toc">toc</a></a></div></td><td class="codes" /></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(ns experiment.views.calendar
  (:require
   [clojure.tools.logging :as log]
   [experiment.models.user :as user]
   [experiment.infra.session :as session]
   [experiment.libs.datetime :as dt]
   [experiment.models.schedule :as sched]
   [experiment.models.events :as events]
   [experiment.models.eventlog :as eventlog]
   [clj-time.core :as time])
  (:use experiment.infra.models
	noir.core
	hiccup.core
	hiccup.page-helpers
	hiccup.form-helpers
	handlebars.templates))</pre></td></tr><tr><td class="docs"><p>==================================</p>

<h1>Calendar View</h1>
</td><td class="codes"></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(def ^{:dynamic true} *events* nil)
(def ^{:dynamic true} *month-dt* nil)</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn today? [day]
  (when *month-dt*
    (let [month (.toDateTime *month-dt* (org.joda.time.LocalTime. 0 0))]
      (and (time/after? (dt/now) month)
           (time/before? (dt/now) (time/plus month (time/months 1)))
           (= day (.getDayOfMonth (dt/now)))))))</pre></td></tr><tr><td class="docs"><p>Event Computation</p>
</td><td class="codes"></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn events-for-day [day]
  (*events* day))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn treatment? [event]
  (nil? (:instrument event)))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn convert-event [event]
  (assoc (server-&gt;client event)
    :instrument (:instrument event)))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn render-event [event]
  (if (:instrument event)
    (let [instrument (resolve-dbref (:instrument event))]
      [:div.event-view
       [:a.view-timeline {:href &quot;#&quot;}
        [:i.icon-eye-open]] &quot;&amp;nbsp;Track&amp;nbsp;&quot;
       (:variable instrument) &quot; -- &quot; (:service instrument) &quot; at &quot; (:local-time event)])
    [:div.event-view
     [:i.icon-comment] &quot;&amp;nbsp;Treament Reminder&amp;nbsp; at &quot; (:local-time event)]))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn- events-daily-map [events-map]
  (apply hash-map
         (mapcat (fn [[dt events]]
                   [(.getDayOfMonth dt)
                    (map convert-event events)])
                 events-map)))</pre></td></tr><tr><td class="docs"><p>Compute Day Entry</p>
</td><td class="codes"></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn day-class [day events]
  (if (nil? day)
    &quot;padding&quot;
    (clojure.string/join
     &quot; &quot;
     [(when day &quot;day&quot;)
      (when (today? day) &quot;today&quot;)
      (when events &quot;date_has_event&quot;)
      (when (and events (some treatment? events)) &quot;treat&quot;)])))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn day-popover-content [day events]
  (when events
    (html
     [:div {:class &quot;events&quot;}
      (doall (map render-event events))])))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn day-title [day]
  (when day
    (str &quot;Events for &quot;
         (dt/as-short-date
          (.withDayOfMonth *month-dt* day)))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn day-date [day]
  (when day
    (dt/as-iso-8601-date (time/plus *month-dt* (time/days (- day 1))))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defpartial render-day [day]
  (let [events (events-for-day day)
        class (day-class day events)
        content (day-popover-content day events)
        table *events*]
    [:td {:class class
          :data-content content
          :data-original-title (day-title day)
          :data-date (day-date day)}
     (or day )]))</pre></td></tr><tr><td class="docs"><p>Compute Week</p>
</td><td class="codes"></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defpartial render-first-week [padding range]
  [:tr
   (map render-day (repeat padding nil))
   (map render-day range)])</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defpartial render-week [[padding range]]
  [:tr
   (map render-day range)
   (map render-day (repeat padding nil))])</pre></td></tr><tr><td class="docs"><p>Compute Month Layout</p>
</td><td class="codes"></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn- make-month [dt]
  (.toLocalDate dt))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn- month-padding [month-interval]
  (let [offset (.getDayOfWeek (make-month (.getStart month-interval)))]
    (if (&gt; offset 6)
      (- offset 7)
      offset)))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn- month-end-day [month-interval]
  (+ 1 (.getDayOfMonth (make-month (.getEnd month-interval)))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn- compute-weeks [interval]
  (let [start-pad (month-padding interval)
        last-day (month-end-day interval)]
    (letfn [(week [start]
              (let [next (+ start 7)]
                (cond (&lt;= last-day start)
                      nil
                      (&lt; last-day next)
                      (cons [(- next last-day) (range start last-day)] (week next))
                      true
                      (cons [0 (range start (+ start 7))] (week next)))))]
      [start-pad (week (- 8 start-pad))])))</pre></td></tr><tr><td class="docs"><p>Render Calendar</p>
</td><td class="codes"></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defpartial render-calendar-header []
  [:thead
   [:tr (map (fn [day] [:th day])
             [&quot;Sun&quot; &quot;Mon&quot; &quot;Tue&quot; &quot;Wed&quot; &quot;Thu&quot; &quot;Fri&quot; &quot;Sat&quot;])]])</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defpartial render-calendar-table [interval events-map]
  (let [[start-pad weeks] (compute-weeks interval)]
    (binding [*month-dt* (make-month (.getStart interval))
              *events* (doall (events-daily-map events-map))]
      [:div {:class &quot;calendar&quot;}
       [:table {:cellspacing 0}
        (render-calendar-header)
        [:tbody
         (doall
          (cons (render-first-week start-pad (range 1 (- 8 start-pad)))
                (map render-week weeks)))]]])))</pre></td></tr><tr><td class="docs"><p>Calendar Client REST API</p>
</td><td class="codes"></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(deftemplate small-calendar
  [:div.small-calendar
   [:div.cal-header
    (%if title [:h3 {:style &quot;text-align: center;&quot;} (% title)])
    [:ul.pager
     [:li.previous [:a {:href &quot;#&quot;} &quot;&amp;larr; Previous&quot;]]
     [:li.now [:a {:href &quot;#&quot;} (% date)]]
     [:li.next [:a {:href &quot;#&quot;} &quot;Next &amp;rarr;&quot;]]]]
   [:div.cal-body]])</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defpage trial-calendar [:get &quot;/api/calendar/trial/:id&quot;]
  {:keys [id year month start]}
  (let [trial (user/get-trial (session/current-user) id)
        start (or start (str (dt/as-utc (dt/now))))]
    (try 
      (render-calendar-table
       (when (and month (not (= month &quot;now&quot;)))
         [(Integer/parseInt year)
          (Integer/parseInt month)
          (Long/parseLong start)])
       []))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn interval-for-month [year month]
  (let [dt (if (and year month)
             (org.joda.time.DateTime. year month 1 0 0)
             (-&gt; (dt/now)
                 (.withDayOfMonth 1)
                 (.withHourOfDay 0)
                 (.withMinuteOfHour 0)
                 (.withSecondOfMinute 0)))
        dt (cond (not year ) dt
                 (&gt; year 2000) (.withYearOfCentury dt (- year 2000))
                 (&gt; year 1900) (.minusYears (.withYearOfCentury dt (- year 2000)) 100))
        dt (if month (.withMonthOfYear dt month) dt)]
    (time/interval dt (.minusSeconds (.plusMonths dt 1) 1))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defpage user-calendar [:get &quot;/api/calendar/user&quot;]
  {:keys [year month]}
  (let [user (session/current-user)
        interval (interval-for-month (Integer/parseInt year) (Integer/parseInt month))
        events-map (eventlog/group-by-start-day
                    (eventlog/event-timeline
                     user (.getStart interval) (.getEnd interval)))]
    (try
      (render-calendar-table interval events-map))))</pre></td></tr><tr><td class="docs"><pre><code>         (mapcat #(sched/events % (filter (partial events/future-reminder? start)
                                                         (events/trial-reminders trial)))
 (catch java.lang.Throwable e
</code></pre>

<p>"<b>Calendar Render Error</b>"))))))</p>
</td><td class="codes"></td></tr><tr><td class="docs"><p>(defpage experiment-calendar [:get "/api/calendar/experiment/:id"] {:keys [id]}
 (let [experiment (resolve-dbref "experiment" id)]
   (try
     (render-calendar-table nil (generate-reminders experiment (dt/now)
                         {:reminders? true}))
     (catch java.lang.Throwable e
"<b>Calendar Render Error</b>"))))</p>
</td><td class="codes"></td></tr><tr><td class="spacer docs">&nbsp;</td><td class="codes" /></tr><tr><td class="docs"><div class="docs-header"><a class="anchor" href="#experiment.views.charts" name="experiment.views.charts"><h1 class="project-name">experiment.views.charts</h1><a class="toc-link" href="#toc">toc</a></a></div></td><td class="codes" /></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(ns experiment.views.charts
  (:use
   experiment.infra.models
   experiment.models.trial
   experiment.models.events
   experiment.models.schedule
   experiment.models.instruments
   clojure.math.numeric-tower
   handlebars.templates
   hiccup.page-helpers
   noir.core)
  (:require
   [incanter.stats]
   [clojure.tools.logging :as log]
   [clojure.walk :as walk]
   [experiment.views.common :as common]
   [experiment.libs.datetime :as dt]
   [clj-time.core :as time]
   [noir.response :as response]
   [experiment.infra.session :as session]
   [somnium.congomongo :as mongo]))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn convert-to-utc [node]
  (if-let [utc (dt/as-utc node)]
    utc
    node))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn as-utc-dataset [dataset]
  (walk/postwalk convert-to-utc dataset))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn test-regions [start end]
  (let [start (dt/as-utc start)
        end (dt/as-utc end)]
    [{:start (+ start (/ (- end start)  4))
      :end (+ start (* 2 (/ (- end start)  4)))
      :label &quot;On antibiotics&quot;}]))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn tracker-chart
  ([inst start end user]
     {:series
      [{:data (time-series inst user start end false)
        :start start
        :end end
        :dataMin (min-plot inst)
        :dataMax (max-plot inst)}]})
  ([inst start end]
     (tracker-chart inst start end (session/current-user))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn as-int [value]
  (try
    (Integer/parseInt value)
    (catch java.lang.Throwable e
      nil)))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defpage event-chart-api [:get &quot;/api/charts/tracker&quot;] {:keys [inst start end] :as options}
  (let [instrument (get-instrument (deserialize-id inst))]
    (response/json
     (as-utc-dataset
      (tracker-chart instrument
                     (or (dt/from-iso-8601 start)
                         (time/minus (dt/now) (time/months 1)))
                     (or (dt/from-iso-8601 end)
                         (dt/now)))))))</pre></td></tr><tr><td class="docs"><h2>Control chart</h2>
</td><td class="codes"></td></tr><tr><td class="docs"><h3>Add control lines to a run chart</h3>
</td><td class="codes"></td></tr><tr><td class="docs"><p>Convert point rec into point pair</p>
</td><td class="codes"><pre class="brush: clojure">(defn pair-point
  [point-rec]
  [(:ts point-rec) (:v point-rec)])</pre></td></tr><tr><td class="docs"><p>Convert a record series to canonical value seq</p>
</td><td class="codes"><pre class="brush: clojure">(defn series-values
  [series]
  (let [data (:data series)]
    (assert (map? (first data)))
    (map :v data)))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn point-in-period [point period]
  (.contains (:interval period) (:ts point)))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn points-in-periods [periods points]
  (filter #(some (partial point-in-period %) periods) points))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(def testing* nil)</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn baseline-values [chart trial]
  (alter-var-root #'testing* (fn [old] [chart trial]))
  (map :v
       (-&gt; (trial-periods trial)
           (baseline-periods (time/interval (:start chart) (:end chart)))
           (points-in-periods (:data chart)))))</pre></td></tr><tr><td class="docs"><p>Given a chart (outcome sequence as first series), compute the UCL and LCL
   bounds over baseline data (if sufficient is present) using the trial schedule
   to get time regions</p>
</td><td class="codes"><pre class="brush: clojure">(defn control-lines
  [series trial]
  (if (&lt; (count (:data series)) 18)
    series
    (let [yvalues (baseline-values series trial)]
      (if (&gt; (count yvalues) 12)
        (let [mean (incanter.stats/mean yvalues)
              sd (incanter.stats/sd yvalues)
              ucl (min (+ mean (* 3 sd)) (or (:dataMax series) (apply max yvalues)))
              lcl (max (- mean (* 3 sd)) 0.1)]
          (assoc series
            :ctrl {:lcl lcl :ucl ucl :mean mean}))
        series))))</pre></td></tr><tr><td class="docs"><h3>Add regions to the chart</h3>
</td><td class="codes"></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn period-as-region [series period]
  (let [i (:interval period)
        rbegin (.getStart i)
        rend (.getEnd i)
        start (:start series)
        end (:end series)
        rbegin (if (time/after? start rbegin) start rbegin)
        rend (if (time/before? end rend) end rend)]
    (merge 
     {:type &quot;area&quot;
      :start rbegin
      :end rend}
     (case (:label period)
       &quot;base&quot;
       {:color &quot;blue&quot;
        :label &quot;Baseline&quot;}
       &quot;treat&quot;
       {:color &quot;red&quot;
        :label &quot;Treatment&quot;}))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn treatment-regions [series trial]
  (if-let [regions
           (map (partial period-as-region series)
                (trial-periods
                 trial 
                 (time/interval (:start series) (:end series))))]
    (assoc series :regions (vec regions))
    series))</pre></td></tr><tr><td class="docs"><h3>Highlight significant events</h3>
</td><td class="codes"></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn- significant-point [point]
  (merge point {:type &quot;point&quot;}))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn outside-control? [upper lower points]
  (filter (fn [point]
            (or (&gt; (:v point) upper)
                (&lt; (:v point) lower)))
          points))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn- significant-seq [seq]
  {:type &quot;sequence&quot;
   :points (vec seq)})</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn significant-sequences [mean points]
  (letfn [(polarity? [point]
            (cond (&gt; (:v point) mean) :pos
                  (&lt; (:v point) mean) :neg
                  true nil))]
    (when (number? (:v (first points)))
      (loop [points points
             seq '()
             last nil
             seqs '()]
        (let [point (first points)]
          (cond (empty? points) (vec (map vec (reverse seqs)))
                (empty? seq) (if-let [polarity (polarity? point)]
                               (recur (rest points) (list point) (polarity? point) seqs)
                               (recur (rest points) '() nil seqs))
                (&lt; (count seq) 5) (if (= (polarity? point) last)
                                    (recur (rest points) (cons point seq) last seqs)
                                    (recur (rest points) (list point) (polarity? point) seqs))
                true (recur (rest points) '() nil (cons (reverse seq) seqs))))))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn significant-events [series]
  (if-let [ctrl (:ctrl series)]
    (let [{ucl :ucl lcl :lcl mean :mean} ctrl
          points (:data series)
          sig-points (map significant-point
                      (outside-control? ucl lcl points))
          sig-seqs (map significant-seq
                        (significant-sequences mean points))]
      (assoc series
        :significance (vec (concat sig-points sig-seqs))))
    series))</pre></td></tr><tr><td class="docs"><h3>Control chart is tracker + ...</h3>

<p>Control lines, Regions, Annotations</p>
</td><td class="codes"></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn control-chart [trial start end]
  (let [chart (tracker-chart (trial-outcome trial)
                             (or start
                                 (time/minus (dt/now) (time/months 1)))
                             (or end
                                 (dt/now)))]
    {:series [(-&gt; (first (:series chart))
                  (control-lines trial)
                  (treatment-regions trial)
                  (significant-events))]}))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defpage ctrl-chart-api [:get &quot;/api/charts/trial&quot;]
  {:keys [id start end] :as options}
  (let [trial (lookup-trial id)]
    (response/json
     (as-utc-dataset
      (control-chart trial (dt/from-iso-8601 start) (dt/from-iso-8601 end))))))</pre></td></tr><tr><td class="docs"><pre><code>(event-chart-api
 {:inst (str (.getId (first (:outcome (trial-experiment trial)))))
  :start start
  :end end})))
</code></pre>
</td><td class="codes"></td></tr><tr><td class="spacer docs">&nbsp;</td><td class="codes" /></tr><tr><td class="docs"><div class="docs-header"><a class="anchor" href="#experiment.views.common" name="experiment.views.common"><h1 class="project-name">experiment.views.common</h1><a class="toc-link" href="#toc">toc</a></a></div></td><td class="codes" /></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(ns experiment.views.common
  (:use
   noir.core
   hiccup.core
   hiccup.page-helpers
   handlebars.templates
   experiment.views.bootstrap
   experiment.views.menu)
  (:require 
   [clojure.tools.logging :as log]
   [clojure.string :as str]
   [cheshire.core :as json]
   [noir.request :as req]
   [noir.response :as resp]
   [experiment.libs.properties :as props]
   [experiment.libs.mail :as mail]
   [experiment.infra.auth :as auth]
   [experiment.infra.session :as session]
   [experiment.infra.models :as models]
   [experiment.models.user :as user]
   [experiment.views.google :as google]
   [experiment.views.facebook :as facebook]))</pre></td></tr><tr><td class="docs"><h2>View Framework</h2>

<p>This file contains the major page building blocks for our Bootstrap-based
page architecture.  This provides for common page elements such as headers
footers, includes, top level menu navigation as well as registration and login
and markup for modal dialogs, etc.</p>
</td><td class="codes"></td></tr><tr><td class="docs"><h2>Header Fields</h2>
</td><td class="codes"><pre class="brush: clojure">(defn layout-header [title]
  (list
   [:title title]
   [:meta {:charset &quot;utf-8&quot;}]
   [:meta {:http-equiv &quot;X-UA-Compatible&quot; :content &quot;chrome=1&quot;}]
   [:meta {:name &quot;viewport&quot; :content &quot;width=device-width, initial-scale=1.0&quot;}]
   [:meta {:name &quot;author&quot; :content &quot;Ian Eslick&quot;}]
   [:meta {:name &quot;description&quot; :content &quot;Personal Experiments&quot;}]
   [:link {:rel &quot;shortcut icon&quot; :href &quot;/img/favicon.ico&quot;}]))</pre></td></tr><tr><td class="docs"><h2>CSS Libraries</h2>
</td><td class="codes"><pre class="brush: clojure">(defpartial include-css-libs []
  (include-css &quot;/css/bootstrap.css&quot;)
  (include-css &quot;/css/override.css&quot;)
  (include-css &quot;/css/autoSuggest.css&quot;)
  (include-css &quot;/css/calendar.css&quot;)
  (include-css &quot;/css/ui.daterangepicker.css&quot;)
  (include-css &quot;/css/smoothness/jquery-ui-1.8.18.custom.css&quot;))</pre></td></tr><tr><td class="docs"><h2>Javascript Libraries</h2>
</td><td class="codes"><pre class="brush: clojure">(defpartial require-js [deps]
  [:script
   {:type &quot;text/javascript&quot;
    :src &quot;/js/libs/require/require.js&quot;
    :data-main &quot;/js/load&quot;}]
  (when-let [depstring (and deps (map #(format &quot;'%s'&quot; %) deps))]
    [:script
     {:type &quot;text/javascript&quot;}
     &quot;require([&quot;
     (str/join &quot;, &quot; (map #(format &quot;'%s'&quot; %) deps))
     &quot;], function () { console.log('loaded dependencies for: &quot; (format &quot;%s&quot; deps) &quot;') });&quot;]))</pre></td></tr><tr><td class="docs"><h2>Support Standard Page Layouts and Structure</h2>
</td><td class="codes"></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn nav-user-name [&amp; [user]]
  (let [user (or user (session/current-user))]
    (or (:name user)
        (and (get-in user [:preferences :firstname])
             (get-in user [:preferences :lastname])
             (str (get-in user [:preferences :firstname])
                  &quot; &quot;
                  (get-in user [:preferences :lastname])
                  &quot; &quot;))
        (str (:username user) &quot; &quot;))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn- research-submenu []
  [{:name &quot;Authoring Study Page&quot; :href &quot;/study1&quot;}
   {:name &quot;Self-Experiment Study Page&quot; :href &quot;/study2&quot;}])</pre></td></tr><tr><td class="docs"><p>  {:name "Site Analysis" :href "/article/analysis"}</p>
</td><td class="codes"></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn- about-submenu []
  [{:name &quot;About this site&quot; :href &quot;/article/about&quot;}
   {:lprops {:class &quot;divider&quot;}}
   {:name [:b &quot;Our Sponsors&quot;]}
   {:name &quot;MIT's New Media Medicine&quot; :href &quot;http://newmed.media.mit.edu/&quot;}
   {:name &quot;Lybba.org&quot; :href &quot;http://lybba.org&quot;} 
   {:name &quot;C3N Project At CCHMC&quot; :href &quot;Http://c3nproject.org&quot;}])</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn- user-submenu []
  [{:name '([:i.icon-cog] &quot; Account&quot;)
    :href &quot;/account&quot;}
   {:name '([:i.icon-question-sign] &quot; Help&quot;)
    :href &quot;/help&quot;}
   {:lprops {:class &quot;divider&quot;}}
   {:name '([:i.icon-off] &quot; Logout&quot;)
    :href &quot;/action/logout&quot;}])</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn default-nav [&amp; [active]]
  (if-let [user (session/current-user)]
    {:nav
     {:active active
      :main [{:tag &quot;dashboard&quot; :name &quot;Dashboard&quot; :href &quot;/&quot;}
             {:tag &quot;explore&quot; :name &quot;Explore&quot;   :href &quot;/explore&quot;
              :aprops {:class &quot;explore-link&quot;}}
             {:name &quot;Research &quot; :href &quot;#&quot;
              :submenu (research-submenu)}
             {:tag &quot;about&quot; :name &quot;About &quot; :href &quot;#&quot;
              :submenu (about-submenu)}]
      :ctrl [{:name (nav-user-name user)
              :submenu (user-submenu)}]}}
;;     :crumbs [{:name &quot;Home&quot; :href &quot;/&quot;}
;;             {:name &quot;Dashboard&quot; :href &quot;/dashboard&quot;}]}
    {:nav
     {:active active
      :main [{:tag &quot;home&quot; :name &quot;Home&quot; :href &quot;/&quot;}
             {:tag &quot;research&quot; :name &quot;Research&quot; :href &quot;#&quot;
              :submenu (research-submenu)}
             {:tag &quot;about&quot; :name &quot;About &quot; :href &quot;#&quot;
              :submenu (about-submenu)}]
      :ctrl [{:tag &quot;register&quot; :name &quot;Register&quot; :href &quot;#registerModal&quot;
              :aprops {:class &quot;register-button&quot;}}
             {:tag &quot;login&quot; :name &quot;Login&quot; :href &quot;#loginModal&quot;
              :aprops {:class &quot;login-button&quot;}}]}}))</pre></td></tr><tr><td class="docs"><h2>Page Components</h2>
</td><td class="codes"></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defpartial render-footer []
  [:footer.footer
   [:div.container.footer-bar
    [:p
     [:a {:class &quot;footer-link&quot; :href &quot;/article/terms&quot;} &quot;Terms of Use&quot;] &quot;|&quot;
     [:a {:class &quot;footer-link&quot; :href &quot;/article/privacy&quot;} &quot;Privacy&quot;]&quot;|&quot;
     [:a {:class &quot;footer-link&quot; :href &quot;/article/about&quot;} &quot;About&quot;]]
    [:p [:small &quot;[Best viewed on modern browsers: &lt;a href='http://firefox.com'&gt;Firefox 8+&lt;/a&gt;, &lt;a href='http://apple.com/safari/'&gt;Safari 5+&lt;/a&gt;, &lt;a href='http://www.google.com/chrome'&gt;Chrome 14+&lt;/a&gt; or &lt;a href='http://windows.microsoft.com/en-us/internet-explorer/products/ie/home'&gt;Internet Explorer 9&lt;/a&gt;]&quot;]]]])</pre></td></tr><tr><td class="docs"><h2>Default Page</h2>
</td><td class="codes"></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn render-spinner []
  [:div#spinner.spinner
   {:style &quot;display:none&quot;}
   [:img#img-spinner
    {:src &quot;/img/spinner.gif&quot; :alt &quot;Loading&quot;}]])</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(declare render-dialogs)</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defpartial page-frame [[title &amp; {:keys [fixed-size deps]}] &amp; body-content]
  (html5
   [:head
    (layout-header title)
    (require-js deps)
    (google/include-analytics)
    (include-css-libs)
    ]
   [:body {:style (str &quot;padding-top:&quot; (or fixed-size 40) &quot;px; padding-bottom:40px;&quot;)}
    body-content
    (render-footer)
    (render-spinner)]))</pre></td></tr><tr><td class="docs"><p>   (facebook/include-jsapi)
   (include-js-libs)</p>
</td><td class="codes"></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defpartial layout [[title nav &amp; rest] &amp; content]
  (page-frame (vec
               (concat (list title :fixed-size (if (:subnav nav) 90 50))
                       rest))
    (nav-fixed (:nav nav))
    (subnav-fixed (:subnav nav))
    (when-let [crumbs (:crumbs nav)]
      (breadcrumbs crumbs))
    content))</pre></td></tr><tr><td class="docs"><h2>Simple content pages</h2>
</td><td class="codes"></td></tr><tr><td class="docs"><p>/not-supported</p>
</td><td class="codes"><pre class="brush: clojure">(defpage not-supported  {}
  (layout
   &quot;Browser Not Supported&quot;
   (default-nav)
   [:div.content
    [:h2 &quot;Your browser is not supported by this site&quot;]]))</pre></td></tr><tr><td class="docs"><p>/util/show-request</p>
</td><td class="codes"><pre class="brush: clojure">(defpage show-map  {}
  (layout
   &quot;Show Debug Request Map&quot;
   (default-nav)
   [:div.content
    (interpose
     '[:br]
     (clojure.string/split 
      (with-out-str
        (clojure.pprint/write
         (noir.request/ring-request)))
      #&quot;\n&quot;))]))</pre></td></tr><tr><td class="docs"><h2>Building blocks for rich-client applications</h2>
</td><td class="codes"></td></tr><tr><td class="docs"><h2>Serialize Models</h2>
</td><td class="codes"><pre class="brush: clojure">(defn bootstrap-user-json []
  [:script {:type &quot;text/json&quot; :id &quot;bootstrap-user&quot;}
   (json/generate-string
    (models/server-&gt;client
     (session/current-user)))])</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn bootstrap-models-json [models]
  [:script {:type &quot;text/json&quot; :id &quot;bootstrap-models&quot;}
   (json/generate-string
    (models/server-&gt;client models))])</pre></td></tr><tr><td class="docs"><h2>Send client-side templates</h2>
</td><td class="codes"><pre class="brush: clojure">(defn render-template [id template]
  (inline-template
   id template &quot;text/x-jquery-html&quot;))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn render-all-templates
  ([]
     (map (fn [[name template]]
            (render-template name template))
          (all-templates)))
  ([names]
     (map (fn [[name template]]
            (render-template name template))
          (select-keys (all-templates) list))))</pre></td></tr><tr><td class="spacer docs">&nbsp;</td><td class="codes" /></tr><tr><td class="docs"><div class="docs-header"><a class="anchor" href="#experiment.views.dashboard" name="experiment.views.dashboard"><h1 class="project-name">experiment.views.dashboard</h1><a class="toc-link" href="#toc">toc</a></a></div></td><td class="codes" /></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(ns experiment.views.dashboard
  (:use
   noir.core
   hiccup.core
   hiccup.page-helpers
   hiccup.form-helpers
   experiment.models.suggestions
   experiment.views.common
   experiment.views.menu
   handlebars.templates)
  (:require
   [cheshire.core :as json]
   [noir.response :as resp]
   [experiment.infra.session :as session]
   [experiment.infra.models :as models]
   [experiment.models.user :as user]
   [experiment.models.profile]
   [experiment.models.events :as events]
   [experiment.views.trials :as trials]))</pre></td></tr><tr><td class="docs"><hr />

<h2>Dashboard </h2>

<p>This file packages and renders most resources relevant to the
client application including client-side templates, data
bootstrapping and HTML skeletons.</p>
</td><td class="codes"></td></tr><tr><td class="docs"><p>See views/common.clj for the static page template and menu
rendering</p>
</td><td class="codes"></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn menu-content []
  [[&quot;dashboard&quot; &quot;Dashboard&quot;]
   (concat [&quot;trials&quot; &quot;Trials&quot;]
           (map (fn [model num]
                  [(:_id model) (str &quot;Trial &quot; num)])
                (user/trials)
                (range 1 10)))
   [&quot;search&quot; &quot;Search&quot;]
   (when (user/is-admin?)
     [&quot;admin&quot; &quot;Admin&quot;])])</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defpartial nav-layout []
  [:div#nav-pane.left-side-bar
   [:hr]
   [:div#main-menu.main-menu nil]
;;    (render-menu (menu-content))]
   [:div.nav-footer
    (image &quot;/img/c3ntheme_logo.png&quot; &quot;C3N Logo&quot;)
    [:br]
    [:div {:style &quot;text-align: center&quot;}
     (link-to &quot;/article/terms&quot; &quot;Terms of Use&quot;)
     &quot;&amp;nbsp; | &amp;nbsp;&quot;
     (link-to &quot;/article/privacy&quot; &quot;Privacy&quot;)
     &quot;&amp;nbsp;&quot;]]])</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defpartial bootstrap-data []
;;  (bootstrap-models-json
;;   (concat
;;    (models/fetch-models :treatment)
;;    (models/fetch-models :instrument)
;;    (models/fetch-models :experiment)))
  (bootstrap-user-json))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn dashboard-subnav [current]
  {:menu
   [{:tag &quot;overview&quot; :name &quot;Overview&quot; :href &quot;overview&quot;}
;;    {:name &quot;Trials&quot; :href &quot;#&quot;}
    {:tag &quot;timeline&quot; :name &quot;Timeline&quot; :href &quot;timeline&quot;}
    {:tag &quot;events&quot; :name &quot;Events&quot; :href &quot;eventlog&quot;}
;;    {:name &quot;Activity&quot; :href &quot;#&quot;}
    {:tag &quot;journal&quot; :name &quot;Journal&quot; :href &quot;journal&quot;}]
   :active current})</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defpartial dashboard-layout [options]
  (page-frame
   [&quot;Personal Experiments Dashboard&quot;
    :fixed-size 100
    :deps [&quot;views/common&quot;, &quot;views/dashboard&quot;]]
   (nav-fixed (:nav (default-nav &quot;dashboard&quot;)))
   (subnav-fixed (dashboard-subnav (:subnav options)))
   [:div.container {:style &quot;min-height: 400px;&quot;}
    [:div.tab-content 
     [:div#overview.tab-pane]
     [:div#timeline.tab-pane]
     [:div#eventlog.tab-pane]
     [:div#journal.tab-pane]]]
   (bootstrap-data)        ;; models
   (render-all-templates))) ;; views</pre></td></tr><tr><td class="docs"><p>views</p>
</td><td class="codes"></td></tr><tr><td class="docs"><p>/dashboard/:subnav</p>
</td><td class="codes"><pre class="brush: clojure">(defpage dashboard-dispatch  {:as options}
  (dashboard-layout options))</pre></td></tr><tr><td class="docs"><p>/dashboard/:subnav/:args*</p>
</td><td class="codes"><pre class="brush: clojure">(defpage dashboard-dispatch-args  {:as options}
  (dashboard-layout options))</pre></td></tr><tr><td class="docs"><p>/dashboard</p>
</td><td class="codes"><pre class="brush: clojure">(defpage dashboard-redir  {:as options}
  (resp/redirect &quot;/dashboard/overview&quot;))</pre></td></tr><tr><td class="spacer docs">&nbsp;</td><td class="codes" /></tr><tr><td class="docs"><div class="docs-header"><a class="anchor" href="#experiment.views.discuss" name="experiment.views.discuss"><h1 class="project-name">experiment.views.discuss</h1><a class="toc-link" href="#toc">toc</a></a></div></td><td class="codes" /></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(ns experiment.views.discuss
  (:use experiment.infra.models
        noir.core
        hiccup.core
        hiccup.page-helpers
        hiccup.form-helpers)
  (:require
   [clojure.string :as str]
   [noir.validation :as vali]
   [clodown.core :as md]
   [experiment.libs.datetime :as dt]
   [experiment.infra.session :as session]
   [experiment.models.comment :as comment]))</pre></td></tr><tr><td class="docs"><p>Active forms</p>
</td><td class="codes"></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(def ^{:dynamic true} *submitted-data* nil)</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defmacro with-submission [data &amp; body]
  `(binding [*submitted-data* ~data]
     ~@body))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn active-form? [id]
  (and *submitted-data*
       (or (= id (:id *submitted-data*))
           (and (nil? id) (= (count (:id *submitted-data*)) 0)))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn submitted-text []
  (:text *submitted-data*))</pre></td></tr><tr><td class="docs"><p>Partials</p>
</td><td class="codes"></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defpartial error-text [errors]
  [:p.error (str/join &quot;&lt;br/&gt;&quot; errors)])</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defpartial comment-fields [id]
  (when (active-form? id)
    (vali/on-error :text error-text))
  (if (active-form? id)
    (text-area :text (submitted-text))
    (text-area {:placeholder &quot;Comment&quot;} :text))
  (hidden-field :id id))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn form-class [id]
  (if (active-form? id)
    &quot;comment-form&quot;
    &quot;hidden comment-form&quot;))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn comment-form [base link-title current-id]
  [:div
   [:a.show-dform {:href } (or link-title &quot;Reply&quot;)]
   [:div {:class (form-class current-id)}
    (form-to [:post base]
             (comment-fields current-id)
             [:br]
             [:button.btn.btn-success {:type &quot;submit&quot;} &quot;Save&quot;]
             [:button.btn [:a {:href } &quot;Cancel&quot;]])]])</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn comment-body [comment]
  (let [{:keys [date owner html]} comment]
    [:div.discussion-body {:id (comment/comment-id comment)}
     [:span.discussion-byline
      &quot;Posted by &quot; [:b owner] &quot; at &quot; (dt/as-short-string
                                      (dt/in-default-tz
                                       (dt/from-utc date)))]
     html]))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn discussion-class [level]
  (format &quot;discussion discussion-%d&quot; level))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn discussion-thread
  ([base discussion level]
     [:div {:class (discussion-class level)}
      (comment-body discussion)
      (when (session/current-user)
        (comment-form base &quot;Reply&quot; (str (:_id discussion))))
      (map #(discussion-thread base % (+ level 1)) (:children discussion))
      (if (= level 0) [:hr])])
  ([base discussion]
     (discussion-thread base discussion 0)))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defpartial discussions [scope base]
  (let [discussions (comment/all-discussions scope)]
    (list
     (if (session/current-user)
       (comment-form base &quot;Ask a New Question&quot; nil)
       [:em &quot;You must be &quot; [:a.login-button &quot;logged-in&quot;] &quot; to add new comments&quot;])
     [:hr]
     (if (empty? discussions)
       [:h3 &quot;No discussions found&quot;]
       (map (partial discussion-thread base) discussions)))))</pre></td></tr><tr><td class="spacer docs">&nbsp;</td><td class="codes" /></tr><tr><td class="docs"><div class="docs-header"><a class="anchor" href="#experiment.views.explore" name="experiment.views.explore"><h1 class="project-name">experiment.views.explore</h1><a class="toc-link" href="#toc">toc</a></a></div></td><td class="codes" /></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(ns experiment.views.explore
  (:use
   noir.core
   hiccup.core
   hiccup.page-helpers
   hiccup.form-helpers
   experiment.models.suggestions
   experiment.views.common
   experiment.views.menu
   handlebars.templates)
  (:require
   [cheshire.core :as json]
   [noir.response :as resp]
   [experiment.infra.session :as session]
   [experiment.infra.models :as models]
   [experiment.models.user :as user]
   [experiment.models.profile]
   [experiment.models.events :as events]
   [experiment.views.trials :as trials]))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defpage &quot;/explore/*&quot; {:as options}
  (page-frame
   [&quot;Explore Experiments&quot;
    :fixed-size 40
    :deps [&quot;views/common&quot;, &quot;views/explore&quot;]]
   (nav-fixed (:nav (default-nav &quot;explore&quot;)))
   [:div#crumbs]
   [:div.container {:style &quot;min-height: 400px&quot;}
    [:div#explore]]
   [:div#templates
    (render-all-templates)
    (bootstrap-user-json)]))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defpage &quot;/explore&quot; {:as options}
  (resp/redirect &quot;/explore/search&quot;))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(deftemplate search-header
  [:div.header
   [:div {:class &quot;well search-box&quot;}
    [:div.pull-left
     (text-field {:class &quot;search-query input-xxlarge&quot;} &quot;q&quot; (% this))
     [:button.btn {:type &quot;button&quot; :class &quot;btn search-btn&quot;} &quot;Search&quot;]
     [:button.btn {:type &quot;button&quot; :class &quot;btn help-btn&quot;} &quot;Help&quot;]]
    [:div.pull-right
     [:div.btn-group
      [:a.btn.btn-primary.dropdown-toggle {:data-toggle &quot;dropdown&quot; :href &quot;#&quot;}
       &quot;Create &quot;
       [:span.caret]]
      [:ul.dropdown-menu
       [:li.menuitem
        [:a {:href &quot;#&quot; :class &quot;action create-experiment&quot;}
         &quot;Experiment&quot;]]
       [:li.menuitem
        [:a {:href &quot;#&quot; :class &quot;action create-treatment&quot;}
         &quot;Treatment&quot;]]]]]]
   [:div#pagination]
   [:div.row
    [:div#results.span8
     [:p]]
    [:div.span4
     [:h2 &quot;Popular Searches&quot;]
     [:ul
      [:li [:a.popsearch {:href &quot;#&quot;} &quot;show treatments&quot;]]
      [:li [:a.popsearch {:href &quot;#&quot;} &quot;show experiments&quot;]]
      [:li [:a.popsearch {:href &quot;#&quot;} &quot;show instruments&quot;]]]
     [:div#popular]]]])</pre></td></tr><tr><td class="docs"><pre><code> [:li.menuitem
  [:a {:href "#" :class "action create-instrument"}
   "Instrument"]]]]]])
</code></pre>
</td><td class="codes"></td></tr><tr><td class="spacer docs">&nbsp;</td><td class="codes" /></tr><tr><td class="docs"><div class="docs-header"><a class="anchor" href="#experiment.views.facebook" name="experiment.views.facebook"><h1 class="project-name">experiment.views.facebook</h1><a class="toc-link" href="#toc">toc</a></a></div></td><td class="codes" /></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(ns experiment.views.facebook
  (:use
   noir.core
   hiccup.core)
  (:require
   [experiment.libs.properties :as props]))</pre></td></tr><tr><td class="docs"><h1>Facebook integration</h1>
</td><td class="codes"></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(def facebook-init-script
  (format &quot;window.fbAsyncInit = function () {
      FB.init({
            appId      : '%s',
            status     : true, 
            cookie     : true,
            xfbml      : true,
            oauth      : true,
          });
        };
        (function(d) {
           var js, id = 'facebook-jssdk'; if (d.getElementById(id)) {return;}
           js = d.createElement('script'); js.id = id; js.async = true;
           js.src = \&quot;//connect.facebook.net/en_US/all.js\&quot;;
           d.getElementsByTagName('head')[0].appendChild(js);
         }(document));&quot; (props/get :facebook.appid)))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn include-jsapi []
  (if (= (props/get :mode) :dev)
    (html
     [:div#fb-root]
     [:script facebook-init-script])))</pre></td></tr><tr><td class="docs"><h1>Facebook User Widgets</h1>
</td><td class="codes"></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defpartial login-button [title]
  [:div.fb-login-button {:data-scope &quot;email&quot;} title])</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defpartial register-button [target]
  [:div
   {:class &quot;fb-registration&quot;
    :data-scope &quot;email&quot;
    :data-fields &quot;[{'name':'name'}, {'name':'email'}]&quot;
    :data-redirect-uri target}])</pre></td></tr><tr><td class="spacer docs">&nbsp;</td><td class="codes" /></tr><tr><td class="docs"><div class="docs-header"><a class="anchor" href="#experiment.views.google" name="experiment.views.google"><h1 class="project-name">experiment.views.google</h1><a class="toc-link" href="#toc">toc</a></a></div></td><td class="codes" /></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(ns experiment.views.google
  (:require
   [experiment.libs.properties :as props]))</pre></td></tr><tr><td class="docs"><p>Create the google analytics script from site properties</p>

<h1>Google Analytics</h1>
</td><td class="codes"><pre class="brush: clojure">(def analytics-script
  (format &quot;&lt;script type=\&quot;text/javascript\&quot;&gt;
  var _gaq = _gaq || [];
  _gaq.push(['_setAccount', '%s']);
  _gaq.push(['_setDomainName', '%s']);
  _gaq.push(['_setAllowLinker', true]);
  _gaq.push(['_trackPageview']);
  (function() {
    var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
    ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
  })();
&lt;/script&gt;&quot;
          (props/get :google.analytics.id)
          (props/get :google.analytics.dom)))</pre></td></tr><tr><td class="docs"><p>Use in production mode only</p>
</td><td class="codes"><pre class="brush: clojure">(defn include-analytics
  []
  (when (= (props/get :mode) :prod)
    analytics-script))</pre></td></tr><tr><td class="spacer docs">&nbsp;</td><td class="codes" /></tr><tr><td class="docs"><div class="docs-header"><a class="anchor" href="#experiment.views.help" name="experiment.views.help"><h1 class="project-name">experiment.views.help</h1><a class="toc-link" href="#toc">toc</a></a></div></td><td class="codes" /></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(ns experiment.views.help
  (:use noir.core
        hiccup.core
        hiccup.page-helpers
        [hiccup.form-helpers :exclude [form-to label]]
        experiment.infra.models
        experiment.models.user
        experiment.models.article
        experiment.views.bootstrap
        experiment.views.discuss)
  (:require
   [clojure.tools.logging :as log]
   [noir.response :as resp]
   [noir.request :as req]
   [experiment.infra.session :as session]
   [experiment.models.comment :as comment]
   [experiment.views.common :as common]
   [experiment.views.discuss :as discuss]))</pre></td></tr><tr><td class="docs"><p>Discussion page</p>
</td><td class="codes"></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defpage &quot;/help&quot; {}
  (common/layout
   [&quot;Help Page&quot;
    (common/default-nav (common/nav-user-name))]
   [:div.container
    [:div.page-header
     [:h1 &quot;Help for Personal Experiments&quot;]
     [:p &quot;This page provides a place for asking questions about personal experiments.  You must be a logged-in user to add new comments here&quot;]]
    [:div.span8
     (discuss/discussions &quot;help&quot; &quot;/help&quot;)]]))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defpage [:post &quot;/help&quot;]
  {pid :id text :text :as data}
  (if (comment/valid? text)
    (do
      (comment/comment! &quot;help&quot; pid text)
      (render &quot;/help&quot;))
    (do
      (discuss/with-submission data
        (render &quot;/help&quot; data)))))</pre></td></tr><tr><td class="spacer docs">&nbsp;</td><td class="codes" /></tr><tr><td class="docs"><div class="docs-header"><a class="anchor" href="#experiment.views.home" name="experiment.views.home"><h1 class="project-name">experiment.views.home</h1><a class="toc-link" href="#toc">toc</a></a></div></td><td class="codes" /></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(ns experiment.views.home
  (:require
   [experiment.views.common :as common]
   [experiment.infra.session :as session]
   [somnium.congomongo :as mongo]
   [noir.response :as resp]
   [noir.util.crypt :as crypt])
  (:use noir.core
        hiccup.core
        hiccup.page-helpers
        [hiccup.form-helpers :exclude [input form-to]]
        experiment.views.bootstrap))</pre></td></tr><tr><td class="docs"><h2>Home Page Layout</h2>
</td><td class="codes"></td></tr><tr><td class="docs"><h2>Carousel</h2>
</td><td class="codes"></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn academy-health []
  [:div#academyHealth.hero-unit
   [:div.pull-right
    [:img {:style &quot;height: 200px; margin-top: -40px; margin-right: 40px;&quot;
           :src &quot;img/academy-health.jpg&quot;}]]
   [:h1 &quot;In the News&quot;]
   [:p &quot;PersonalExperiments.org wins &quot; [:a {:href &quot;http://blog.academyhealth.org/?p=574&quot;} &quot;runner-up&quot;] &quot; in &quot; [:a {:href &quot;http://academyhealth.org&quot;} &quot;Academy Health's&quot;] [:br] [:a {:href &quot;http://www.health2challenge.org/relevant-evidence-to-advance-care-and-health-reach/&quot;} &quot;REACH competition&quot;] &quot; under the entry 'Aggregated Self-Experiments'&quot;]
   [:small [:em &quot;January 31st, 2012&quot;]]])</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn study1-announce []
  [:div#study1.hero-unit
   [:h1 &quot;Author an Experiment&quot;]
   [:p &quot;PersonalExperiments.org is dedicated to help individuals discover effective ways to improve their health and wellbeing.  Join our first MIT-run &quot; [:a {:href &quot;/study1&quot;} &quot;authoring study&quot;] &quot; today to help us create better tools for you.&quot;]
   [:small [:em &quot;March 15th, 2012&quot;]]])</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn study2-announce []
  [:div#study2.hero-unit
   [:div.pull-right
    [:img {:style &quot;height: 200px; margin-top: -40px; margin-right: 40px;&quot;
           :src &quot;img/academy-health.jpg&quot;}]]
   [:h1 &quot;Self-Experiments&quot;]
   [:p &quot;We are inviting patients to participate in a formal study of two
        treatments that patient anecdote indicates may help some people with psoriasis.&quot;]
   [:small [:em &quot;June 1st, 2012&quot;]]])</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn home-carousel [id]
  (carousel id (list (study2-announce)
                     (study1-announce)
                     (academy-health))))</pre></td></tr><tr><td class="docs"><h2>Feature Boxes</h2>
</td><td class="codes"></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(def detail-records
  [{:header &quot;Find Treatments&quot;
    :body &quot;This site contains dozens of small lifestyle changes and
     alternative therapies you can try out on your own to see if they help.&quot;
    :link &quot;/article/treatment&quot;}
;;    :icon &quot;icon-plus&quot;}
   {:header &quot;Experiment&quot;
    :body &quot;The site can help you try out new treatments by running
    structured, personal experiments that help you track your
    treatments, symptoms, and assess impact.&quot;
    :link &quot;/article/experiment&quot;}
;;    :icon &quot;icon-random&quot;}
   {:header &quot;Simplify Tracking&quot;
    :body &quot;We integrate with the Zeo, Strava.com, your phone's SMS,
    and over e-mail to simplify your self discovery process.  More
    integrations are coming!&quot;
    :link &quot;/article/track&quot;}
   {:header &quot;Share Outcomes&quot;
    :body &quot;You can journal privately or publicly about your
    experiences.  You can comment and discuss treatments or
    experiments with other users or on social media&quot;
    :link &quot;/article/share&quot;}
   {:header &quot;Design your own&quot;
    :body &quot;You can use a previously-defined experiment, or you can add
    your own treatments and experiments. You can help improve this
    feature by &lt;a href=\&quot;/study1\&quot;&gt;participating in our study.&lt;/a&gt;&quot;
    :link &quot;/article/design&quot;}
   {:header &quot;Learn more...&quot;
   :body &quot;This project is a work in progress to help us understand how
   ordinary people can collaborate to make personal discoveries about
   treatments.&quot; ;; See our &lt;a href=\&quot;/article/about\&quot;&gt;demo&lt;/a&gt;&quot;
   :link &quot;/article/about&quot;}])</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defpartial render-home-detail [record]
  [:li.span4.home-detail
   [:div.thumbnail
    [:h2 [:a {:href (:link record)} [:i {:class (:icon record)}] &quot; &quot; (:header record)]]
    [:p (:body record)]]])</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defpartial home-page-details []
  [:ul.thumbnails
   (map render-home-detail detail-records)])</pre></td></tr><tr><td class="docs"><h3>Sponsor Bar</h3>
</td><td class="codes"></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn render-thumbnail [url imgurl &amp; {:as styles}]
  [:a.thumbnail {:href url }
   [:img (assoc styles :src imgurl)]])</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defpartial sponsor-bar []
  [:div.sponsor-bar
   [:div.byline
    &quot;Created/Sponsored By&quot;]
   [:div
    [:ul.thumbnails
     [:li {:style &quot;padding-top:25px;&quot;}
      (render-thumbnail &quot;http://lybba.org&quot;
                        &quot;http://www.lybba.org/wp-content/uploads/images/lybba_logo.png&quot;
                        :alt &quot;Lybba.org&quot;)]
     [:li
      (render-thumbnail &quot;http://www.media.mit.edu/&quot;
                        &quot;http://t3.gstatic.com/images?q=tbn:ANd9GcQ9s6ovS4qdVf568bDL9Xdn8xAKTgaJIhdbdi1-jPq9lc-qYjxGYw&quot;
                        :alt &quot;MIT Media Laboratory&quot;
                        :width &quot;130px&quot;)]
     [:li
      (render-thumbnail &quot;http://c3nproject.org/&quot;
                        &quot;http://c3nproject.org/sites/bmidrupalpc3n.chmcres.cchmc.org/files/c3ntheme_logo.png&quot;
                        :alt &quot;C3N Project&quot;)]]]])</pre></td></tr><tr><td class="docs"><h2>Home Page</h2>
</td><td class="codes"></td></tr><tr><td class="docs"><p>/</p>
</td><td class="codes"><pre class="brush: clojure">(defpage public-home-page  {}
  (common/layout
   [&quot;Welcome to Personal Experiments&quot;
    (common/default-nav &quot;Home&quot;)
    :deps [&quot;views/home&quot; &quot;libs/misc/jstz.min&quot;]]
   [:div.container.home-page
    (home-carousel &quot;homeCarousel&quot;)
    (home-page-details)
    (sponsor-bar)]))</pre></td></tr><tr><td class="spacer docs">&nbsp;</td><td class="codes" /></tr><tr><td class="docs"><div class="docs-header"><a class="anchor" href="#experiment.views.menu" name="experiment.views.menu"><h1 class="project-name">experiment.views.menu</h1><a class="toc-link" href="#toc">toc</a></a></div></td><td class="codes" /></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(ns experiment.views.menu
  (:use
   noir.core
   hiccup.core
   experiment.views.bootstrap
   hiccup.page-helpers
   [hiccup.form-helpers :exclude [form-to input]])
  (:require
   [experiment.infra.session :as session]))</pre></td></tr><tr><td class="docs"><hr />

<h2>Generic Menus (I hope) for site frame and other pages</h2>
</td><td class="codes"></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn- bar-search [search]
  (when search
    [:form.navbar-search {:action }
     [:input.span2 {:type &quot;text&quot;}]]))</pre></td></tr><tr><td class="docs"><h2>Layout for Site Nav Bar</h2>
</td><td class="codes"><pre class="brush: clojure">(defpartial nav-fixed [menu]
  [:div.navbar.navbar-fixed-top
   [:div.navbar-inner
    [:div.container 
     [:a.brand {:href &quot;/&quot;}
      &quot;Personal Experiments&quot;]
     (nav-menu (:main menu) (:active menu))
     [:div.pull-right
      (bar-search (:search menu))
      (nav-menu (:ctrl menu) (:active menu))]]]])</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defpartial subnav-fixed [menu]
  (when menu
    [:div.subnav.subnav-fixed-top
     [:div.nav-inner
      [:div.container
       (nav-menu {:class &quot;nav nav-pills&quot;} (:menu menu) (:active menu))]]]))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn- breadcrumb [{:keys [name href props]}]
  [:li props
   [:a {:href href} name]
   [:span.divider]])</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defpartial breadcrumbs [crumbs]
  [:ul.breadcrumb (map breadcrumb crumbs)])</pre></td></tr><tr><td class="docs"><h2>Application Window Menu</h2>
</td><td class="codes"><pre class="brush: clojure">(defpartial render-submenu [parent menu]
  [:ul {:class &quot;submenu&quot; :style &quot;display: none;&quot;}
   (keep (fn [[name content]]
           [:li {:class &quot;subitem&quot;}
            [:a {:href (str parent &quot;/&quot; name) :class &quot;action&quot;}
             content]])
	menu)])</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defpartial render-menu [menu]
  [:ul ;; {:class &quot;menulist&quot;}
   (map (fn [[name content &amp; subitems]]
	  (when name
	    (let [base (str name)]
	      [:li {:class &quot;menuitem&quot;}
	       [:a {:href base :class (if subitems &quot;expand&quot; &quot;action&quot;)}
		content]
	       (when subitems (render-submenu base subitems))])))
	menu)])</pre></td></tr><tr><td class="spacer docs">&nbsp;</td><td class="codes" /></tr><tr><td class="docs"><div class="docs-header"><a class="anchor" href="#experiment.views.omh" name="experiment.views.omh"><h1 class="project-name">experiment.views.omh</h1><a class="toc-link" href="#toc">toc</a></a></div></td><td class="codes" /></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(ns experiment.views.omh
  (:use
   experiment.infra.models
   experiment.models.samples)
  (:require
   [clj-time.core :as time]
   [experiment.libs.datetime :as dt]))</pre></td></tr><tr><td class="spacer docs">&nbsp;</td><td class="codes" /></tr><tr><td class="docs"><div class="docs-header"><a class="anchor" href="#experiment.views.pages" name="experiment.views.pages"><h1 class="project-name">experiment.views.pages</h1><a class="toc-link" href="#toc">toc</a></a></div></td><td class="codes" /></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(ns experiment.views.pages
  (:require
   [noir.response :as resp]
   [experiment.infra.models :as models]
   [experiment.infra.session :as session]
   [experiment.models.user :as user]
   [experiment.models.core :as core]
   [experiment.views.common :as common])
  (:use noir.core
        hiccup.core
        hiccup.page-helpers
	hiccup.form-helpers
	experiment.libs.highcharts
	handlebars.templates))</pre></td></tr><tr><td class="docs"><p>This file contains templates and other harness for differnet
page-level views for the main client application framework</p>
</td><td class="codes"></td></tr><tr><td class="docs"><p>===========================
Dashboard</p>
</td><td class="codes"></td></tr><tr><td class="docs"><p>{:trials
:user
:tracking }</p>
</td><td class="codes"></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(deftemplate dashboard-header
  [:div.dashboard-header
   [:ul
    [:li [:a.tab.active-tab {:href &quot;/app/dashboard/overview&quot;} &quot;Overview&quot;]]
    [:li [:a.tab {:href &quot;/app/dashboard/tracking&quot;} &quot;Tracking&quot;]]
    [:li [:a.tab {:href &quot;/app/dashboard/journal&quot;} &quot;Journal Log&quot;]]]])</pre></td></tr><tr><td class="docs"><p>Application renders views of data   </p>
</td><td class="codes"></td></tr><tr><td class="docs"><p>===========================
Search</p>
</td><td class="codes"></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(deftemplate search-filter
  [:div.search-filter
   [:input {:type &quot;text&quot;
	    :id &quot;search-filter-input&quot;
	    :value (% query)}]
   [:span.filter-guide
    &quot;&lt;b&gt;show&lt;/b&gt; type, &lt;b&gt;with&lt;/b&gt; treatment, &lt;b&gt;for&lt;/b&gt; symptom/condition, &lt;b&gt;use&lt;/b&gt; instrument &amp;nbsp;&quot; [:a.help-link {:href &quot;#&quot;} &quot;[More help...]&quot;]]])</pre></td></tr><tr><td class="docs"><p>===========================
Admin</p>
</td><td class="codes"></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(deftemplate admin-main
  [:div [:h1 &quot;This is the admin template&quot;]])</pre></td></tr><tr><td class="spacer docs">&nbsp;</td><td class="codes" /></tr><tr><td class="docs"><div class="docs-header"><a class="anchor" href="#experiment.views.settings" name="experiment.views.settings"><h1 class="project-name">experiment.views.settings</h1><a class="toc-link" href="#toc">toc</a></a></div></td><td class="codes" /></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(ns experiment.views.settings
  (:use
   noir.core
   hiccup.core
   hiccup.page-helpers
   experiment.views.menu
   handlebars.templates)
  (:require
   [noir.response :as resp]
   [experiment.infra.services :as services]
   [experiment.infra.session :as session]
   [experiment.views.common :as common]
   [experiment.libs.zeo :as zeo]))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn settings-subnav [active]
  {:menu
   [{:tag &quot;preferences&quot; :name &quot;Preferences&quot; :href &quot;preferences&quot;}
    {:tag &quot;services&quot; :name &quot;Services&quot; :href &quot;services&quot;}
    {:tag &quot;password&quot; :name &quot;Change Password&quot; :href &quot;password&quot;}]
   :active active})</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn settings-nav [active]
  (assoc (common/default-nav &quot;user&quot;)
    :subnav (settings-subnav active)))</pre></td></tr><tr><td class="docs"><p>/account/:subnav</p>
</td><td class="codes"><pre class="brush: clojure">(defpage settings-page  {:keys [subnav] :as options}
  (common/page-frame
   [&quot;Personal Experiments Account Settings&quot;
    :fixed-size 100
    :deps [&quot;views/settings&quot;]]
   (nav-fixed (:nav (common/default-nav &quot;user&quot;)))
   (subnav-fixed (settings-subnav subnav))
   [:div.container {:style &quot;min-height: 400px&quot;}
    [:div#main]]
   (common/bootstrap-user-json)
   (services/render-registry)
   (common/render-all-templates)))</pre></td></tr><tr><td class="docs"><p>/account</p>
</td><td class="codes"><pre class="brush: clojure">(defpage settings-redir  {}
  (resp/redirect &quot;/account/preferences&quot;))</pre></td></tr><tr><td class="docs"><p>Personal Information (TAB 1)
- gender
- birthdate
- weight
- height
- state
- country
- time zone</p>
</td><td class="codes"></td></tr><tr><td class="docs"><p>View preferences (TAB 2)
- date fmt
- units
- chart pref
- my url</p>
</td><td class="codes"></td></tr><tr><td class="docs"><p>Contact options
- e-mail on related comments
- inhibit reminders</p>
</td><td class="codes"></td></tr><tr><td class="docs"><p>Services (TAB 2)
- List of services (cell, e-mail, withings, etc)</p>
</td><td class="codes"></td></tr><tr><td class="docs"><p>Password (TAB 3)</p>
</td><td class="codes"></td></tr><tr><td class="docs"><p>Social Media (TAB 4)
- Facebook</p>
</td><td class="codes"></td></tr><tr><td class="docs"><p>Service View Templates</p>
</td><td class="codes"></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(deftemplate services-header-template
  [:div
   [:span.page-header
    [:h1.pull-left &quot;Service Connections&quot;]
    [:span.btn-group.pull-right
     [:a.btn.btn-success.dropdown-toggle {:data-toggle &quot;dropdown&quot; :href &quot;#&quot;}
      &quot;Add Service &quot; [:span.caret]]
     [:ul.dropdown-menu
      (%each services
        [:li [:a.new {:href (% tag)} (% name)]])]]]
   [:div {:style &quot;clear: both;&quot;}]
   [:hr]])</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(deftemplate service-template
  [:div.span7.well
   [:span.pull-right
    [:button.btn.btn-mini.btn-danger.del
     {:data-tag (% config.tag)}
     [:i.icon-remove.icon-white]]]
   [:h2 (% config.name)]
   [:p (% config.description)]
   [:div.svcform]])</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(deftemplate service-oauth-template
  [:div.span7.well
   [:span.pull-right
    [:button.btn.btn-mini.btn-danger.del
     {:data-tag (% config.tag)}
     [:i.icon-remove.icon-white]]]
   [:h2 (% config.name)]
   [:p (% config.description)]
   (%if oauth
        [:p &quot;Connected as : &quot; (% oauth.name)])
   (%unless oauth
        [:p &quot;Connect to &quot; [:a {:href (% config.url)} (% config.title)]])])</pre></td></tr><tr><td class="spacer docs">&nbsp;</td><td class="codes" /></tr><tr><td class="docs"><div class="docs-header"><a class="anchor" href="#experiment.views.study1" name="experiment.views.study1"><h1 class="project-name">experiment.views.study1</h1><a class="toc-link" href="#toc">toc</a></a></div></td><td class="codes" /></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(ns experiment.views.study1
  (:use noir.core
        hiccup.core
        hiccup.page-helpers
	hiccup.form-helpers
	experiment.infra.models
	experiment.models.user
        experiment.models.article
        experiment.views.discuss)
  (:require
   [clojure.tools.logging :as log]
   [clojure.string :as str]
   [somnium.congomongo :as mongo]
   [clodown.core :as markdown]
   [noir.response :as resp]
   [noir.request :as req]
   [noir.util.crypt :as crypt]
   [noir.validation :as vali]
   [experiment.infra.session :as session]
   [experiment.views.common :as common]
   [experiment.models.comment :as comment]
   [experiment.views.discuss :as discuss]
   [experiment.infra.auth :as auth]
   [experiment.libs.datetime :as dt]))</pre></td></tr><tr><td class="docs"><h2>Authoring Study Page</h2>
</td><td class="codes"></td></tr><tr><td class="docs"><h2>Utilities</h2>
</td><td class="codes"></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn consent-patient! []
  (set-pref! :study1-consented true))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn patient-consented? []
  (get-pref :study1-consented))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn record-experiment [exp]
  (if (&gt; (count (:id exp)) 0)
    (update-model!
     (assoc (dissoc exp :submit)
       :_id (deserialize-id (:id exp))
       :type &quot;study1-experiment&quot;))
    (create-model!
     (assoc (dissoc exp :submit)
       :type &quot;study1-experiment&quot;
       :owner (:username (session/current-user))
       :date (dt/as-utc (dt/now))))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn get-experiment [id]
  (fetch-model :study1-experiment {:_id (as-oid id)}))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn get-experiments
  ([]
     (get-experiments (session/current-user)))
  ([user]
     (let [name (if (string? user) user (:username user))]
       (fetch-models :study1-experiment {:owner name}))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn study1-complete?
  ([]
     (&gt;= (count (get-experiments)) 2))
  ([user]
     (&gt;= (count (get-experiments user)) 2)))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn study1-nav [current]
  (let [user (session/current-user)
        consented? (get-pref :study1-consented)]
    (merge (common/default-nav &quot;research&quot;)
           {:subnav
            {:menu
             (concat
              [{:name &quot;Overview&quot; :href &quot;/study1&quot;}
               {:name &quot;Study Protocol&quot; :href &quot;/study1/doc/study1-protocol&quot;}
               {:name &quot;Consent&quot; :href &quot;/study1/consent&quot;}
               {:name &quot;Online Q&amp;A&quot; :href &quot;/study1/discuss&quot;}]
              (when consented?
                [{:name &quot;Introduction&quot; :href &quot;/study1/doc/study1-background&quot;}
                 {:name &quot;Examples&quot; :href &quot;/study1/doc/study1-example&quot;}
                 {:name &quot;Author Study&quot; :href &quot;/study1/author&quot;}
                 {:name &quot;Review&quot; :href &quot;/study1/review&quot;}]))
             :active current}})))</pre></td></tr><tr><td class="docs"><h2>Study home page</h2>
</td><td class="codes"></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defpartial render-study-page []
  (common/layout
   [&quot;Authoring Research Study&quot;
    (study1-nav &quot;Overview&quot;)
    :deps [&quot;views/home&quot;]]
   [:div.container
    [:div.span8
     [:div.page-header
      [:h1 &quot;Welcome to the Authoring study&quot;]
      [:br]
      [:p &quot;This is the home page for a one-time research study about authoring experiments.  We are running this study to better understand how patients think about self-experimentation and figuring out how making changes impacts them.  If you would like to help, we will ask you to read some introductory material, research a specific treatment, and write down your &quot; [:b &quot;best guess&quot;] &quot; as to how an experiment should be constructed so you would have confidence if you ran the experiment you would be confident that it worked.&quot;]
      [:p &quot;We are not asking you to engage in any experimentation, but simply to write down how you think it should be done.  The best result for us is that you don't get everyong wrong nor everything right, but are somewhere in the middle. We're looking to understand what is easy and what is hard so we can build the best tools for non-specialists.&quot;]
      [:p (when (not (session/logged-in?))
            &quot;To participate, please &quot; [:a.register-button {:href &quot;#&quot;} &quot;register&quot;] &quot; for an account, login and then follow the procedures below.  &quot;) &quot;As you proceed through consenting to the study, the procedure list will be updated.&quot; ]
      (when (session/logged-in?)
        [:p &quot;To withdraw or have your account deleted, please send e-mail eslick@media.mit.edu&quot;])
      [:p &quot;If at any time you want help, go to our &quot; (link-to &quot;/study1/discuss&quot; &quot;Online Q&amp;A&quot;) &quot; page and ask your question.&quot;]]
     [:h2 &quot;Procedures&quot;]
     [:ol
      (if (session/logged-in?)
        (if (not (patient-consented?))
          (list [:li (link-to &quot;/study1/doc/study1-protocol&quot; &quot;Read: The Study Protocol&quot;)]
                [:li (link-to &quot;/study1/consent&quot; &quot;Consent to the study&quot;)])
          (list [:li &quot;Read: &quot; (link-to &quot;/study1/doc/study1-background&quot; &quot;Introduction to Single-Subject Experimentation&quot;)]
                [:li &quot;Read: &quot; (link-to &quot;/study1/doc/study1-example&quot; &quot;Example Experiments&quot;)]
                [:li &quot;Read: &quot; (link-to &quot;/study1/doc/study1-suggestions&quot; &quot;Treatments to Research&quot;)]
                [:li &quot;Do: &quot; (link-to &quot;/study1/author&quot; &quot;Author Experiments&quot;)]
                [:li &quot;Do: take the &quot; (link-to &quot;https://atrial.qualtrics.com/SE/?SID=SV_3l3Ix9bjgCxYpj6&quot; &quot;Exit Survey&quot;) &quot; (we request you complete at least 2 studies, but if you have significant problems, please fill out the survey anyway)&quot;]))
        (list [:li &quot;Preview the &quot; (link-to &quot;/study1/consent&quot; &quot;Study Consent Form&quot;)]
              [:li [:a.login-button {:href &quot;#loginModal&quot;} &quot;Login&quot;] &quot; or &quot; [:a.register-button {:href &quot;#regModal&quot;} &quot;Register&quot; &quot; to get an account.&quot;]]))]
     (when (and (patient-consented?) (not (empty? (get-experiments))))
       (list [:h2 &quot;Your Experiments&quot;]
             [:ul
              (map (fn [exp]
                     [:li (link-to (format &quot;/study1/author?id=%s&quot; (:_id exp))
                                   (:name exp))])
                   (get-experiments (session/current-user)))]))]]))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defpage &quot;/study1&quot; {}
  (render-study-page))</pre></td></tr><tr><td class="docs"><p>Information pages</p>
</td><td class="codes"></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defpage &quot;/study1/doc/:name&quot; {name :name}
  (let [article (get-article name)]
    (common/layout
     [(str &quot;Reading: &quot; (:title article))
      (study1-nav (case name
                    &quot;study1-protocol&quot; &quot;Study Protocol&quot;
                    &quot;study1-background&quot; &quot;Introduction&quot;
                    &quot;study1-example&quot; &quot;Examples&quot;
                    &quot;study1-suggestions&quot; &quot;Suggestions&quot;
                    true &quot;Author&quot;))]
     [:div.container
      [:div.span8
       (if article
         (list (when (is-admin?)
                 [:a.admin-link {:href (format &quot;/article/edit/%s&quot; name)}
                  &quot;Edit Article&quot;])
               [:div.page-header
                [:h1 (:title article)]]
               (:html article))
         [:div.page-header
          [:h1 &quot;No Article named '&quot; name &quot;' found&quot;]])]])))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defpartial render-consent-form []
  (form-to [:post &quot;/study1/consent&quot;]
           [:div.form-actions
            [:button {:type &quot;submit&quot; :class &quot;btn-large btn-success&quot;}
             &quot;YES, I consent to this research&quot;]
            [:button {:type &quot;submit&quot; :class &quot;btn-large btn-danger&quot;}
             &quot;NO, I do not consent&quot;]]))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defpartial render-consent []
  (let [consent (get-article &quot;study1-consent&quot;)]
    [:div.container
     [:div.span8
      [:div.page-header
       [:h1 (:title consent)]]
      (:html consent)
      (if (session/logged-in?)
        (if (patient-consented?)
          [:h2 &quot;You have consented to this study&quot;]
          (render-consent-form))
        [:h2
         &quot;You must click on register (top right of page) and then return and login to consent to this study&quot;])]]))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defpage &quot;/study1/consent&quot; {}
  (common/layout
   [&quot;Authoring Study Consent&quot;
    (study1-nav &quot;Consent&quot;)]
   (render-consent)))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defpage [:post &quot;/study1/consent&quot;] {}
  (let [req req/*request*]
    (consent-patient!)
    (resp/redirect &quot;/study1&quot;)))</pre></td></tr><tr><td class="docs"><p>Discussion page</p>
</td><td class="codes"></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defpage &quot;/study1/discuss&quot; {}
  (common/layout
   [&quot;Authoring Study Discussion&quot;
    (study1-nav &quot;Online Q&amp;A&quot;)]
   [:div.container
    [:div.page-header
     [:h1 &quot;Authoring Study Q&amp;A&quot;]]
    [:div.span8
     (discuss/discussions &quot;study1&quot; &quot;/study1/discuss&quot;)]]))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defpage [:post &quot;/study1/discuss&quot;]
  {pid :id text :text :as data}
  (if (comment/valid? text)
    (do
      (comment/comment! &quot;study1&quot; pid text)
      (render &quot;/study1/discuss&quot;))
    (do
      (discuss/with-submission data
        (render &quot;/study1/discuss&quot; data)))))</pre></td></tr><tr><td class="docs"><p>========================================</p>

<h1>Experiment Template</h1>
</td><td class="codes"></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defpage &quot;/study1/review&quot; {}
  (common/layout
   [&quot;Authored Experiments&quot;
    (study1-nav &quot;Author&quot;)]
   [:div.container
    [:h1 &quot;My Submitted Experiments&quot;]
    [:p &quot;It is perfectly acceptable during the duration of this experiment (through mid-June 2012) to revisit experiments you have submitted and make changes to them&quot;]
    [:ul (map (fn [exp] [:li [:a {:href (format &quot;/study1/author?id=%s&quot; (:_id exp))}
                              (:name exp)]])
              (get-experiments (session/current-user)))]]))</pre></td></tr><tr><td class="docs"><p>Study authoring page</p>
</td><td class="codes"></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn form-control-group [id name control &amp; [help]]
  [:div.control-group
   (label {:class &quot;control-label&quot;} id name)
   [:div.controls
    (when help [:p.help-block [:i help]])
    control]])</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defpartial experiment-form [experiment]
  (form-to [:post &quot;/study1/author&quot;]
           [:fieldset
            (form-control-group &quot;name&quot; &quot;Name&quot;
                                (text-field {:class &quot;input-xlarge&quot;}
                                            &quot;name&quot; (:name experiment))
                                &quot;Give your experiment a meaningful name&quot;)
            (form-control-group &quot;treatment&quot; &quot;Treatment&quot;
                                (text-area {:class &quot;input-xxlarge&quot; :rows 10}
                                           &quot;treatment&quot; (:treatment experiment))
                                &quot;Describe the treatment in as much detail as you can so that someone could reproduce all the important aspects of it&quot;)
            (form-control-group &quot;outcome&quot; &quot;Outcome&quot;
                                (text-area {:class &quot;input-xxlarge&quot; :rows 3}
                                           &quot;outcome&quot; (:outcome experiment))
                                &quot;What is the primary outcome you are interested in and how would you measure it?&quot;)
            (form-control-group &quot;measures&quot; &quot;Other Measures&quot;
                                (text-area {:class &quot;input-xxlarge&quot; :rows 6}
                                           &quot;measures&quot; (:measures experiment))
                                &quot;Please list, separated by commas, other measurements you think might be relevant to this experiment&quot;)
            (form-control-group &quot;schedule&quot; &quot;Experiment Schedule&quot;
                                (text-area {:class &quot;input-xxlarge&quot; :rows 6}
                                           &quot;schedule&quot; (:schedule experiment))
                                &quot;How long should someone do a treatment?  How many times should they repeat? &lt;br/&gt; How long should the baseline collection period be?  How long does it take for someone to respond to a treatment?&quot;)
            (form-control-group &quot;predictors&quot; &quot;Predictors&quot;
                                (text-area {:class &quot;input-xxlarge&quot; :rows 6}
                                           &quot;predictors&quot; (:predictors experiment))
                                &quot;Based on your research, what symptoms or patient history (if any) is likely to be associated with a successful response to a treatment. &lt;br/&gt;  You can specify this as formally or as causally as you want.&quot;)
            (form-control-group &quot;notes&quot; &quot;Notes/Comments&quot;
                                (text-area {:class &quot;input-xxlarge&quot; :rows 6}
                                           &quot;notes&quot; (:notes experiment)))
            (hidden-field &quot;id&quot; (str (:_id experiment)))
            [:div.form-actions
             [:button.btn.btn-primary {:type &quot;submit&quot; :name &quot;submit&quot;} &quot;Save Experiment&quot;]
             [:button.btn {:type &quot;submit&quot; :name &quot;cancel&quot;} &quot;Cancel&quot;]]]))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defpartial experiment-thank-you [name]
  [:h1 &quot;Submission Successful&quot;]
  [:p &quot;Thank you for submitting the experiment '&quot; name
   &quot;'.  We encourage you to research more possible treatments and provide additional submissions.&quot;])</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defpage &quot;/study1/author&quot; {:as options}
  (common/layout
   [&quot;Author an Experiment&quot;
    (study1-nav &quot;Author&quot;)
    :deps []]
   [:div.container
    [:div.study1-author
     [:div.page-header
      [:h1 &quot;Author an Experiment&quot;]
      [:br]
      [:p &quot;Here we ask you to describe all the essential elements of an experiment designed to test one or more treatments.  Read the introductory material, look at an example experiment, and review the questions on the Q&amp;A page for more information.  The &lt;a href=\&quot;/study1/doc/study1-suggestions\&quot;&gt;treatment suggestion page&lt;/a&gt; gives you two specific treatments to write about and how to find information about them&quot;]
      [:p &quot;Please be as precise as you can, acting as if you were actually going to run this experiment.  There are no wrong answers.  If you aren't sure about something and can't get what you want from the Q&amp;A section, then write down what is hard or confusing after making your best guess.  The goal is to learn how you react to the material and think about experimentation so we can make the process easier for non-experts.&quot;]]
     (experiment-form
      (if-let [id (:id options)]
        (get-experiment id)
        {}))]]))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defpage author-view [:get &quot;/study1/author-view&quot;] {:as options}
  (let [exp (get-experiment (:id options))]
    (common/layout
     [&quot;View a Study&quot;
      (study1-nav )]
     [:div.span8
      [:div.study1-author
       (if (not exp)
         [:h1 &quot;Experiment not found&quot;]
         (list [:h2 &quot;Example: &quot; (:name exp)]
               [:dl.dl-horizontal
                [:dt &quot;Treatment&quot;]
                [:dd (markdown/md (or (:treatment exp) ))]
                [:dt &quot;Outcome&quot;]
                [:dd (markdown/md (or (:outcome exp) ))]
                [:dt &quot;Measures&quot;]
                [:dd (markdown/md (or (:measures exp) ))]
                [:dt &quot;Schedule&quot;]
                [:dd (markdown/md (or (:schedule exp) ))]
                [:dt &quot;Predictors&quot;]
                [:dd (markdown/md (or (:predictors exp) ))]
                [:dt &quot;Notes&quot;]
                [:dd (markdown/md (or (:notes exp) ))]]))]])))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn experiment-valid? [spec]
  true)</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defpage [:post &quot;/study1/author&quot;] {:as spec}
  (common/layout
   [&quot;Thank you&quot;
    (study1-nav &quot;Author&quot;)]
   [:div.container
    (if (and (:submit spec) (experiment-valid? spec))
      (do
        (record-experiment spec)
        (experiment-thank-you (:name spec)))
      (render &quot;/study1/author&quot;))]))</pre></td></tr><tr><td class="spacer docs">&nbsp;</td><td class="codes" /></tr><tr><td class="docs"><div class="docs-header"><a class="anchor" href="#experiment.views.study2" name="experiment.views.study2"><h1 class="project-name">experiment.views.study2</h1><a class="toc-link" href="#toc">toc</a></a></div></td><td class="codes" /></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(ns experiment.views.study2
  (:use noir.core
        hiccup.core
        hiccup.page-helpers
	hiccup.form-helpers
	experiment.infra.models
	experiment.models.user
        experiment.models.article
        experiment.views.discuss)
  (:require
   [clojure.tools.logging :as log]
   [clojure.string :as str]
   [somnium.congomongo :as mongo]
   [clodown.core :as markdown]
   [noir.response :as resp]
   [noir.request :as req]
   [noir.util.crypt :as crypt]
   [noir.validation :as vali]
   [experiment.infra.session :as session]
   [experiment.views.common :as common]
   [experiment.models.comment :as comment]
   [experiment.views.discuss :as discuss]
   [experiment.infra.auth :as auth]
   [experiment.libs.datetime :as dt]))</pre></td></tr><tr><td class="docs"><h2>Aggregating Self-Experiments Study Page</h2>
</td><td class="codes"></td></tr><tr><td class="docs"><h2>Utilities</h2>
</td><td class="codes"></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn consent-patient! []
  (set-pref! :study2-consented true))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn patient-consented? []
  (get-pref :study2-consented))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn record-experiment [exp]
  (if (&gt; (count (:id exp)) 0)
    (update-model!
     (assoc (dissoc exp :submit)
       :_id (deserialize-id (:id exp))
       :type &quot;study2-experiment&quot;))
    (create-model!
     (assoc (dissoc exp :submit)
       :type &quot;study2-experiment&quot;
       :owner (:username (session/current-user))
       :date (dt/as-utc (dt/now))))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn get-experiment [id]
  (fetch-model :study2-experiment {:_id (as-oid id)}))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn get-experiments
  ([]
     (get-experiments (session/current-user)))
  ([user]
     (let [name (if (string? user) user (:username user))]
       (fetch-models :study2-experiment {:owner name}))))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn study2-complete?
  ([]
     (&gt;= (count (get-experiments)) 2))
  ([user]
     (&gt;= (count (get-experiments user)) 2)))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn study2-nav [current]
  (let [user (session/current-user)
        consented? (get-pref :study2-consented)]
    (merge (common/default-nav &quot;research&quot;)
           {:subnav
            {:menu
             (concat
              [{:name &quot;Overview&quot; :href &quot;/study2&quot;}
               {:name &quot;Study Protocol&quot; :href &quot;/study2/doc/study2-protocol&quot;}
               {:name &quot;Consent&quot; :href &quot;/study2/consent&quot;}
               {:name &quot;Online Q&amp;A&quot; :href &quot;/study2/discuss&quot;}]
              (when consented?
                [{:name &quot;Introduction&quot; :href &quot;/study2/doc/study2-background&quot;}
                 {:name &quot;Examples&quot; :href &quot;/study2/doc/study2-example&quot;}
                 {:name &quot;Author Study&quot; :href &quot;/study2/author&quot;}]))
             :active current}})))</pre></td></tr><tr><td class="docs"><h2>Study home page</h2>
</td><td class="codes"></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defpartial render-study-page []
  (common/layout
   [&quot;Aggregating Self-Experiments Study&quot;
    (study2-nav &quot;Overview&quot;)
    :deps [&quot;views/home&quot;]]
   [:div.container
    [:div.span8
     [:div.page-header
      [:h1 &quot;Self-Experiments for Psoriasis&quot;]
      [:br]
      [:p &quot;This page introduces and guides you through one of two different studies
           that will help you determine whether a specific treatment is helpful for you.
           Participating in this study will help us understand more about these treatments,
           and more about how this site can be improved to support more studies like these.&quot;]
      [:p &quot;If you would like to participate, we will ask you to read some introductory material,
           consent to the study&quot;]
      [:p &quot;We are not asking you to engage in any experimentation, but simply to write down how you think it should be done.  The best result for us is that you don't get everyong wrong nor everything right, but are somewhere in the middle. We're looking to understand what is easy and what is hard so we can build the best tools for non-specialists.&quot;]
      [:p (when (not (session/logged-in?))
            &quot;To participate, please &quot; [:a.register-button {:href &quot;#&quot;} &quot;register&quot;] &quot; for an account, login and then follow the procedures below.  &quot;) &quot;As you proceed through consenting to the study, the procedure list will be updated.&quot; ]
      (when (session/logged-in?)
        [:p &quot;To withdraw or have your account deleted, please send e-mail eslick@media.mit.edu&quot;])
      [:p &quot;If at any time you want help, go to our &quot; (link-to &quot;/study2/discuss&quot; &quot;Online Q&amp;A&quot;) &quot; page and ask your question.&quot;]]
     [:h2 &quot;Procedures&quot;]
     [:ol
      (if (session/logged-in?)
        (if (not (patient-consented?))
          (list [:li (link-to &quot;/study2/doc/study2-protocol&quot; &quot;Read: The Study Protocol&quot;)]
                [:li (link-to &quot;/study2/consent&quot; &quot;Consent to the study&quot;)])
          (list [:li &quot;Read: &quot; (link-to &quot;/study2/doc/study2-background&quot; &quot;Introduction to Single-Subject Experimentation&quot;)]
                [:li &quot;Read: &quot; (link-to &quot;/study2/doc/study2-example&quot; &quot;Example Experiments&quot;)]
                [:li &quot;Read: &quot; (link-to &quot;/study2/doc/study2-suggestions&quot; &quot;Treatments to Research&quot;)]
                [:li &quot;Do: &quot; (link-to &quot;/study2/author&quot; &quot;Author Experiments&quot;)]
                [:li &quot;Do: take the &quot; (link-to &quot;https://atrial.qualtrics.com/SE/?SID=SV_3l3Ix9bjgCxYpj6&quot; &quot;Exit Survey&quot;) &quot; (we request you complete at least 2 studies, but if you have significant problems, please fill out the survey anyway)&quot;]))
        (list [:li &quot;Preview the &quot; (link-to &quot;/study2/consent&quot; &quot;Study Consent Form&quot;)]
              [:li [:a.login-button {:href &quot;#loginModal&quot;} &quot;Login&quot;] &quot; or &quot; [:a.register-button {:href &quot;#regModal&quot;} &quot;Register&quot; &quot; to get an account.&quot;]]))]
     (when (and (patient-consented?) (not (empty? (get-experiments))))
       (list [:h2 &quot;Your Experiments&quot;]
             [:ul
              (map (fn [exp]
                     [:li (link-to (format &quot;/study2/author?id=%s&quot; (:_id exp))
                                   (:name exp))])
                   (get-experiments (session/current-user)))]))]]))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defpage &quot;/study2&quot; {}
  (render-study-page))</pre></td></tr><tr><td class="docs"><p>Information pages</p>
</td><td class="codes"></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defpage &quot;/study2/doc/:name&quot; {name :name}
  (let [article (get-article name)]
    (common/layout
     [(str &quot;Reading: &quot; (:title article))
      (study2-nav (case name
                    &quot;study2-protocol&quot; &quot;Study Protocol&quot;
                    &quot;study2-background&quot; &quot;Introduction&quot;
                    &quot;study2-example&quot; &quot;Examples&quot;
                    &quot;study2-suggestions&quot; &quot;Suggestions&quot;
                    true &quot;Author&quot;))]
     [:div.container
      [:div.span8
       (if article
         (list (when (is-admin?)
                 [:a.admin-link {:href (format &quot;/article/edit/%s&quot; name)}
                  &quot;Edit Article&quot;])
               [:div.page-header
                [:h1 (:title article)]]
               (:html article))
         [:div.page-header
          [:h1 &quot;No Article named '&quot; name &quot;' found&quot;]])]])))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defpartial render-consent-form []
  (form-to [:post &quot;/study2/consent&quot;]
           [:div.form-actions
            [:button {:type &quot;submit&quot; :class &quot;btn-large btn-success&quot;}
             &quot;YES, I consent to this research&quot;]
            [:button {:type &quot;submit&quot; :class &quot;btn-large btn-danger&quot;}
             &quot;NO, I do not consent&quot;]]))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defpartial render-consent []
  (let [consent (get-article &quot;study2-consent&quot;)]
    [:div.container
     [:div.span8
      [:div.page-header
       [:h1 (:title consent)]]
      (:html consent)
      (if (session/logged-in?)
        (if (patient-consented?)
          [:h2 &quot;You have consented to this study&quot;]
          (render-consent-form))
        [:h2 &quot;You must register and login to consent to this study&quot;])]]))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defpage &quot;/study2/consent&quot; {}
  (common/layout
   [&quot;Self-Experiments Consent&quot;
    (study2-nav &quot;Consent&quot;)]
   (render-consent)))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defpage [:post &quot;/study2/consent&quot;] {}
  (let [req req/*request*]
    (consent-patient!)
    (resp/redirect &quot;/study2/select&quot;)))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defpartial render-select-page []
  [:div.container
   [:h1 &quot;Select Page&quot;]])</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defpage [:get &quot;/study2/select&quot;] {}
  (common/layout
   [&quot;Select your Experiment&quot;
    (study2-nav &quot;Consent&quot;)]
   (render-select-page)))</pre></td></tr><tr><td class="docs"><p>Discussion page</p>
</td><td class="codes"></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defpage &quot;/study2/discuss&quot; {}
  (common/layout
   [&quot;Aggregating Self-Experiments Discussion&quot;
    (study2-nav &quot;Online Q&amp;A&quot;)]
   [:div.container
    [:div.page-header
     [:h1 &quot;Aggregating Self-Experiments Study Q&amp;A&quot;]]
    [:div.span8
     (discuss/discussions &quot;study2&quot; &quot;/study2/discuss&quot;)]]))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defpage [:post &quot;/study2/discuss&quot;]
  {pid :id text :text :as data}
  (if (comment/valid? text)
    (do
      (comment/comment! &quot;study2&quot; pid text)
      (render &quot;/study2/discuss&quot;))
    (do
      (discuss/with-submission data
        (render &quot;/study2/discuss&quot; data)))))</pre></td></tr><tr><td class="spacer docs">&nbsp;</td><td class="codes" /></tr><tr><td class="docs"><div class="docs-header"><a class="anchor" href="#experiment.views.templates" name="experiment.views.templates"><h1 class="project-name">experiment.views.templates</h1><a class="toc-link" href="#toc">toc</a></a></div></td><td class="codes" /></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(ns experiment.views.templates
  (:use
   experiment.infra.models
   noir.core
   hiccup.core
   hiccup.page-helpers
   hiccup.form-helpers
   handlebars.templates)
  (:require
   [noir.response :as response]
   [experiment.views.bootstrap :as boot]))</pre></td></tr><tr><td class="docs"><h1>Dynamic Template Loader API endpoint</h1>
</td><td class="codes"></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defpage load-template [:get &quot;/api/templates/:id&quot;]
  {:keys [id]}
  (response/content-type
   &quot;text/html&quot;
   (html-template
    (get-template id))))</pre></td></tr><tr><td class="docs"><p>Template Views for System Objects</p>
</td><td class="codes"></td></tr><tr><td class="docs"><h1>Breadcrumbs</h1>
</td><td class="codes"></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(deftemplate breadcrumbs-view
  [:ul.breadcrumb
   (%each path
          [:li {:class (% class)}
           [:a {:href (% url)} (% name)]
           [:span.divider &quot;/&quot;]])
   (%with tail
          [:li {:class &quot;active&quot;}
           [:a {:href (% url)} (% name)]])])</pre></td></tr><tr><td class="docs"><h1>Pagination</h1>
</td><td class="codes"></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(deftemplate pagination-view
  [:ul
   (%each this
          [:li {:class (% class)} [:a {:href &quot;#&quot;} (% text)]])])</pre></td></tr><tr><td class="docs"><h1>Scheduling</h1>
</td><td class="codes"></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(deftemplate scheduler-view
  [:div
   [:div.page-header
    [:h1 &quot;Configure Instrument Tracker&quot;]]
   [:ul#schedTab.nav.nav-tabs
    (%if daily [:li [:a {:href &quot;#daily&quot;} &quot;Daily&quot;]])
    (%if weekly [:li [:a {:href &quot;#weekly&quot;} &quot;Weekly&quot;]])
    (%if periodic [:li [:a {:href &quot;#periodic&quot;} &quot;Periodic&quot;]])]
   [:div.tab-content.well
    [:div#daily.tab-pane]
    [:div#weekly.tab-pane]
    [:div#periodic.tab-pane]]
   [:div.controls
    [:button.btn.btn-primary.accept &quot;Configure&quot;]
    [:button.btn.cancel &quot;Cancel&quot;]]])</pre></td></tr><tr><td class="docs"><h1>Instrument Templates</h1>
</td><td class="codes"></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(deftemplate journal-page
  [:div.row.journal-page
   [:div.span7.jvl]
   [:div.span5.jvp]])</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(deftemplate journal-view
  [:div.well
   [:div.journal-header
    [:span.pull-left
     [:p {:style &quot;text-align: center;&quot;} (% date-str)]]
    [:span.pull-right
     [:span#purpose.btn-group
      [:a.btn.btn-mini.dropdown-toggle
       {:data-toggle &quot;dropdown&quot;
        :href &quot;#&quot; 
        :style &quot;margin-right: 10px;&quot;}
       (% annotation) &quot; &quot; [:span.caret]]
      [:ul.dropdown-menu
       [:li [:a.option {:href &quot;#&quot;} &quot;Note&quot;]]
       [:li [:a.option {:href &quot;#&quot;} &quot;Change&quot;]]
       [:li [:a.option {:href &quot;#&quot;} &quot;Adverse&quot;]]]]
     &quot;&amp;nbsp;&quot;
     [:span#sharing.btn-group
      [:a.btn.btn-mini.dropdown-toggle
       {:data-toggle &quot;dropdown&quot;
        :href &quot;#&quot; 
        :style &quot;margin-right: 10px;&quot;}
       (% sharing) &quot; &quot; [:span.caret]]
      [:ul.dropdown-menu
       [:li [:a.option {:href &quot;#&quot;} &quot;Private&quot;]]
       [:li [:a.option {:href &quot;#&quot;} &quot;Friends&quot;]]
       [:li [:a.option {:href &quot;#&quot;} &quot;Public&quot;]]]]]
    [:div.clear]]
   [:form {:style &quot;clear: both;&quot;}
    [:hr]
    (boot/ctrl-group
     [&quot;Tagline&quot; &quot;short&quot;]
     (boot/input {:id &quot;journal-short&quot; :maxlength &quot;40&quot;} &quot;text&quot; &quot;short&quot; (% short)))
    (boot/ctrl-group
     [&quot;Long Entry&quot; &quot;content&quot;]
     (boot/textarea {:rows &quot;15&quot;
                     :cols &quot;80&quot;
                     :class &quot;input-xlarge&quot;
                     :id &quot;journal-content&quot;
                     :style &quot;resize: none;&quot;}
                    &quot;content&quot;
                    (% content)))]])</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(deftemplate journal-list
  [:div
   [:span [:h2.pull-left &quot;Journal Entries&quot;]
    [:span.pull-right [:button.btn.btn-primary.new &quot;New Entry&quot;]]]
   [:table.table
    [:thead
     [:tr
      [:th &quot;Date&quot;]
      [:th &quot;Description&quot;]
      [:th &quot;Type&quot;]
      [:th &quot;Sharing&quot;]]]
    [:tbody
     (%each journals
            [:tr {:data (% id)}
             [:td.time
              (% date-str)]
             [:td.short
              (% short)]
             [:td.anno
              (% annotation)]
             [:td.sharing
              (% sharing)]
             [:td.del
              [:button.btn.btn-mini.btn-danger.del
               [:i.icon-remove.icon-white]]]
             ])]]])</pre></td></tr><tr><td class="docs"><p>Dashboard Overview Page</p>
</td><td class="codes"></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(deftemplate overview-page
  [:div 
   [:div.row
    [:div#summary-pane.span12]]
   [:div.row
    [:div#calendar-pane.span4]
    [:div#feeds-pane.span4 [:p &quot; &quot;]]
    [:div#journal-pane.span4]]])</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(deftemplate dashboard-help
  [:div.help-pane
;;   [:h3 {:style &quot;text-align: center;&quot;} &quot;Help&quot;]
   [:p &quot;This page contains a summary of your activity.  What can you do?&quot;]
   [:dl
    [:dt &quot;Select a trial&quot;]
    [:dd &quot;You can select between more than one trial by clicking on the arrows in the upper right corner under 'Select Trial'.&quot;]
    [:dt &quot;Pause a trial&quot;]
    [:dd &quot;If you are busy, you can pause the trial
        temporarily which will stop all data collection and pause the analysis.
        If you pause for more than a few days, you may have to repeat.&quot;]]])</pre></td></tr><tr><td class="docs"><p>Related Objects List</p>
</td><td class="codes"></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(deftemplate related-objects
  [:div.related-objects
   [:table.table
    [:thead
     [:th
      [:td &quot;Type&quot;]
      [:td &quot;Name&quot;]]]
    [:tbody
     (%each this
            [:tr
             [:td (% type)]
             [:td (% name)]])]]])</pre></td></tr><tr><td class="docs"><p>TIMELINE</p>
</td><td class="codes"></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(deftemplate timeline-header
  [:div#timeline-header {:style &quot;height: 60px;&quot;}
   [:div.page-header
    [:span {:style &quot;display: inline;&quot;}
     [:h1.pull-left &quot;Timeline&quot;]
     [:div.pull-right.btn-group
       [:a.btn.dropdown-toggle {:data-toggle &quot;dropdown&quot; :href &quot;#&quot;}
        &quot;Show/Hide &quot;
        [:span.caret]]
      [:ul.dropdown-menu]]
     [:div.pull-right {:style &quot;padding-left: 10px;&quot;} [:p] ]
     [:div.pull-right 
      [:input {:type &quot;text&quot; :name &quot;timelinerange&quot; :value (% range) :id &quot;timelinerange&quot;}]]]
    [:div {:style &quot;clear:both;&quot;}]]])</pre></td></tr><tr><td class="docs"><p>EVENT LOG</p>
</td><td class="codes"></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(deftemplate event-log
  [:div
   [:div.page-header
    [:div
     [:h1.pull-left &quot;Event Log&quot;]
     [:span.pull-right {:style &quot;display: inline;&quot;}
      [:input {:type &quot;text&quot; :name &quot;eventrange&quot; :value (% range) :id &quot;eventrange&quot;}]]
     [:div {:style &quot;clear: both;&quot;}]]]
   [:div.row
    [:div#eventlist.span7]
    [:div#eventother.span5 [:p]]]])</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(deftemplate event-view
  [:div.event-view
   (%if editable
        [:div {:style &quot;float: right;&quot;}
         [:a.edit-event {:href &quot;#&quot;}
          [:i.icon-edit]]])
   [:div
    (%if success [:i.icon-ok])
    (%if fail [:i.icon-remove])
    (%if instrument
         (%with instrument
                [:b (% variable) &quot; (&quot; (% service) &quot;)&quot;
                 [:a.view-timeline {:href &quot;#&quot;}
                  [:i.icon-eye-open]]]))
    (%unless instrument
             [:b &quot;Treatment Reminder&quot; [:i.icon-comment]])]
   [:div (% local-time) &quot;:&amp;nbsp;&quot; (% message)] ;; (% status) &quot; &quot; 
   (%if result-val
        [:div.response (% result-time) &quot;:&amp;nbsp;&quot; [:b &quot;Response: '&quot;] (% result-val) &quot;'&quot;])
   (%if error [:div.error (% error)])])</pre></td></tr><tr><td class="docs"><p>TRIAL</p>
</td><td class="codes"></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(deftemplate trial-view-frame
  [:div.well
   [:div#trial-pane-wrapper
    (%if empty
         [:h1.centered &quot;No Active Trials&quot;])]
   [:p]])</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defelem render-decorated-button [name &amp; [icon-class]]
  [:a {:href &quot;#&quot;}
   [:button.btn.btn-small 
    [:i {:class (or icon-class )}] name]])</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(deftemplate trial-view-header
  [:div.trial-header
   [:div.trial-title-bar 
    [:div.pull-left {:style &quot;padding-bottom: 12px;&quot;}
     [:h3 &quot; Trial: &quot; (% experiment.title)]]
    [:div.pull-right {:style &quot;padding-bottom: 12px;&quot;}
     [:div.trial-nav-note {:style &quot;margin-top: -10px; font-size: tiny; text-align: center;&quot;}
      &quot;Select Trial&quot;]
     [:div.btn-group
      [:button.btn.btn-mini.prev [:i.icon-chevron-left]]
      [:button.btn.btn-mini.next [:i.icon-chevron-right]]]]]
   [:div.trial-info-bar.clear-both 
    [:div.pull-left.trial-stats
     [:p [:b &quot;Started: &quot;]
      [:span.label.label-info (% start_str)]]
     (%unless donep
              [:p [:b &quot;Current status: &quot;]
               (%unless pausedp [:span.label.label-success (% status_str)])
               (%if pausedp [:span.label.label-warning (% status_str)])])
     (%if donep
          [:p [:b &quot;Ended: &quot;]
           [:span.label.label-fail (% end_str)]])]
    [:div.pull-right.trial-actions.btn-group
     (%unless pausedp
              (render-decorated-button
               {:class &quot;pause&quot; :rel &quot;tooltip&quot; :title &quot;Pause the trial&quot;}
               &quot;Pause&quot; &quot;icon-pause&quot;))
     (%if pausedp
          (render-decorated-button
           {:class &quot;resume&quot; :rel &quot;tooltip&quot; :title &quot;Resume the trial&quot;}
           &quot;Resume&quot; &quot;icon-play&quot;))
     (%unless donep
              (render-decorated-button
               {:class &quot;cancel&quot; :rel &quot;tooltip&quot; :title &quot;Terminate the trial&quot;}
               &quot;Cancel&quot; &quot;icon-stop&quot;))
     (%if donep
          (render-decorated-button
           {:class &quot;archive&quot; :rel &quot;tooltip&quot; :title &quot;Archive the Trial&quot;}
           &quot;Archive&quot; &quot;icon-eject&quot;))]]
    [:hr.clear-both]])</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(deftemplate trial-table
  [:div.trial-table
   [:h2.trial-table-header]
   [:ul.trial-table-list
    (%each trials
	   [:li.trial-table-list-entry
	    [:span.trial-title (% experiment.title)]
	    [:p (%with stats
		       (%str &quot;Run for &quot; (% elapsed) &quot; days with &quot; (% remaining) &quot; days remaining&quot;))]])]])</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(deftemplate configure-trial-view
  [:div.configure-trial
   [:div.row
    [:div.page-header
     [:div.span7
      [:h1 &quot;Configuring new trial&quot;]]
     [:div.span4]
     [:div {:style &quot;clear:both;&quot;}]]]
   [:div.row
    [:div.span12
     [:div
      (%with experiment
             (%with treatment
                    [:h3 &quot;For treatment: &quot; (% name)]))]
     [:div#configureForm]
     [:div#configureTrackers]
     [:hr]]]
   [:div.row
    [:div.span3 [:p]]
    [:div.span5
     [:button.btn.btn-large.btn-success.accept.pull-left
      {:type &quot;button&quot;} &quot;Create&quot;]
     [:button.btn.btn-large.btn-danger.cancel.pull-right
      {:type &quot;button&quot;} &quot;Cancel&quot;]]]])</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn tag-list []
  [:div.tags
   (%each tags
    [:span.label.label-info (% this)] &quot;&amp;nbsp;&quot;)])</pre></td></tr><tr><td class="docs"><p>TREATMENT</p>
</td><td class="codes"></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(deftemplate treatment-list-view
  [:div.result.treatment-list-view
   [:h3 [:a.title {:href &quot;#&quot; :data-id (% id)} ;; (%str &quot;/explore/view/&quot; (% type) &quot;/&quot; (% id)) }
         [:i.icon-play] &quot; &quot; (% name)]]
   [:p (% description)]
   [:div.tags
    (%each tags
           [:span.label.label-info (% this)] &quot;&amp;nbsp;&quot;)]])</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(deftemplate treatment-row-view
  [:tr [:td [:a.title {:href &quot;#&quot; :data-id (% id) :data-type (% type)}
             [:i.icon-play] &quot; &quot; (% name)]]])</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(deftemplate treatment-view
  [:div.treatment-view.object-view
   [:div.row
    [:div.page-header
     [:div.span7
      [:h1 (% name)]]
     [:div.span4
      [:span.pull-right
       [:button.btn.btn-large.btn-primary.experiment {:type &quot;button&quot;} &quot;Create Experiment&quot;]
       (%if owner [:button.btn.btn-large.edit {:type &quot;button&quot;} &quot;Edit&quot;])
       [:button.btn.btn-large.clone {:type &quot;button&quot;} &quot;Clone&quot;]]]
     [:div {:style &quot;clear:both;&quot;}]]]
   [:div.row
    [:div.span5
     [:h3 &quot;Protocol&quot;]
     [:p (%code description-html)]
     [:p [:b &quot;Behavior&quot;]]
     [:p
      [:span &quot;Onset period of &quot; (% dynamics.onset) &quot; days, &amp;nbsp;&quot;]
      [:span &quot;Washout period of &quot; (% dynamics.washout) &quot; days&quot;]]
     [:p [:b &quot;Tags &quot;]
      [:a.add-tag {:href &quot;#&quot;} [:i.icon-plus-sign]]]
     [:p.tags
      (%each tags
             [:span.label.label-info (% this)] &quot;&amp;nbsp;&quot;)]
     [:div#discuss]]
    [:div.span1 [:p]]
    [:div.span6
     ;; Related, Discussion
     [:div#related]]
;;     [:div.row.conversations [:h2 &quot;Conversations&quot;]]
     ]])</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(deftemplate treatment-editor
  [:div.treatment-edit.object-editor
   [:div.row
    [:div.page-header
     [:div.span7
      (%if name [:h1 &quot;Editing &quot; (% name)])
      (%unless name [:h1 &quot;Create a new Treatment&quot;])]
     [:div.span4]
     [:div {:style &quot;clear:both&quot;}]]]
   [:div.row
    [:div.span12
     [:div#editForm]]]
   [:div.row
    [:div.span3 [:p]]
    [:div.span5
     [:button.btn.btn-large.btn-success.accept.pull-left
      {:type &quot;button&quot;}
      (%if name &quot;Update&quot;)
      (%unless name &quot;Create&quot;)]
     [:button.btn.btn-large.btn-danger.cancel.pull-right
      {:type &quot;button&quot;} &quot;Cancel&quot;]]]])</pre></td></tr><tr><td class="docs"><p>INSTRUMENT</p>
</td><td class="codes"></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(deftemplate instrument-list-view
  [:div.result.instrument-list-view
   [:h3 [:a.title {:href &quot;#&quot; :data-id (% id) :data-type (% type)} ;; (%str &quot;/explore/view/&quot; (% type) &quot;/&quot; (% id)) }
         [:i.icon-eye-open {:style &quot;vertical-align:middle&quot;}] &quot; &quot; (% variable) &quot; (&quot; (% service) &quot;)&quot;]]
   [:p (% description)]
   [:p.tags
    (%each tags
      [:span.label.label-info (% this)] &quot;&amp;nbsp;&quot;)]])</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(deftemplate instrument-short-table
  [:div {:class &quot;instrument-short-table&quot;}
   [:ul
    (%each instruments
	   [:li
	    [:a {:href (%strcat &quot;/app/search/instrument/&quot; (% id))}
	     [:span {:class &quot;variable&quot;} (% name)]
	     [:span {:class &quot;type&quot;} (% service)]]])
    ]])</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(deftemplate instrument-row-view
  [:tr [:td [:a.title {:href &quot;#&quot; :data-id (% id) :data-type (% type)}
             [:i.icon-eye-open] &quot; &quot; (% variable) &quot; -- &quot; (% service)]]])</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(deftemplate instrument-view
  [:div.instrument-view
   [:div.row
    [:div.page-header
     [:div.span8
      [:h1 (%if tracked [:a {:href &quot;/dashboard/timeline&quot;} (% variable)])
           (%unless tracked (% variable))
       &quot; -- &quot; [:a {:href &quot;/account/services&quot;} (% service)]]]
     [:div.span3
      [:span.pull-right
       (%if owner [:button.btn.btn-large.edit &quot;Edit&quot;])
       (%if tracked [:button.btn.btn-large.untrack &quot;Untrack&quot;])
       (%unless tracked [:button.btn.btn-large.track &quot;Track&quot;])]]
     [:div {:style &quot;clear:both;&quot;}]]]
   [:div.row
    [:div.span5
     [:h3 &quot;Description&quot;]
     [:p (%code description-html)]
     [:p [:b &quot;Tags &quot;]
      [:a.add-tag {:href &quot;#&quot;} [:i.icon-plus-sign]]]
     [:p.tags
      (%each tags
             [:span.label.label-info (% this)] &quot;&amp;nbsp;&quot;)]]
    [:div.span1 [:p]]
    [:div.span6
     ;; Related, Discussion
     [:div#related]
     ]]])</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(deftemplate instrument-editor
  [:div.instrument-edit.object-editor
   [:div.row
    [:div.page-header
     [:div.span7
      [:h1 &quot;Editing &quot; (% variable) &quot; -- &quot; (% service)]]
     [:div.span4]
     [:div {:style &quot;clear:both&quot;}]]]
   [:div.row
    [:div.span12
     [:div#editForm]]]
   [:div.row
    [:div.span3 [:p]]
    [:div.span5
     [:button.btn.btn-large.btn-success.accept.pull-left
      {:type &quot;button&quot;} &quot;Update&quot;]
     [:button.btn.btn-large.btn-danger.cancel.pull-right
      {:type &quot;button&quot;} &quot;Cancel&quot;]]]])</pre></td></tr><tr><td class="docs"><p>EXPERIMENT</p>
</td><td class="codes"></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(deftemplate experiment-list-view
  [:div.result.experiment-list-view
   [:h3 [:a.title {:href &quot;#&quot; :data-id (% id)} ;; (%str &quot;/explore/view/&quot; (% type) &quot;/&quot; (% id)) }
        [:i.icon-random] &quot; &quot; (% treatment.name)]]
   [:p (% title)]
   [:ul
    (%each instruments
           [:li (% variable) &quot;(measured by &quot; (% service) &quot;)&quot;])]])</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(deftemplate experiment-row-view
  [:tr [:td [:a.title {:href &quot;#&quot; :data-id (% id)}
             [:i.icon-random] &quot; &quot; (% title)]]])</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(deftemplate experiment-view
  [:div.experiment-view
   [:div.row
    [:div.page-header
     [:div.span8
      [:h1 {:href }
       (% title)]]
     [:div.span3
      [:span.pull-right
       [:button.btn.btn-primary.btn-large.run {:type &quot;button&quot;} &quot;Start Trial&quot;]
       (%if owner [:button.btn.btn-large.edit {:type &quot;button&quot;} &quot;Edit&quot;])
       [:button.btn.btn-large.clone {:type &quot;button&quot;} &quot;Clone&quot;]]]
     [:div {:style &quot;clear:both;&quot;}]]]
   [:div.row
    [:div.span5
     (%with treatment
            [:h3 &quot;Protocol&quot;]
            [:p &quot;&amp;nbsp; from: &quot; [:a.view {:href &quot;#&quot; :data-id (% id)} (% name)]]
            [:p (%code description-html)])
     [:p [:b &quot;Outcome Measure&quot;]]
     (%each outcome
            [:p [:a.view {:href &quot;#&quot; :data-id (% id)} (% variable) &quot; -- &quot; (% service)]
             &quot;&amp;nbsp;&quot;
             [:a.timeline {:href &quot;/dashboard/timeline&quot; :data-id (% id)}
              [:i.icon-eye-open]]])
     [:p [:b &quot;Other Measures&quot;]]
     (%each covariates 
            [:p [:a.view {:href &quot;#&quot; :data-id (% id)} (% variable) &quot; -- &quot; (% service)]
             &quot;&amp;nbsp;&quot;
             [:a.timeline {:href &quot;/dashboard/timeline&quot; :data-id (% id)}
              [:i.icon-eye-open]]])
     [:p [:b &quot;Tags: &quot;] [:a.add-tag {:href &quot;#&quot;} [:i.icon-plus-sign]]]
     [:p.tags
      (%each tags
             [:span.label.label-info (% this)] &quot;&amp;nbsp;&quot;)]]
    [:div.span1 [:p]]
    [:div.span6
     [:div#related]
     [:div#trials]]]
   [:div.row
    [:div#discuss.span12]]])</pre></td></tr><tr><td class="docs"><p>  [:h2 "Schedule"]
  [:div.schedule "Schedule view TBD"]])</p>
</td><td class="codes"></td></tr><tr><td class="docs"><p>(deftemplate experiment-editor
 )</p>
</td><td class="codes"></td></tr><tr><td class="docs"><p>(deftemplate trial-creation
 )</p>
</td><td class="codes"></td></tr><tr><td class="docs"><p>COMMENT</p>
</td><td class="codes"></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(deftemplate comment-short-view
  [:div.comment-short
   [:p.comment-text (% content)]
   [:p.comment-sig
    (%strcat &quot;@&quot; (% username))
    &quot; at &quot; (% date-str)]])</pre></td></tr><tr><td class="spacer docs">&nbsp;</td><td class="codes" /></tr><tr><td class="docs"><div class="docs-header"><a class="anchor" href="#experiment.views.test" name="experiment.views.test"><h1 class="project-name">experiment.views.test</h1><a class="toc-link" href="#toc">toc</a></a></div></td><td class="codes" /></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(ns experiment.views.test
  (:require
   [experiment.views.common :as common]
   [noir.response :as response]
   [noir.request :as request])
  (:use noir.core
        experiment.infra.models
        hiccup.core
        hiccup.page-helpers))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defpage &quot;/test&quot; {}
  (common/layout
   [&quot;Test Page&quot;
    (common/default-nav)]
   [:div.content
    [:div.page-header
     [:h1 &quot;Test Page&quot;]
     [:p &quot;This is a test&quot;]]]))</pre></td></tr><tr><td class="spacer docs">&nbsp;</td><td class="codes" /></tr><tr><td class="docs"><div class="docs-header"><a class="anchor" href="#experiment.views.trials" name="experiment.views.trials"><h1 class="project-name">experiment.views.trials</h1><a class="toc-link" href="#toc">toc</a></a></div></td><td class="codes" /></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(ns experiment.views.trials
  (:use
   noir.core
   hiccup.core
   hiccup.page-helpers
   hiccup.form-helpers
   experiment.infra.models
   experiment.models.trial
   experiment.views.common
   handlebars.templates)
  (:require
   [clodown.core :as md]
   [noir.response :as resp]
   [experiment.infra.session :as session]
   [experiment.models.user :as user]
   [experiment.models.profile]
   [experiment.views.bootstrap :as bs]))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(def default-options
  {:tn 1} ;; trial number)</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn treatment-href [treatment]
  (assert (:_id treatment))
  (str &quot;/explore/treatment/&quot; (:_id treatment)))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn trial-empty-summary []
  [:div.page-header
   [:h1 &quot;No Active Trials&quot;]
   [:p [:a {:href &quot;/explore&quot;} &quot;Search for an experiment to run&quot;]]])</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn trial-controls [status]
  (let [play-class (if (= status :active) &quot;btn disabled&quot; &quot;btn&quot;)
        pause-class (if (= status :paused) &quot;btn disabled&quot; &quot;btn&quot;)] 
    (list
     (human-status status)
     &quot;&amp;nbsp;&quot;
     [:span.btn-toolbar
      [:span.btn-group
       [:button.btn [:i.icon-play]]
       [:button.btn [:i.icon-pause]]
       [:button.btn [:i.icon-backward]]
       [:button.btn [:i.icon-stop]]]])))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn trial-summary-body [user trials options]
  (let [options (if (:tn options) options default-options)
        trial-num (:tn options)
        trial (nth trials (- trial-num 1))
        exp (:experiment trial)
        treat (:treatment exp)]
    [:div.trialSummary.well
;;     [:p &quot;Experiment: &quot; (:title exp)]
     [:div.trialBar
      [:h3
       [:span &quot;Treatment: &quot;
        (bs/popover-link (:name treat)
                         (treatment-href treat)
                         &quot;Treatment Description&quot;
                         (md/mdp (:description treat)))]
       &quot;&amp;nbsp;&quot;
       [:span &quot;Primary Outcome: &quot;
        (:variable (:outcome exp))]
       [:span.pull-right
        (trial-controls (:status trial))]]]
     [:div#qichart {:style &quot;height:250px&quot;}]]))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn trial-summary [user options]
  (if-let [trials (user/trials user)]
    (trial-summary-body user
                        (map embed-dbrefs trials)
                        (if (empty? options) default-options options))
    (trial-empty-summary)))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defn trial-complete [user]
  [:div [:p &quot;Foo&quot;]])</pre></td></tr><tr><td class="spacer docs">&nbsp;</td><td class="codes" /></tr><tr><td class="docs"><div class="docs-header"><a class="anchor" href="#experiment.views.welcome" name="experiment.views.welcome"><h1 class="project-name">experiment.views.welcome</h1><a class="toc-link" href="#toc">toc</a></a></div></td><td class="codes" /></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(ns experiment.views.welcome
  (:require [experiment.views.common :as common])
  (:use noir.core
        hiccup.core
        hiccup.page-helpers))</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defpartial welcome-msg [user exp]
  [:div#welcome
   [:p &quot;Welcome &quot; user &quot;, to experiment '&quot; exp &quot;'&quot;]])</pre></td></tr><tr><td class="docs">
</td><td class="codes"><pre class="brush: clojure">(defpage &quot;/welcome&quot; {:keys [user exp]}
  (common/layout
   [:h1 &quot;Experiments&quot;]
   (welcome-msg user exp)))</pre></td></tr><tr><td class="spacer docs">&nbsp;</td><td class="codes" /></tr></table><div class="footer">Generated by <a href="https://github.com/fogus/marginalia">Marginalia</a>.&nbsp;&nbsp;Syntax highlighting provided by Alex Gorbatchev's <a href="http://alexgorbatchev.com/SyntaxHighlighter/">SyntaxHighlighter</a></div><script type="text/javascript">SyntaxHighlighter.defaults['gutter'] = false;
       SyntaxHighlighter.all()</script></body></html>